var He=Object.defineProperty;var Ve=(t,e,n)=>e in t?He(t,e,{enumerable:!0,configurable:!0,writable:!0,value:n}):t[e]=n;var m=(t,e,n)=>(Ve(t,typeof e!="symbol"?e+"":e,n),n);(function(){const e=document.createElement("link").relList;if(e&&e.supports&&e.supports("modulepreload"))return;for(const s of document.querySelectorAll('link[rel="modulepreload"]'))r(s);new MutationObserver(s=>{for(const o of s)if(o.type==="childList")for(const a of o.addedNodes)a.tagName==="LINK"&&a.rel==="modulepreload"&&r(a)}).observe(document,{childList:!0,subtree:!0});function n(s){const o={};return s.integrity&&(o.integrity=s.integrity),s.referrerPolicy&&(o.referrerPolicy=s.referrerPolicy),s.crossOrigin==="use-credentials"?o.credentials="include":s.crossOrigin==="anonymous"?o.credentials="omit":o.credentials="same-origin",o}function r(s){if(s.ep)return;s.ep=!0;const o=n(s);fetch(s.href,o)}})();const styles="";class NotificationManager{constructor(){this.notificationContainer=null,this.initializeContainer()}initializeContainer(){this.notificationContainer=document.getElementById("notifications"),this.notificationContainer||(this.notificationContainer=document.createElement("div"),this.notificationContainer.id="notifications",this.notificationContainer.style.cssText=`
                position: fixed;
                top: 20px;
                right: 20px;
                z-index: 1000;
                max-width: 300px;
            `,document.body.appendChild(this.notificationContainer))}showSuccess(e){this.showNotification(e,"success")}showError(e){this.showNotification(e,"error")}showInfo(e){this.showNotification(e,"info")}showWarning(e){this.showNotification(e,"warning")}showNotification(e,n){if(!this.notificationContainer)return;const r=document.createElement("div");r.className=`notification notification-${n}`,r.textContent=e,r.style.cssText=`
            padding: 12px 16px;
            margin-bottom: 10px;
            border-radius: 4px;
            color: white;
            font-size: 14px;
            box-shadow: 0 2px 8px rgba(0,0,0,0.2);
            opacity: 0;
            transform: translateX(100%);
            transition: all 0.3s ease;
            ${this.getTypeStyles(n)}
        `,this.notificationContainer.appendChild(r),setTimeout(()=>{r.style.opacity="1",r.style.transform="translateX(0)"},10),setTimeout(()=>{this.removeNotification(r)},5e3),r.addEventListener("click",()=>{this.removeNotification(r)})}getTypeStyles(e){switch(e){case"success":return"background-color: #4CAF50;";case"error":return"background-color: #f44336;";case"warning":return"background-color: #ff9800;";case"info":default:return"background-color: #2196F3;"}}removeNotification(e){e.style.opacity="0",e.style.transform="translateX(100%)",setTimeout(()=>{e.parentNode&&e.parentNode.removeChild(e)},300)}updateStatus(e){const n=document.getElementById("status");n&&(n.textContent=e)}clearNotifications(){this.notificationContainer&&(this.notificationContainer.innerHTML="")}}const crypto$3=typeof globalThis=="object"&&"crypto"in globalThis?globalThis.crypto:void 0;/*! noble-hashes - MIT License (c) 2022 Paul Miller (paulmillr.com) */function isBytes$5(t){return t instanceof Uint8Array||ArrayBuffer.isView(t)&&t.constructor.name==="Uint8Array"}function anumber$1(t){if(!Number.isSafeInteger(t)||t<0)throw new Error("positive integer expected, got "+t)}function abytes$2(t,...e){if(!isBytes$5(t))throw new Error("Uint8Array expected");if(e.length>0&&!e.includes(t.length))throw new Error("Uint8Array expected of length "+e+", got length="+t.length)}function ahash(t){if(typeof t!="function"||typeof t.create!="function")throw new Error("Hash should be wrapped by utils.createHasher");anumber$1(t.outputLen),anumber$1(t.blockLen)}function aexists(t,e=!0){if(t.destroyed)throw new Error("Hash instance has been destroyed");if(e&&t.finished)throw new Error("Hash#digest() has already been called")}function aoutput(t,e){abytes$2(t);const n=e.outputLen;if(t.length<n)throw new Error("digestInto() expects output buffer of length at least "+n)}function clean(...t){for(let e=0;e<t.length;e++)t[e].fill(0)}function createView$3(t){return new DataView(t.buffer,t.byteOffset,t.byteLength)}function rotr$2(t,e){return t<<32-e|t>>>e}function rotl$1(t,e){return t<<e|t>>>32-e>>>0}const hasHexBuiltin$2=(()=>typeof Uint8Array.from([]).toHex=="function"&&typeof Uint8Array.fromHex=="function")(),hexes$3=Array.from({length:256},(t,e)=>e.toString(16).padStart(2,"0"));function bytesToHex$3(t){if(abytes$2(t),hasHexBuiltin$2)return t.toHex();let e="";for(let n=0;n<t.length;n++)e+=hexes$3[t[n]];return e}const asciis$1={_0:48,_9:57,A:65,F:70,a:97,f:102};function asciiToBase16$1(t){if(t>=asciis$1._0&&t<=asciis$1._9)return t-asciis$1._0;if(t>=asciis$1.A&&t<=asciis$1.F)return t-(asciis$1.A-10);if(t>=asciis$1.a&&t<=asciis$1.f)return t-(asciis$1.a-10)}function hexToBytes$3(t){if(typeof t!="string")throw new Error("hex string expected, got "+typeof t);if(hasHexBuiltin$2)return Uint8Array.fromHex(t);const e=t.length,n=e/2;if(e%2)throw new Error("hex string expected, got unpadded hex of length "+e);const r=new Uint8Array(n);for(let s=0,o=0;s<n;s++,o+=2){const a=asciiToBase16$1(t.charCodeAt(o)),c=asciiToBase16$1(t.charCodeAt(o+1));if(a===void 0||c===void 0){const l=t[o]+t[o+1];throw new Error('hex string expected, got non-hex character "'+l+'" at index '+o)}r[s]=a*16+c}return r}function utf8ToBytes$3(t){if(typeof t!="string")throw new Error("string expected");return new Uint8Array(new TextEncoder().encode(t))}function toBytes$2(t){return typeof t=="string"&&(t=utf8ToBytes$3(t)),abytes$2(t),t}function concatBytes$6(...t){let e=0;for(let r=0;r<t.length;r++){const s=t[r];abytes$2(s),e+=s.length}const n=new Uint8Array(e);for(let r=0,s=0;r<t.length;r++){const o=t[r];n.set(o,s),s+=o.length}return n}let Hash$2=class{};function createHasher(t){const e=r=>t().update(toBytes$2(r)).digest(),n=t();return e.outputLen=n.outputLen,e.blockLen=n.blockLen,e.create=()=>t(),e}function randomBytes$2(t=32){if(crypto$3&&typeof crypto$3.getRandomValues=="function")return crypto$3.getRandomValues(new Uint8Array(t));if(crypto$3&&typeof crypto$3.randomBytes=="function")return Uint8Array.from(crypto$3.randomBytes(t));throw new Error("crypto.getRandomValues must be defined")}function setBigUint64$2(t,e,n,r){if(typeof t.setBigUint64=="function")return t.setBigUint64(e,n,r);const s=BigInt(32),o=BigInt(4294967295),a=Number(n>>s&o),c=Number(n&o),l=r?4:0,u=r?0:4;t.setUint32(e+l,a,r),t.setUint32(e+u,c,r)}function Chi$2(t,e,n){return t&e^~t&n}function Maj$2(t,e,n){return t&e^t&n^e&n}class HashMD extends Hash$2{constructor(e,n,r,s){super(),this.finished=!1,this.length=0,this.pos=0,this.destroyed=!1,this.blockLen=e,this.outputLen=n,this.padOffset=r,this.isLE=s,this.buffer=new Uint8Array(e),this.view=createView$3(this.buffer)}update(e){aexists(this),e=toBytes$2(e),abytes$2(e);const{view:n,buffer:r,blockLen:s}=this,o=e.length;for(let a=0;a<o;){const c=Math.min(s-this.pos,o-a);if(c===s){const l=createView$3(e);for(;s<=o-a;a+=s)this.process(l,a);continue}r.set(e.subarray(a,a+c),this.pos),this.pos+=c,a+=c,this.pos===s&&(this.process(n,0),this.pos=0)}return this.length+=e.length,this.roundClean(),this}digestInto(e){aexists(this),aoutput(e,this),this.finished=!0;const{buffer:n,view:r,blockLen:s,isLE:o}=this;let{pos:a}=this;n[a++]=128,clean(this.buffer.subarray(a)),this.padOffset>s-a&&(this.process(r,0),a=0);for(let f=a;f<s;f++)n[f]=0;setBigUint64$2(r,s-8,BigInt(this.length*8),o),this.process(r,0);const c=createView$3(e),l=this.outputLen;if(l%4)throw new Error("_sha2: outputLen should be aligned to 32bit");const u=l/4,h=this.get();if(u>h.length)throw new Error("_sha2: outputLen bigger than state");for(let f=0;f<u;f++)c.setUint32(4*f,h[f],o)}digest(){const{buffer:e,outputLen:n}=this;this.digestInto(e);const r=e.slice(0,n);return this.destroy(),r}_cloneInto(e){e||(e=new this.constructor),e.set(...this.get());const{blockLen:n,buffer:r,length:s,finished:o,destroyed:a,pos:c}=this;return e.destroyed=a,e.finished=o,e.length=s,e.pos=c,s%n&&e.buffer.set(r),e}clone(){return this._cloneInto()}}const SHA256_IV=Uint32Array.from([1779033703,3144134277,1013904242,2773480762,1359893119,2600822924,528734635,1541459225]),SHA256_K$2=Uint32Array.from([1116352408,1899447441,3049323471,3921009573,961987163,1508970993,2453635748,2870763221,3624381080,310598401,607225278,1426881987,1925078388,2162078206,2614888103,3248222580,3835390401,4022224774,264347078,604807628,770255983,1249150122,1555081692,1996064986,2554220882,2821834349,2952996808,3210313671,3336571891,3584528711,113926993,338241895,666307205,773529912,1294757372,1396182291,1695183700,1986661051,2177026350,2456956037,2730485921,2820302411,3259730800,3345764771,3516065817,3600352804,4094571909,275423344,430227734,506948616,659060556,883997877,958139571,1322822218,1537002063,1747873779,1955562222,2024104815,2227730452,2361852424,2428436474,2756734187,3204031479,3329325298]),SHA256_W$2=new Uint32Array(64);let SHA256$2=class extends HashMD{constructor(e=32){super(64,e,8,!1),this.A=SHA256_IV[0]|0,this.B=SHA256_IV[1]|0,this.C=SHA256_IV[2]|0,this.D=SHA256_IV[3]|0,this.E=SHA256_IV[4]|0,this.F=SHA256_IV[5]|0,this.G=SHA256_IV[6]|0,this.H=SHA256_IV[7]|0}get(){const{A:e,B:n,C:r,D:s,E:o,F:a,G:c,H:l}=this;return[e,n,r,s,o,a,c,l]}set(e,n,r,s,o,a,c,l){this.A=e|0,this.B=n|0,this.C=r|0,this.D=s|0,this.E=o|0,this.F=a|0,this.G=c|0,this.H=l|0}process(e,n){for(let f=0;f<16;f++,n+=4)SHA256_W$2[f]=e.getUint32(n,!1);for(let f=16;f<64;f++){const p=SHA256_W$2[f-15],g=SHA256_W$2[f-2],w=rotr$2(p,7)^rotr$2(p,18)^p>>>3,y=rotr$2(g,17)^rotr$2(g,19)^g>>>10;SHA256_W$2[f]=y+SHA256_W$2[f-7]+w+SHA256_W$2[f-16]|0}let{A:r,B:s,C:o,D:a,E:c,F:l,G:u,H:h}=this;for(let f=0;f<64;f++){const p=rotr$2(c,6)^rotr$2(c,11)^rotr$2(c,25),g=h+p+Chi$2(c,l,u)+SHA256_K$2[f]+SHA256_W$2[f]|0,y=(rotr$2(r,2)^rotr$2(r,13)^rotr$2(r,22))+Maj$2(r,s,o)|0;h=u,u=l,l=c,c=a+g|0,a=o,o=s,s=r,r=g+y|0}r=r+this.A|0,s=s+this.B|0,o=o+this.C|0,a=a+this.D|0,c=c+this.E|0,l=l+this.F|0,u=u+this.G|0,h=h+this.H|0,this.set(r,s,o,a,c,l,u,h)}roundClean(){clean(SHA256_W$2)}destroy(){this.set(0,0,0,0,0,0,0,0),clean(this.buffer)}};const sha256$3=createHasher(()=>new SHA256$2);let HMAC$2=class extends Hash$2{constructor(e,n){super(),this.finished=!1,this.destroyed=!1,ahash(e);const r=toBytes$2(n);if(this.iHash=e.create(),typeof this.iHash.update!="function")throw new Error("Expected instance of class which extends utils.Hash");this.blockLen=this.iHash.blockLen,this.outputLen=this.iHash.outputLen;const s=this.blockLen,o=new Uint8Array(s);o.set(r.length>s?e.create().update(r).digest():r);for(let a=0;a<o.length;a++)o[a]^=54;this.iHash.update(o),this.oHash=e.create();for(let a=0;a<o.length;a++)o[a]^=106;this.oHash.update(o),clean(o)}update(e){return aexists(this),this.iHash.update(e),this}digestInto(e){aexists(this),abytes$2(e,this.outputLen),this.finished=!0,this.iHash.digestInto(e),this.oHash.update(e),this.oHash.digestInto(e),this.destroy()}digest(){const e=new Uint8Array(this.oHash.outputLen);return this.digestInto(e),e}_cloneInto(e){e||(e=Object.create(Object.getPrototypeOf(this),{}));const{oHash:n,iHash:r,finished:s,destroyed:o,blockLen:a,outputLen:c}=this;return e=e,e.finished=s,e.destroyed=o,e.blockLen=a,e.outputLen=c,e.oHash=n._cloneInto(e.oHash),e.iHash=r._cloneInto(e.iHash),e}clone(){return this._cloneInto()}destroy(){this.destroyed=!0,this.oHash.destroy(),this.iHash.destroy()}};const hmac$2=(t,e,n)=>new HMAC$2(t,e).update(n).digest();hmac$2.create=(t,e)=>new HMAC$2(t,e);/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */const _0n$9=BigInt(0),_1n$9=BigInt(1);function isBytes$4(t){return t instanceof Uint8Array||ArrayBuffer.isView(t)&&t.constructor.name==="Uint8Array"}function abytes$1(t){if(!isBytes$4(t))throw new Error("Uint8Array expected")}function abool(t,e){if(typeof e!="boolean")throw new Error(t+" boolean expected, got "+e)}function numberToHexUnpadded$1(t){const e=t.toString(16);return e.length&1?"0"+e:e}function hexToNumber$1(t){if(typeof t!="string")throw new Error("hex string expected, got "+typeof t);return t===""?_0n$9:BigInt("0x"+t)}const hasHexBuiltin$1=typeof Uint8Array.from([]).toHex=="function"&&typeof Uint8Array.fromHex=="function",hexes$2=Array.from({length:256},(t,e)=>e.toString(16).padStart(2,"0"));function bytesToHex$2(t){if(abytes$1(t),hasHexBuiltin$1)return t.toHex();let e="";for(let n=0;n<t.length;n++)e+=hexes$2[t[n]];return e}const asciis={_0:48,_9:57,A:65,F:70,a:97,f:102};function asciiToBase16(t){if(t>=asciis._0&&t<=asciis._9)return t-asciis._0;if(t>=asciis.A&&t<=asciis.F)return t-(asciis.A-10);if(t>=asciis.a&&t<=asciis.f)return t-(asciis.a-10)}function hexToBytes$2(t){if(typeof t!="string")throw new Error("hex string expected, got "+typeof t);if(hasHexBuiltin$1)return Uint8Array.fromHex(t);const e=t.length,n=e/2;if(e%2)throw new Error("hex string expected, got unpadded hex of length "+e);const r=new Uint8Array(n);for(let s=0,o=0;s<n;s++,o+=2){const a=asciiToBase16(t.charCodeAt(o)),c=asciiToBase16(t.charCodeAt(o+1));if(a===void 0||c===void 0){const l=t[o]+t[o+1];throw new Error('hex string expected, got non-hex character "'+l+'" at index '+o)}r[s]=a*16+c}return r}function bytesToNumberBE$1(t){return hexToNumber$1(bytesToHex$2(t))}function bytesToNumberLE$1(t){return abytes$1(t),hexToNumber$1(bytesToHex$2(Uint8Array.from(t).reverse()))}function numberToBytesBE$1(t,e){return hexToBytes$2(t.toString(16).padStart(e*2,"0"))}function numberToBytesLE$1(t,e){return numberToBytesBE$1(t,e).reverse()}function ensureBytes$1(t,e,n){let r;if(typeof e=="string")try{r=hexToBytes$2(e)}catch(o){throw new Error(t+" must be hex string or Uint8Array, cause: "+o)}else if(isBytes$4(e))r=Uint8Array.from(e);else throw new Error(t+" must be hex string or Uint8Array");const s=r.length;if(typeof n=="number"&&s!==n)throw new Error(t+" of length "+n+" expected, got "+s);return r}function concatBytes$5(...t){let e=0;for(let r=0;r<t.length;r++){const s=t[r];abytes$1(s),e+=s.length}const n=new Uint8Array(e);for(let r=0,s=0;r<t.length;r++){const o=t[r];n.set(o,s),s+=o.length}return n}function equalBytes$4(t,e){if(t.length!==e.length)return!1;let n=0;for(let r=0;r<t.length;r++)n|=t[r]^e[r];return n===0}const isPosBig=t=>typeof t=="bigint"&&_0n$9<=t;function inRange(t,e,n){return isPosBig(t)&&isPosBig(e)&&isPosBig(n)&&e<=t&&t<n}function aInRange(t,e,n,r){if(!inRange(e,n,r))throw new Error("expected valid "+t+": "+n+" <= n < "+r+", got "+e)}function bitLen$1(t){let e;for(e=0;t>_0n$9;t>>=_1n$9,e+=1);return e}const bitMask$1=t=>(_1n$9<<BigInt(t))-_1n$9,u8n$2=t=>new Uint8Array(t),u8fr$1=t=>Uint8Array.from(t);function createHmacDrbg$1(t,e,n){if(typeof t!="number"||t<2)throw new Error("hashLen must be a number");if(typeof e!="number"||e<2)throw new Error("qByteLen must be a number");if(typeof n!="function")throw new Error("hmacFn must be a function");let r=u8n$2(t),s=u8n$2(t),o=0;const a=()=>{r.fill(1),s.fill(0),o=0},c=(...f)=>n(s,r,...f),l=(f=u8n$2(0))=>{s=c(u8fr$1([0]),f),r=c(),f.length!==0&&(s=c(u8fr$1([1]),f),r=c())},u=()=>{if(o++>=1e3)throw new Error("drbg: tried 1000 values");let f=0;const p=[];for(;f<e;){r=c();const g=r.slice();p.push(g),f+=r.length}return concatBytes$5(...p)};return(f,p)=>{a(),l(f);let g;for(;!(g=p(u()));)l();return a(),g}}const validatorFns$1={bigint:t=>typeof t=="bigint",function:t=>typeof t=="function",boolean:t=>typeof t=="boolean",string:t=>typeof t=="string",stringOrUint8Array:t=>typeof t=="string"||isBytes$4(t),isSafeInteger:t=>Number.isSafeInteger(t),array:t=>Array.isArray(t),field:(t,e)=>e.Fp.isValid(t),hash:t=>typeof t=="function"&&Number.isSafeInteger(t.outputLen)};function validateObject$1(t,e,n={}){const r=(s,o,a)=>{const c=validatorFns$1[o];if(typeof c!="function")throw new Error("invalid validator function");const l=t[s];if(!(a&&l===void 0)&&!c(l,t))throw new Error("param "+String(s)+" is invalid. Expected "+o+", got "+l)};for(const[s,o]of Object.entries(e))r(s,o,!1);for(const[s,o]of Object.entries(n))r(s,o,!0);return t}function memoized(t){const e=new WeakMap;return(n,...r)=>{const s=e.get(n);if(s!==void 0)return s;const o=t(n,...r);return e.set(n,o),o}}/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */const _0n$8=BigInt(0),_1n$8=BigInt(1),_2n$4=BigInt(2),_3n$3=BigInt(3),_4n$2=BigInt(4),_5n$1=BigInt(5),_8n$1=BigInt(8);function mod$1(t,e){const n=t%e;return n>=_0n$8?n:e+n}function pow2$1(t,e,n){let r=t;for(;e-- >_0n$8;)r*=r,r%=n;return r}function invert$1(t,e){if(t===_0n$8)throw new Error("invert: expected non-zero number");if(e<=_0n$8)throw new Error("invert: expected positive modulus, got "+e);let n=mod$1(t,e),r=e,s=_0n$8,o=_1n$8;for(;n!==_0n$8;){const c=r/n,l=r%n,u=s-o*c;r=n,n=l,s=o,o=u}if(r!==_1n$8)throw new Error("invert: does not exist");return mod$1(s,e)}function sqrt3mod4(t,e){const n=(t.ORDER+_1n$8)/_4n$2,r=t.pow(e,n);if(!t.eql(t.sqr(r),e))throw new Error("Cannot find square root");return r}function sqrt5mod8(t,e){const n=(t.ORDER-_5n$1)/_8n$1,r=t.mul(e,_2n$4),s=t.pow(r,n),o=t.mul(e,s),a=t.mul(t.mul(o,_2n$4),s),c=t.mul(o,t.sub(a,t.ONE));if(!t.eql(t.sqr(c),e))throw new Error("Cannot find square root");return c}function tonelliShanks$1(t){if(t<BigInt(3))throw new Error("sqrt is not defined for small field");let e=t-_1n$8,n=0;for(;e%_2n$4===_0n$8;)e/=_2n$4,n++;let r=_2n$4;const s=Field$1(t);for(;FpLegendre(s,r)===1;)if(r++>1e3)throw new Error("Cannot find square root: probably non-prime P");if(n===1)return sqrt3mod4;let o=s.pow(r,e);const a=(e+_1n$8)/_2n$4;return function(l,u){if(l.is0(u))return u;if(FpLegendre(l,u)!==1)throw new Error("Cannot find square root");let h=n,f=l.mul(l.ONE,o),p=l.pow(u,e),g=l.pow(u,a);for(;!l.eql(p,l.ONE);){if(l.is0(p))return l.ZERO;let w=1,y=l.sqr(p);for(;!l.eql(y,l.ONE);)if(w++,y=l.sqr(y),w===h)throw new Error("Cannot find square root");const b=_1n$8<<BigInt(h-w-1),x=l.pow(f,b);h=w,f=l.sqr(x),p=l.mul(p,f),g=l.mul(g,x)}return g}}function FpSqrt$1(t){return t%_4n$2===_3n$3?sqrt3mod4:t%_8n$1===_5n$1?sqrt5mod8:tonelliShanks$1(t)}const FIELD_FIELDS$1=["create","isValid","is0","neg","inv","sqrt","sqr","eql","add","sub","mul","pow","div","addN","subN","mulN","sqrN"];function validateField$1(t){const e={ORDER:"bigint",MASK:"bigint",BYTES:"isSafeInteger",BITS:"isSafeInteger"},n=FIELD_FIELDS$1.reduce((r,s)=>(r[s]="function",r),e);return validateObject$1(t,n)}function FpPow$1(t,e,n){if(n<_0n$8)throw new Error("invalid exponent, negatives unsupported");if(n===_0n$8)return t.ONE;if(n===_1n$8)return e;let r=t.ONE,s=e;for(;n>_0n$8;)n&_1n$8&&(r=t.mul(r,s)),s=t.sqr(s),n>>=_1n$8;return r}function FpInvertBatch$1(t,e,n=!1){const r=new Array(e.length).fill(n?t.ZERO:void 0),s=e.reduce((a,c,l)=>t.is0(c)?a:(r[l]=a,t.mul(a,c)),t.ONE),o=t.inv(s);return e.reduceRight((a,c,l)=>t.is0(c)?a:(r[l]=t.mul(a,r[l]),t.mul(a,c)),o),r}function FpLegendre(t,e){const n=(t.ORDER-_1n$8)/_2n$4,r=t.pow(e,n),s=t.eql(r,t.ONE),o=t.eql(r,t.ZERO),a=t.eql(r,t.neg(t.ONE));if(!s&&!o&&!a)throw new Error("invalid Legendre symbol result");return s?1:o?0:-1}function nLength$1(t,e){e!==void 0&&anumber$1(e);const n=e!==void 0?e:t.toString(2).length,r=Math.ceil(n/8);return{nBitLength:n,nByteLength:r}}function Field$1(t,e,n=!1,r={}){if(t<=_0n$8)throw new Error("invalid field: expected ORDER > 0, got "+t);const{nBitLength:s,nByteLength:o}=nLength$1(t,e);if(o>2048)throw new Error("invalid field: expected ORDER of <= 2048 bytes");let a;const c=Object.freeze({ORDER:t,isLE:n,BITS:s,BYTES:o,MASK:bitMask$1(s),ZERO:_0n$8,ONE:_1n$8,create:l=>mod$1(l,t),isValid:l=>{if(typeof l!="bigint")throw new Error("invalid field element: expected bigint, got "+typeof l);return _0n$8<=l&&l<t},is0:l=>l===_0n$8,isOdd:l=>(l&_1n$8)===_1n$8,neg:l=>mod$1(-l,t),eql:(l,u)=>l===u,sqr:l=>mod$1(l*l,t),add:(l,u)=>mod$1(l+u,t),sub:(l,u)=>mod$1(l-u,t),mul:(l,u)=>mod$1(l*u,t),pow:(l,u)=>FpPow$1(c,l,u),div:(l,u)=>mod$1(l*invert$1(u,t),t),sqrN:l=>l*l,addN:(l,u)=>l+u,subN:(l,u)=>l-u,mulN:(l,u)=>l*u,inv:l=>invert$1(l,t),sqrt:r.sqrt||(l=>(a||(a=FpSqrt$1(t)),a(c,l))),toBytes:l=>n?numberToBytesLE$1(l,o):numberToBytesBE$1(l,o),fromBytes:l=>{if(l.length!==o)throw new Error("Field.fromBytes: expected "+o+" bytes, got "+l.length);return n?bytesToNumberLE$1(l):bytesToNumberBE$1(l)},invertBatch:l=>FpInvertBatch$1(c,l),cmov:(l,u,h)=>h?u:l});return Object.freeze(c)}function getFieldBytesLength$1(t){if(typeof t!="bigint")throw new Error("field order must be bigint");const e=t.toString(2).length;return Math.ceil(e/8)}function getMinHashLength$1(t){const e=getFieldBytesLength$1(t);return e+Math.ceil(e/2)}function mapHashToField$1(t,e,n=!1){const r=t.length,s=getFieldBytesLength$1(e),o=getMinHashLength$1(e);if(r<16||r<o||r>1024)throw new Error("expected "+o+"-1024 bytes of input, got "+r);const a=n?bytesToNumberLE$1(t):bytesToNumberBE$1(t),c=mod$1(a,e-_1n$8)+_1n$8;return n?numberToBytesLE$1(c,s):numberToBytesBE$1(c,s)}/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */const _0n$7=BigInt(0),_1n$7=BigInt(1);function constTimeNegate(t,e){const n=e.negate();return t?n:e}function validateW(t,e){if(!Number.isSafeInteger(t)||t<=0||t>e)throw new Error("invalid window size, expected [1.."+e+"], got W="+t)}function calcWOpts(t,e){validateW(t,e);const n=Math.ceil(e/t)+1,r=2**(t-1),s=2**t,o=bitMask$1(t),a=BigInt(t);return{windows:n,windowSize:r,mask:o,maxNumber:s,shiftBy:a}}function calcOffsets(t,e,n){const{windowSize:r,mask:s,maxNumber:o,shiftBy:a}=n;let c=Number(t&s),l=t>>a;c>r&&(c-=o,l+=_1n$7);const u=e*r,h=u+Math.abs(c)-1,f=c===0,p=c<0,g=e%2!==0;return{nextN:l,offset:h,isZero:f,isNeg:p,isNegF:g,offsetF:u}}function validateMSMPoints(t,e){if(!Array.isArray(t))throw new Error("array expected");t.forEach((n,r)=>{if(!(n instanceof e))throw new Error("invalid point at index "+r)})}function validateMSMScalars(t,e){if(!Array.isArray(t))throw new Error("array of scalars expected");t.forEach((n,r)=>{if(!e.isValid(n))throw new Error("invalid scalar at index "+r)})}const pointPrecomputes=new WeakMap,pointWindowSizes=new WeakMap;function getW(t){return pointWindowSizes.get(t)||1}function wNAF$2(t,e){return{constTimeNegate,hasPrecomputes(n){return getW(n)!==1},unsafeLadder(n,r,s=t.ZERO){let o=n;for(;r>_0n$7;)r&_1n$7&&(s=s.add(o)),o=o.double(),r>>=_1n$7;return s},precomputeWindow(n,r){const{windows:s,windowSize:o}=calcWOpts(r,e),a=[];let c=n,l=c;for(let u=0;u<s;u++){l=c,a.push(l);for(let h=1;h<o;h++)l=l.add(c),a.push(l);c=l.double()}return a},wNAF(n,r,s){let o=t.ZERO,a=t.BASE;const c=calcWOpts(n,e);for(let l=0;l<c.windows;l++){const{nextN:u,offset:h,isZero:f,isNeg:p,isNegF:g,offsetF:w}=calcOffsets(s,l,c);s=u,f?a=a.add(constTimeNegate(g,r[w])):o=o.add(constTimeNegate(p,r[h]))}return{p:o,f:a}},wNAFUnsafe(n,r,s,o=t.ZERO){const a=calcWOpts(n,e);for(let c=0;c<a.windows&&s!==_0n$7;c++){const{nextN:l,offset:u,isZero:h,isNeg:f}=calcOffsets(s,c,a);if(s=l,!h){const p=r[u];o=o.add(f?p.negate():p)}}return o},getPrecomputes(n,r,s){let o=pointPrecomputes.get(r);return o||(o=this.precomputeWindow(r,n),n!==1&&pointPrecomputes.set(r,s(o))),o},wNAFCached(n,r,s){const o=getW(n);return this.wNAF(o,this.getPrecomputes(o,n,s),r)},wNAFCachedUnsafe(n,r,s,o){const a=getW(n);return a===1?this.unsafeLadder(n,r,o):this.wNAFUnsafe(a,this.getPrecomputes(a,n,s),r,o)},setWindowSize(n,r){validateW(r,e),pointWindowSizes.set(n,r),pointPrecomputes.delete(n)}}}function pippenger(t,e,n,r){validateMSMPoints(n,t),validateMSMScalars(r,e);const s=n.length,o=r.length;if(s!==o)throw new Error("arrays of points and scalars must have equal length");const a=t.ZERO,c=bitLen$1(BigInt(s));let l=1;c>12?l=c-3:c>4?l=c-2:c>0&&(l=2);const u=bitMask$1(l),h=new Array(Number(u)+1).fill(a),f=Math.floor((e.BITS-1)/l)*l;let p=a;for(let g=f;g>=0;g-=l){h.fill(a);for(let y=0;y<o;y++){const b=r[y],x=Number(b>>BigInt(g)&u);h[x]=h[x].add(n[y])}let w=a;for(let y=h.length-1,b=a;y>0;y--)b=b.add(h[y]),w=w.add(b);if(p=p.add(w),g!==0)for(let y=0;y<l;y++)p=p.double()}return p}function validateBasic$1(t){return validateField$1(t.Fp),validateObject$1(t,{n:"bigint",h:"bigint",Gx:"field",Gy:"field"},{nBitLength:"isSafeInteger",nByteLength:"isSafeInteger"}),Object.freeze({...nLength$1(t.n,t.nBitLength),...t,p:t.Fp.ORDER})}/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */function validateSigVerOpts(t){t.lowS!==void 0&&abool("lowS",t.lowS),t.prehash!==void 0&&abool("prehash",t.prehash)}function validatePointOpts$1(t){const e=validateBasic$1(t);validateObject$1(e,{a:"field",b:"field"},{allowInfinityPoint:"boolean",allowedPrivateKeyLengths:"array",clearCofactor:"function",fromBytes:"function",isTorsionFree:"function",toBytes:"function",wrapPrivateKey:"boolean"});const{endo:n,Fp:r,a:s}=e;if(n){if(!r.eql(s,r.ZERO))throw new Error("invalid endo: CURVE.a must be 0");if(typeof n!="object"||typeof n.beta!="bigint"||typeof n.splitScalar!="function")throw new Error('invalid endo: expected "beta": bigint and "splitScalar": function')}return Object.freeze({...e})}class DERErr extends Error{constructor(e=""){super(e)}}const DER$1={Err:DERErr,_tlv:{encode:(t,e)=>{const{Err:n}=DER$1;if(t<0||t>256)throw new n("tlv.encode: wrong tag");if(e.length&1)throw new n("tlv.encode: unpadded data");const r=e.length/2,s=numberToHexUnpadded$1(r);if(s.length/2&128)throw new n("tlv.encode: long form length too big");const o=r>127?numberToHexUnpadded$1(s.length/2|128):"";return numberToHexUnpadded$1(t)+o+s+e},decode(t,e){const{Err:n}=DER$1;let r=0;if(t<0||t>256)throw new n("tlv.encode: wrong tag");if(e.length<2||e[r++]!==t)throw new n("tlv.decode: wrong tlv");const s=e[r++],o=!!(s&128);let a=0;if(!o)a=s;else{const l=s&127;if(!l)throw new n("tlv.decode(long): indefinite length not supported");if(l>4)throw new n("tlv.decode(long): byte length is too big");const u=e.subarray(r,r+l);if(u.length!==l)throw new n("tlv.decode: length bytes not complete");if(u[0]===0)throw new n("tlv.decode(long): zero leftmost byte");for(const h of u)a=a<<8|h;if(r+=l,a<128)throw new n("tlv.decode(long): not minimal encoding")}const c=e.subarray(r,r+a);if(c.length!==a)throw new n("tlv.decode: wrong value length");return{v:c,l:e.subarray(r+a)}}},_int:{encode(t){const{Err:e}=DER$1;if(t<_0n$6)throw new e("integer: negative integers are not allowed");let n=numberToHexUnpadded$1(t);if(Number.parseInt(n[0],16)&8&&(n="00"+n),n.length&1)throw new e("unexpected DER parsing assertion: unpadded hex");return n},decode(t){const{Err:e}=DER$1;if(t[0]&128)throw new e("invalid signature integer: negative");if(t[0]===0&&!(t[1]&128))throw new e("invalid signature integer: unnecessary leading zero");return bytesToNumberBE$1(t)}},toSig(t){const{Err:e,_int:n,_tlv:r}=DER$1,s=ensureBytes$1("signature",t),{v:o,l:a}=r.decode(48,s);if(a.length)throw new e("invalid signature: left bytes after parsing");const{v:c,l}=r.decode(2,o),{v:u,l:h}=r.decode(2,l);if(h.length)throw new e("invalid signature: left bytes after parsing");return{r:n.decode(c),s:n.decode(u)}},hexFromSig(t){const{_tlv:e,_int:n}=DER$1,r=e.encode(2,n.encode(t.r)),s=e.encode(2,n.encode(t.s)),o=r+s;return e.encode(48,o)}};function numToSizedHex(t,e){return bytesToHex$2(numberToBytesBE$1(t,e))}const _0n$6=BigInt(0),_1n$6=BigInt(1);BigInt(2);const _3n$2=BigInt(3),_4n$1=BigInt(4);function weierstrassPoints$1(t){const e=validatePointOpts$1(t),{Fp:n}=e,r=Field$1(e.n,e.nBitLength),s=e.toBytes||((R,$,A)=>{const L=$.toAffine();return concatBytes$5(Uint8Array.from([4]),n.toBytes(L.x),n.toBytes(L.y))}),o=e.fromBytes||(R=>{const $=R.subarray(1),A=n.fromBytes($.subarray(0,n.BYTES)),L=n.fromBytes($.subarray(n.BYTES,2*n.BYTES));return{x:A,y:L}});function a(R){const{a:$,b:A}=e,L=n.sqr(R),v=n.mul(L,R);return n.add(n.add(v,n.mul(R,$)),A)}function c(R,$){const A=n.sqr($),L=a(R);return n.eql(A,L)}if(!c(e.Gx,e.Gy))throw new Error("bad curve params: generator point");const l=n.mul(n.pow(e.a,_3n$2),_4n$1),u=n.mul(n.sqr(e.b),BigInt(27));if(n.is0(n.add(l,u)))throw new Error("bad curve params: a or b");function h(R){return inRange(R,_1n$6,e.n)}function f(R){const{allowedPrivateKeyLengths:$,nByteLength:A,wrapPrivateKey:L,n:v}=e;if($&&typeof R!="bigint"){if(isBytes$4(R)&&(R=bytesToHex$2(R)),typeof R!="string"||!$.includes(R.length))throw new Error("invalid private key");R=R.padStart(A*2,"0")}let D;try{D=typeof R=="bigint"?R:bytesToNumberBE$1(ensureBytes$1("private key",R,A))}catch{throw new Error("invalid private key, expected hex or "+A+" bytes, got "+typeof R)}return L&&(D=mod$1(D,v)),aInRange("private key",D,_1n$6,v),D}function p(R){if(!(R instanceof y))throw new Error("ProjectivePoint expected")}const g=memoized((R,$)=>{const{px:A,py:L,pz:v}=R;if(n.eql(v,n.ONE))return{x:A,y:L};const D=R.is0();$==null&&($=D?n.ONE:n.inv(v));const j=n.mul(A,$),z=n.mul(L,$),E=n.mul(v,$);if(D)return{x:n.ZERO,y:n.ZERO};if(!n.eql(E,n.ONE))throw new Error("invZ was invalid");return{x:j,y:z}}),w=memoized(R=>{if(R.is0()){if(e.allowInfinityPoint&&!n.is0(R.py))return;throw new Error("bad point: ZERO")}const{x:$,y:A}=R.toAffine();if(!n.isValid($)||!n.isValid(A))throw new Error("bad point: x or y not FE");if(!c($,A))throw new Error("bad point: equation left != right");if(!R.isTorsionFree())throw new Error("bad point: not in prime-order subgroup");return!0});class y{constructor($,A,L){if($==null||!n.isValid($))throw new Error("x required");if(A==null||!n.isValid(A)||n.is0(A))throw new Error("y required");if(L==null||!n.isValid(L))throw new Error("z required");this.px=$,this.py=A,this.pz=L,Object.freeze(this)}static fromAffine($){const{x:A,y:L}=$||{};if(!$||!n.isValid(A)||!n.isValid(L))throw new Error("invalid affine point");if($ instanceof y)throw new Error("projective point not allowed");const v=D=>n.eql(D,n.ZERO);return v(A)&&v(L)?y.ZERO:new y(A,L,n.ONE)}get x(){return this.toAffine().x}get y(){return this.toAffine().y}static normalizeZ($){const A=FpInvertBatch$1(n,$.map(L=>L.pz));return $.map((L,v)=>L.toAffine(A[v])).map(y.fromAffine)}static fromHex($){const A=y.fromAffine(o(ensureBytes$1("pointHex",$)));return A.assertValidity(),A}static fromPrivateKey($){return y.BASE.multiply(f($))}static msm($,A){return pippenger(y,r,$,A)}_setWindowSize($){_.setWindowSize(this,$)}assertValidity(){w(this)}hasEvenY(){const{y:$}=this.toAffine();if(n.isOdd)return!n.isOdd($);throw new Error("Field doesn't support isOdd")}equals($){p($);const{px:A,py:L,pz:v}=this,{px:D,py:j,pz:z}=$,E=n.eql(n.mul(A,z),n.mul(D,v)),k=n.eql(n.mul(L,z),n.mul(j,v));return E&&k}negate(){return new y(this.px,n.neg(this.py),this.pz)}double(){const{a:$,b:A}=e,L=n.mul(A,_3n$2),{px:v,py:D,pz:j}=this;let z=n.ZERO,E=n.ZERO,k=n.ZERO,B=n.mul(v,v),H=n.mul(D,D),S=n.mul(j,j),T=n.mul(v,D);return T=n.add(T,T),k=n.mul(v,j),k=n.add(k,k),z=n.mul($,k),E=n.mul(L,S),E=n.add(z,E),z=n.sub(H,E),E=n.add(H,E),E=n.mul(z,E),z=n.mul(T,z),k=n.mul(L,k),S=n.mul($,S),T=n.sub(B,S),T=n.mul($,T),T=n.add(T,k),k=n.add(B,B),B=n.add(k,B),B=n.add(B,S),B=n.mul(B,T),E=n.add(E,B),S=n.mul(D,j),S=n.add(S,S),B=n.mul(S,T),z=n.sub(z,B),k=n.mul(S,H),k=n.add(k,k),k=n.add(k,k),new y(z,E,k)}add($){p($);const{px:A,py:L,pz:v}=this,{px:D,py:j,pz:z}=$;let E=n.ZERO,k=n.ZERO,B=n.ZERO;const H=e.a,S=n.mul(e.b,_3n$2);let T=n.mul(A,D),U=n.mul(L,j),K=n.mul(v,z),O=n.add(A,L),V=n.add(D,j);O=n.mul(O,V),V=n.add(T,U),O=n.sub(O,V),V=n.add(A,v);let F=n.add(D,z);return V=n.mul(V,F),F=n.add(T,K),V=n.sub(V,F),F=n.add(L,v),E=n.add(j,z),F=n.mul(F,E),E=n.add(U,K),F=n.sub(F,E),B=n.mul(H,V),E=n.mul(S,K),B=n.add(E,B),E=n.sub(U,B),B=n.add(U,B),k=n.mul(E,B),U=n.add(T,T),U=n.add(U,T),K=n.mul(H,K),V=n.mul(S,V),U=n.add(U,K),K=n.sub(T,K),K=n.mul(H,K),V=n.add(V,K),T=n.mul(U,V),k=n.add(k,T),T=n.mul(F,V),E=n.mul(O,E),E=n.sub(E,T),T=n.mul(O,U),B=n.mul(F,B),B=n.add(B,T),new y(E,k,B)}subtract($){return this.add($.negate())}is0(){return this.equals(y.ZERO)}wNAF($){return _.wNAFCached(this,$,y.normalizeZ)}multiplyUnsafe($){const{endo:A,n:L}=e;aInRange("scalar",$,_0n$6,L);const v=y.ZERO;if($===_0n$6)return v;if(this.is0()||$===_1n$6)return this;if(!A||_.hasPrecomputes(this))return _.wNAFCachedUnsafe(this,$,y.normalizeZ);let{k1neg:D,k1:j,k2neg:z,k2:E}=A.splitScalar($),k=v,B=v,H=this;for(;j>_0n$6||E>_0n$6;)j&_1n$6&&(k=k.add(H)),E&_1n$6&&(B=B.add(H)),H=H.double(),j>>=_1n$6,E>>=_1n$6;return D&&(k=k.negate()),z&&(B=B.negate()),B=new y(n.mul(B.px,A.beta),B.py,B.pz),k.add(B)}multiply($){const{endo:A,n:L}=e;aInRange("scalar",$,_1n$6,L);let v,D;if(A){const{k1neg:j,k1:z,k2neg:E,k2:k}=A.splitScalar($);let{p:B,f:H}=this.wNAF(z),{p:S,f:T}=this.wNAF(k);B=_.constTimeNegate(j,B),S=_.constTimeNegate(E,S),S=new y(n.mul(S.px,A.beta),S.py,S.pz),v=B.add(S),D=H.add(T)}else{const{p:j,f:z}=this.wNAF($);v=j,D=z}return y.normalizeZ([v,D])[0]}multiplyAndAddUnsafe($,A,L){const v=y.BASE,D=(z,E)=>E===_0n$6||E===_1n$6||!z.equals(v)?z.multiplyUnsafe(E):z.multiply(E),j=D(this,A).add(D($,L));return j.is0()?void 0:j}toAffine($){return g(this,$)}isTorsionFree(){const{h:$,isTorsionFree:A}=e;if($===_1n$6)return!0;if(A)return A(y,this);throw new Error("isTorsionFree() has not been declared for the elliptic curve")}clearCofactor(){const{h:$,clearCofactor:A}=e;return $===_1n$6?this:A?A(y,this):this.multiplyUnsafe(e.h)}toRawBytes($=!0){return abool("isCompressed",$),this.assertValidity(),s(y,this,$)}toHex($=!0){return abool("isCompressed",$),bytesToHex$2(this.toRawBytes($))}}y.BASE=new y(e.Gx,e.Gy,n.ONE),y.ZERO=new y(n.ZERO,n.ONE,n.ZERO);const{endo:b,nBitLength:x}=e,_=wNAF$2(y,b?Math.ceil(x/2):x);return{CURVE:e,ProjectivePoint:y,normPrivateKeyToScalar:f,weierstrassEquation:a,isWithinCurveOrder:h}}function validateOpts$2(t){const e=validateBasic$1(t);return validateObject$1(e,{hash:"hash",hmac:"function",randomBytes:"function"},{bits2int:"function",bits2int_modN:"function",lowS:"boolean"}),Object.freeze({lowS:!0,...e})}function weierstrass$1(t){const e=validateOpts$2(t),{Fp:n,n:r,nByteLength:s,nBitLength:o}=e,a=n.BYTES+1,c=2*n.BYTES+1;function l(S){return mod$1(S,r)}function u(S){return invert$1(S,r)}const{ProjectivePoint:h,normPrivateKeyToScalar:f,weierstrassEquation:p,isWithinCurveOrder:g}=weierstrassPoints$1({...e,toBytes(S,T,U){const K=T.toAffine(),O=n.toBytes(K.x),V=concatBytes$5;return abool("isCompressed",U),U?V(Uint8Array.from([T.hasEvenY()?2:3]),O):V(Uint8Array.from([4]),O,n.toBytes(K.y))},fromBytes(S){const T=S.length,U=S[0],K=S.subarray(1);if(T===a&&(U===2||U===3)){const O=bytesToNumberBE$1(K);if(!inRange(O,_1n$6,n.ORDER))throw new Error("Point is not on curve");const V=p(O);let F;try{F=n.sqrt(V)}catch(Z){const X=Z instanceof Error?": "+Z.message:"";throw new Error("Point is not on curve"+X)}const q=(F&_1n$6)===_1n$6;return(U&1)===1!==q&&(F=n.neg(F)),{x:O,y:F}}else if(T===c&&U===4){const O=n.fromBytes(K.subarray(0,n.BYTES)),V=n.fromBytes(K.subarray(n.BYTES,2*n.BYTES));return{x:O,y:V}}else{const O=a,V=c;throw new Error("invalid Point, expected length of "+O+", or uncompressed "+V+", got "+T)}}});function w(S){const T=r>>_1n$6;return S>T}function y(S){return w(S)?l(-S):S}const b=(S,T,U)=>bytesToNumberBE$1(S.slice(T,U));class x{constructor(T,U,K){aInRange("r",T,_1n$6,r),aInRange("s",U,_1n$6,r),this.r=T,this.s=U,K!=null&&(this.recovery=K),Object.freeze(this)}static fromCompact(T){const U=s;return T=ensureBytes$1("compactSignature",T,U*2),new x(b(T,0,U),b(T,U,2*U))}static fromDER(T){const{r:U,s:K}=DER$1.toSig(ensureBytes$1("DER",T));return new x(U,K)}assertValidity(){}addRecoveryBit(T){return new x(this.r,this.s,T)}recoverPublicKey(T){const{r:U,s:K,recovery:O}=this,V=v(ensureBytes$1("msgHash",T));if(O==null||![0,1,2,3].includes(O))throw new Error("recovery id invalid");const F=O===2||O===3?U+e.n:U;if(F>=n.ORDER)throw new Error("recovery id 2 or 3 invalid");const q=O&1?"03":"02",Y=h.fromHex(q+numToSizedHex(F,n.BYTES)),Z=u(F),X=l(-V*Z),te=l(K*Z),J=h.BASE.multiplyAndAddUnsafe(Y,X,te);if(!J)throw new Error("point at infinify");return J.assertValidity(),J}hasHighS(){return w(this.s)}normalizeS(){return this.hasHighS()?new x(this.r,l(-this.s),this.recovery):this}toDERRawBytes(){return hexToBytes$2(this.toDERHex())}toDERHex(){return DER$1.hexFromSig(this)}toCompactRawBytes(){return hexToBytes$2(this.toCompactHex())}toCompactHex(){const T=s;return numToSizedHex(this.r,T)+numToSizedHex(this.s,T)}}const _={isValidPrivateKey(S){try{return f(S),!0}catch{return!1}},normPrivateKeyToScalar:f,randomPrivateKey:()=>{const S=getMinHashLength$1(e.n);return mapHashToField$1(e.randomBytes(S),e.n)},precompute(S=8,T=h.BASE){return T._setWindowSize(S),T.multiply(BigInt(3)),T}};function R(S,T=!0){return h.fromPrivateKey(S).toRawBytes(T)}function $(S){if(typeof S=="bigint")return!1;if(S instanceof h)return!0;const U=ensureBytes$1("key",S).length,K=n.BYTES,O=K+1,V=2*K+1;if(!(e.allowedPrivateKeyLengths||s===O))return U===O||U===V}function A(S,T,U=!0){if($(S)===!0)throw new Error("first arg must be private key");if($(T)===!1)throw new Error("second arg must be public key");return h.fromHex(T).multiply(f(S)).toRawBytes(U)}const L=e.bits2int||function(S){if(S.length>8192)throw new Error("input is too large");const T=bytesToNumberBE$1(S),U=S.length*8-o;return U>0?T>>BigInt(U):T},v=e.bits2int_modN||function(S){return l(L(S))},D=bitMask$1(o);function j(S){return aInRange("num < 2^"+o,S,_0n$6,D),numberToBytesBE$1(S,s)}function z(S,T,U=E){if(["recovered","canonical"].some(ne=>ne in U))throw new Error("sign() legacy options not supported");const{hash:K,randomBytes:O}=e;let{lowS:V,prehash:F,extraEntropy:q}=U;V==null&&(V=!0),S=ensureBytes$1("msgHash",S),validateSigVerOpts(U),F&&(S=ensureBytes$1("prehashed msgHash",K(S)));const Y=v(S),Z=f(T),X=[j(Z),j(Y)];if(q!=null&&q!==!1){const ne=q===!0?O(n.BYTES):q;X.push(ensureBytes$1("extraEntropy",ne))}const te=concatBytes$5(...X),J=Y;function oe(ne){const re=L(ne);if(!g(re))return;const Be=u(re),ie=h.BASE.multiply(re).toAffine(),Q=l(ie.x);if(Q===_0n$6)return;const se=l(Be*l(J+Q*Z));if(se===_0n$6)return;let le=(ie.x===Q?0:2)|Number(ie.y&_1n$6),ce=se;return V&&w(se)&&(ce=y(se),le^=1),new x(Q,ce,le)}return{seed:te,k2sig:oe}}const E={lowS:e.lowS,prehash:!1},k={lowS:e.lowS,prehash:!1};function B(S,T,U=E){const{seed:K,k2sig:O}=z(S,T,U),V=e;return createHmacDrbg$1(V.hash.outputLen,V.nByteLength,V.hmac)(K,O)}h.BASE._setWindowSize(8);function H(S,T,U,K=k){var le;const O=S;T=ensureBytes$1("msgHash",T),U=ensureBytes$1("publicKey",U);const{lowS:V,prehash:F,format:q}=K;if(validateSigVerOpts(K),"strict"in K)throw new Error("options.strict was renamed to lowS");if(q!==void 0&&q!=="compact"&&q!=="der")throw new Error("format must be compact or der");const Y=typeof O=="string"||isBytes$4(O),Z=!Y&&!q&&typeof O=="object"&&O!==null&&typeof O.r=="bigint"&&typeof O.s=="bigint";if(!Y&&!Z)throw new Error("invalid signature, expected Uint8Array, hex string or Signature instance");let X,te;try{if(Z&&(X=new x(O.r,O.s)),Y){try{q!=="compact"&&(X=x.fromDER(O))}catch(ce){if(!(ce instanceof DER$1.Err))throw ce}!X&&q!=="der"&&(X=x.fromCompact(O))}te=h.fromHex(U)}catch{return!1}if(!X||V&&X.hasHighS())return!1;F&&(T=e.hash(T));const{r:J,s:oe}=X,ne=v(T),re=u(oe),Be=l(ne*re),ie=l(J*re),Q=(le=h.BASE.multiplyAndAddUnsafe(te,Be,ie))==null?void 0:le.toAffine();return Q?l(Q.x)===J:!1}return{CURVE:e,getPublicKey:R,getSharedSecret:A,sign:B,verify:H,ProjectivePoint:h,Signature:x,utils:_}}/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */function getHash$1(t){return{hash:t,hmac:(e,...n)=>hmac$2(t,e,concatBytes$6(...n)),randomBytes:randomBytes$2}}function createCurve$1(t,e){const n=r=>weierstrass$1({...t,...getHash$1(r)});return{...n(e),create:n}}/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */const secp256k1P$1=BigInt("0xfffffffffffffffffffffffffffffffffffffffffffffffffffffffefffffc2f"),secp256k1N$1=BigInt("0xfffffffffffffffffffffffffffffffebaaedce6af48a03bbfd25e8cd0364141"),_0n$5=BigInt(0),_1n$5=BigInt(1),_2n$3=BigInt(2),divNearest$1=(t,e)=>(t+e/_2n$3)/e;function sqrtMod$1(t){const e=secp256k1P$1,n=BigInt(3),r=BigInt(6),s=BigInt(11),o=BigInt(22),a=BigInt(23),c=BigInt(44),l=BigInt(88),u=t*t*t%e,h=u*u*t%e,f=pow2$1(h,n,e)*h%e,p=pow2$1(f,n,e)*h%e,g=pow2$1(p,_2n$3,e)*u%e,w=pow2$1(g,s,e)*g%e,y=pow2$1(w,o,e)*w%e,b=pow2$1(y,c,e)*y%e,x=pow2$1(b,l,e)*b%e,_=pow2$1(x,c,e)*y%e,R=pow2$1(_,n,e)*h%e,$=pow2$1(R,a,e)*w%e,A=pow2$1($,r,e)*u%e,L=pow2$1(A,_2n$3,e);if(!Fpk1.eql(Fpk1.sqr(L),t))throw new Error("Cannot find square root");return L}const Fpk1=Field$1(secp256k1P$1,void 0,void 0,{sqrt:sqrtMod$1}),secp256k1$1=createCurve$1({a:_0n$5,b:BigInt(7),Fp:Fpk1,n:secp256k1N$1,Gx:BigInt("55066263022277343669578718895168534326250603453777594175500187360389116729240"),Gy:BigInt("32670510020758816978083085130507043184471273380659243275938904335757337482424"),h:BigInt(1),lowS:!0,endo:{beta:BigInt("0x7ae96a2b657c07106e64479eac3434e99cf0497512f58995c1396c28719501ee"),splitScalar:t=>{const e=secp256k1N$1,n=BigInt("0x3086d221a7d46bcde86c90e49284eb15"),r=-_1n$5*BigInt("0xe4437ed6010e88286f547fa90abfe4c3"),s=BigInt("0x114ca50f7a8e2f3f657c1108d9d44cfd8"),o=n,a=BigInt("0x100000000000000000000000000000000"),c=divNearest$1(o*t,e),l=divNearest$1(-r*t,e);let u=mod$1(t-c*n-l*s,e),h=mod$1(-c*r-l*o,e);const f=u>a,p=h>a;if(f&&(u=e-u),p&&(h=e-h),u>a||h>a)throw new Error("splitScalar: Endomorphism failed, k="+t);return{k1neg:f,k1:u,k2neg:p,k2:h}}}},sha256$3),TAGGED_HASH_PREFIXES$1={};function taggedHash$2(t,...e){let n=TAGGED_HASH_PREFIXES$1[t];if(n===void 0){const r=sha256$3(Uint8Array.from(t,s=>s.charCodeAt(0)));n=concatBytes$5(r,r),TAGGED_HASH_PREFIXES$1[t]=n}return sha256$3(concatBytes$5(n,...e))}const pointToBytes$2=t=>t.toRawBytes(!0).slice(1),numTo32b$1=t=>numberToBytesBE$1(t,32),modP$1=t=>mod$1(t,secp256k1P$1),modN$2=t=>mod$1(t,secp256k1N$1),Point$4=(()=>secp256k1$1.ProjectivePoint)(),GmulAdd$1=(t,e,n)=>Point$4.BASE.multiplyAndAddUnsafe(t,e,n);function schnorrGetExtPubKey$1(t){let e=secp256k1$1.utils.normPrivateKeyToScalar(t),n=Point$4.fromPrivateKey(e);return{scalar:n.hasEvenY()?e:modN$2(-e),bytes:pointToBytes$2(n)}}function lift_x$1(t){aInRange("x",t,_1n$5,secp256k1P$1);const e=modP$1(t*t),n=modP$1(e*t+BigInt(7));let r=sqrtMod$1(n);r%_2n$3!==_0n$5&&(r=modP$1(-r));const s=new Point$4(t,r,_1n$5);return s.assertValidity(),s}const num=bytesToNumberBE$1;function challenge$1(...t){return modN$2(num(taggedHash$2("BIP0340/challenge",...t)))}function schnorrGetPublicKey$1(t){return schnorrGetExtPubKey$1(t).bytes}function schnorrSign$1(t,e,n=randomBytes$2(32)){const r=ensureBytes$1("message",t),{bytes:s,scalar:o}=schnorrGetExtPubKey$1(e),a=ensureBytes$1("auxRand",n,32),c=numTo32b$1(o^num(taggedHash$2("BIP0340/aux",a))),l=taggedHash$2("BIP0340/nonce",c,s,r),u=modN$2(num(l));if(u===_0n$5)throw new Error("sign failed: k is zero");const{bytes:h,scalar:f}=schnorrGetExtPubKey$1(u),p=challenge$1(h,s,r),g=new Uint8Array(64);if(g.set(h,0),g.set(numTo32b$1(modN$2(f+p*o)),32),!schnorrVerify$1(g,r,s))throw new Error("sign: Invalid signature produced");return g}function schnorrVerify$1(t,e,n){const r=ensureBytes$1("signature",t,64),s=ensureBytes$1("message",e),o=ensureBytes$1("publicKey",n,32);try{const a=lift_x$1(num(o)),c=num(r.subarray(0,32));if(!inRange(c,_1n$5,secp256k1P$1))return!1;const l=num(r.subarray(32,64));if(!inRange(l,_1n$5,secp256k1N$1))return!1;const u=challenge$1(numTo32b$1(c),pointToBytes$2(a),s),h=GmulAdd$1(a,l,modN$2(-u));return!(!h||!h.hasEvenY()||h.toAffine().x!==c)}catch{return!1}}const schnorr$1=(()=>({getPublicKey:schnorrGetPublicKey$1,sign:schnorrSign$1,verify:schnorrVerify$1,utils:{randomPrivateKey:secp256k1$1.utils.randomPrivateKey,lift_x:lift_x$1,pointToBytes:pointToBytes$2,numberToBytesBE:numberToBytesBE$1,bytesToNumberBE:bytesToNumberBE$1,taggedHash:taggedHash$2,mod:mod$1}}))(),Rho160=Uint8Array.from([7,4,13,1,10,6,15,3,12,0,9,5,2,14,11,8]),Id160=(()=>Uint8Array.from(new Array(16).fill(0).map((t,e)=>e)))(),Pi160=(()=>Id160.map(t=>(9*t+5)%16))(),idxLR=(()=>{const n=[[Id160],[Pi160]];for(let r=0;r<4;r++)for(let s of n)s.push(s[r].map(o=>Rho160[o]));return n})(),idxL=(()=>idxLR[0])(),idxR=(()=>idxLR[1])(),shifts160=[[11,14,15,12,5,8,7,9,11,13,14,15,6,7,9,8],[12,13,11,15,6,9,9,7,12,15,11,13,7,8,7,7],[13,15,14,11,7,7,6,8,13,14,13,12,5,5,6,9],[14,11,12,14,8,6,5,5,15,12,15,14,9,9,8,6],[15,12,13,13,9,5,8,6,14,11,12,11,8,6,5,5]].map(t=>Uint8Array.from(t)),shiftsL160=idxL.map((t,e)=>t.map(n=>shifts160[e][n])),shiftsR160=idxR.map((t,e)=>t.map(n=>shifts160[e][n])),Kl160=Uint32Array.from([0,1518500249,1859775393,2400959708,2840853838]),Kr160=Uint32Array.from([1352829926,1548603684,1836072691,2053994217,0]);function ripemd_f(t,e,n,r){return t===0?e^n^r:t===1?e&n|~e&r:t===2?(e|~n)^r:t===3?e&r|n&~r:e^(n|~r)}const BUF_160=new Uint32Array(16);class RIPEMD160 extends HashMD{constructor(){super(64,20,8,!0),this.h0=1732584193,this.h1=-271733879,this.h2=-1732584194,this.h3=271733878,this.h4=-1009589776}get(){const{h0:e,h1:n,h2:r,h3:s,h4:o}=this;return[e,n,r,s,o]}set(e,n,r,s,o){this.h0=e|0,this.h1=n|0,this.h2=r|0,this.h3=s|0,this.h4=o|0}process(e,n){for(let g=0;g<16;g++,n+=4)BUF_160[g]=e.getUint32(n,!0);let r=this.h0|0,s=r,o=this.h1|0,a=o,c=this.h2|0,l=c,u=this.h3|0,h=u,f=this.h4|0,p=f;for(let g=0;g<5;g++){const w=4-g,y=Kl160[g],b=Kr160[g],x=idxL[g],_=idxR[g],R=shiftsL160[g],$=shiftsR160[g];for(let A=0;A<16;A++){const L=rotl$1(r+ripemd_f(g,o,c,u)+BUF_160[x[A]]+y,R[A])+f|0;r=f,f=u,u=rotl$1(c,10)|0,c=o,o=L}for(let A=0;A<16;A++){const L=rotl$1(s+ripemd_f(w,a,l,h)+BUF_160[_[A]]+b,$[A])+p|0;s=p,p=h,h=rotl$1(l,10)|0,l=a,a=L}}this.set(this.h1+c+h|0,this.h2+u+p|0,this.h3+f+s|0,this.h4+r+a|0,this.h0+o+l|0)}roundClean(){clean(BUF_160)}destroy(){this.destroyed=!0,clean(this.buffer),this.set(0,0,0,0,0)}}const ripemd160=createHasher(()=>new RIPEMD160);/*! scure-base - MIT License (c) 2022 Paul Miller (paulmillr.com) */function isBytes$3(t){return t instanceof Uint8Array||ArrayBuffer.isView(t)&&t.constructor.name==="Uint8Array"}function abytes(t,...e){if(!isBytes$3(t))throw new Error("Uint8Array expected");if(e.length>0&&!e.includes(t.length))throw new Error("Uint8Array expected of length "+e+", got length="+t.length)}function isArrayOf(t,e){return Array.isArray(e)?e.length===0?!0:t?e.every(n=>typeof n=="string"):e.every(n=>Number.isSafeInteger(n)):!1}function afn(t){if(typeof t!="function")throw new Error("function expected");return!0}function astr(t,e){if(typeof e!="string")throw new Error(`${t}: string expected`);return!0}function anumber(t){if(!Number.isSafeInteger(t))throw new Error(`invalid integer: ${t}`)}function aArr(t){if(!Array.isArray(t))throw new Error("array expected")}function astrArr(t,e){if(!isArrayOf(!0,e))throw new Error(`${t}: array of strings expected`)}function anumArr(t,e){if(!isArrayOf(!1,e))throw new Error(`${t}: array of numbers expected`)}function chain$1(...t){const e=o=>o,n=(o,a)=>c=>o(a(c)),r=t.map(o=>o.encode).reduceRight(n,e),s=t.map(o=>o.decode).reduce(n,e);return{encode:r,decode:s}}function alphabet$1(t){const e=typeof t=="string"?t.split(""):t,n=e.length;astrArr("alphabet",e);const r=new Map(e.map((s,o)=>[s,o]));return{encode:s=>(aArr(s),s.map(o=>{if(!Number.isSafeInteger(o)||o<0||o>=n)throw new Error(`alphabet.encode: digit index outside alphabet "${o}". Allowed: ${t}`);return e[o]})),decode:s=>(aArr(s),s.map(o=>{astr("alphabet.decode",o);const a=r.get(o);if(a===void 0)throw new Error(`Unknown letter: "${o}". Allowed: ${t}`);return a}))}}function join$1(t=""){return astr("join",t),{encode:e=>(astrArr("join.decode",e),e.join(t)),decode:e=>(astr("join.decode",e),e.split(t))}}function padding$1(t,e="="){return anumber(t),astr("padding",e),{encode(n){for(astrArr("padding.encode",n);n.length*t%8;)n.push(e);return n},decode(n){astrArr("padding.decode",n);let r=n.length;if(r*t%8)throw new Error("padding: invalid, string should have whole number of bytes");for(;r>0&&n[r-1]===e;r--)if((r-1)*t%8===0)throw new Error("padding: invalid, string has too much padding");return n.slice(0,r)}}}function normalize$2(t){return afn(t),{encode:e=>e,decode:e=>t(e)}}function convertRadix$1(t,e,n){if(e<2)throw new Error(`convertRadix: invalid from=${e}, base cannot be less than 2`);if(n<2)throw new Error(`convertRadix: invalid to=${n}, base cannot be less than 2`);if(aArr(t),!t.length)return[];let r=0;const s=[],o=Array.from(t,c=>{if(anumber(c),c<0||c>=e)throw new Error(`invalid integer: ${c}`);return c}),a=o.length;for(;;){let c=0,l=!0;for(let u=r;u<a;u++){const h=o[u],f=e*c,p=f+h;if(!Number.isSafeInteger(p)||f/e!==c||p-h!==f)throw new Error("convertRadix: carry overflow");const g=p/n;c=p%n;const w=Math.floor(g);if(o[u]=w,!Number.isSafeInteger(w)||w*n+c!==p)throw new Error("convertRadix: carry overflow");if(l)w?l=!1:r=u;else continue}if(s.push(c),l)break}for(let c=0;c<t.length-1&&t[c]===0;c++)s.push(0);return s.reverse()}const gcd$1=(t,e)=>e===0?t:gcd$1(e,t%e),radix2carry$1=(t,e)=>t+(e-gcd$1(t,e)),powers=(()=>{let t=[];for(let e=0;e<40;e++)t.push(2**e);return t})();function convertRadix2$1(t,e,n,r){if(aArr(t),e<=0||e>32)throw new Error(`convertRadix2: wrong from=${e}`);if(n<=0||n>32)throw new Error(`convertRadix2: wrong to=${n}`);if(radix2carry$1(e,n)>32)throw new Error(`convertRadix2: carry overflow from=${e} to=${n} carryBits=${radix2carry$1(e,n)}`);let s=0,o=0;const a=powers[e],c=powers[n]-1,l=[];for(const u of t){if(anumber(u),u>=a)throw new Error(`convertRadix2: invalid data word=${u} from=${e}`);if(s=s<<e|u,o+e>32)throw new Error(`convertRadix2: carry overflow pos=${o} from=${e}`);for(o+=e;o>=n;o-=n)l.push((s>>o-n&c)>>>0);const h=powers[o];if(h===void 0)throw new Error("invalid carry");s&=h-1}if(s=s<<n-o&c,!r&&o>=e)throw new Error("Excess padding");if(!r&&s>0)throw new Error(`Non-zero padding: ${s}`);return r&&o>0&&l.push(s>>>0),l}function radix$1(t){anumber(t);const e=2**8;return{encode:n=>{if(!isBytes$3(n))throw new Error("radix.encode input should be Uint8Array");return convertRadix$1(Array.from(n),e,t)},decode:n=>(anumArr("radix.decode",n),Uint8Array.from(convertRadix$1(n,t,e)))}}function radix2$1(t,e=!1){if(anumber(t),t<=0||t>32)throw new Error("radix2: bits should be in (0..32]");if(radix2carry$1(8,t)>32||radix2carry$1(t,8)>32)throw new Error("radix2: carry overflow");return{encode:n=>{if(!isBytes$3(n))throw new Error("radix2.encode input should be Uint8Array");return convertRadix2$1(Array.from(n),8,t,!e)},decode:n=>(anumArr("radix2.decode",n),Uint8Array.from(convertRadix2$1(n,t,8,e)))}}function unsafeWrapper$1(t){return afn(t),function(...e){try{return t.apply(null,e)}catch{}}}function checksum(t,e){return anumber(t),afn(e),{encode(n){if(!isBytes$3(n))throw new Error("checksum.encode: input should be Uint8Array");const r=e(n).slice(0,t),s=new Uint8Array(n.length+t);return s.set(n),s.set(r,n.length),s},decode(n){if(!isBytes$3(n))throw new Error("checksum.decode: input should be Uint8Array");const r=n.slice(0,-t),s=n.slice(-t),o=e(r).slice(0,t);for(let a=0;a<t;a++)if(o[a]!==s[a])throw new Error("Invalid checksum");return r}}}const utils$3={alphabet:alphabet$1,chain:chain$1,checksum,convertRadix:convertRadix$1,convertRadix2:convertRadix2$1,radix:radix$1,radix2:radix2$1,join:join$1,padding:padding$1},base16$1=chain$1(radix2$1(4),alphabet$1("0123456789ABCDEF"),join$1("")),base32$1=chain$1(radix2$1(5),alphabet$1("ABCDEFGHIJKLMNOPQRSTUVWXYZ234567"),padding$1(5),join$1("")),base32nopad=chain$1(radix2$1(5),alphabet$1("ABCDEFGHIJKLMNOPQRSTUVWXYZ234567"),join$1("")),base32hex=chain$1(radix2$1(5),alphabet$1("0123456789ABCDEFGHIJKLMNOPQRSTUV"),padding$1(5),join$1("")),base32hexnopad=chain$1(radix2$1(5),alphabet$1("0123456789ABCDEFGHIJKLMNOPQRSTUV"),join$1("")),base32crockford=chain$1(radix2$1(5),alphabet$1("0123456789ABCDEFGHJKMNPQRSTVWXYZ"),join$1(""),normalize$2(t=>t.toUpperCase().replace(/O/g,"0").replace(/[IL]/g,"1"))),hasBase64Builtin=(()=>typeof Uint8Array.from([]).toBase64=="function"&&typeof Uint8Array.fromBase64=="function")(),decodeBase64Builtin=(t,e)=>{astr("base64",t);const n=e?/^[A-Za-z0-9=_-]+$/:/^[A-Za-z0-9=+/]+$/,r=e?"base64url":"base64";if(t.length>0&&!n.test(t))throw new Error("invalid base64");return Uint8Array.fromBase64(t,{alphabet:r,lastChunkHandling:"strict"})},base64$1=hasBase64Builtin?{encode(t){return abytes(t),t.toBase64()},decode(t){return decodeBase64Builtin(t,!1)}}:chain$1(radix2$1(6),alphabet$1("ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/"),padding$1(6),join$1("")),base64nopad=chain$1(radix2$1(6),alphabet$1("ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/"),join$1("")),base64url$1=hasBase64Builtin?{encode(t){return abytes(t),t.toBase64({alphabet:"base64url"})},decode(t){return decodeBase64Builtin(t,!0)}}:chain$1(radix2$1(6),alphabet$1("ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-_"),padding$1(6),join$1("")),base64urlnopad=chain$1(radix2$1(6),alphabet$1("ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-_"),join$1("")),genBase58$1=t=>chain$1(radix$1(58),alphabet$1(t),join$1("")),base58$1=genBase58$1("123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz"),base58flickr=genBase58$1("123456789abcdefghijkmnopqrstuvwxyzABCDEFGHJKLMNPQRSTUVWXYZ"),base58xrp=genBase58$1("rpshnaf39wBUDNEGHJKLM4PQRST7VWXYZ2bcdeCg65jkm8oFqi1tuvAxyz"),XMR_BLOCK_LEN$1=[0,2,3,5,6,7,9,10,11],base58xmr$1={encode(t){let e="";for(let n=0;n<t.length;n+=8){const r=t.subarray(n,n+8);e+=base58$1.encode(r).padStart(XMR_BLOCK_LEN$1[r.length],"1")}return e},decode(t){let e=[];for(let n=0;n<t.length;n+=11){const r=t.slice(n,n+11),s=XMR_BLOCK_LEN$1.indexOf(r.length),o=base58$1.decode(r);for(let a=0;a<o.length-s;a++)if(o[a]!==0)throw new Error("base58xmr: wrong padding");e=e.concat(Array.from(o.slice(o.length-s)))}return Uint8Array.from(e)}},createBase58check=t=>chain$1(checksum(4,e=>t(t(e))),base58$1),base58check$1=createBase58check,BECH_ALPHABET$1=chain$1(alphabet$1("qpzry9x8gf2tvdw0s3jn54khce6mua7l"),join$1("")),POLYMOD_GENERATORS$1=[996825010,642813549,513874426,1027748829,705979059];function bech32Polymod$1(t){const e=t>>25;let n=(t&33554431)<<5;for(let r=0;r<POLYMOD_GENERATORS$1.length;r++)(e>>r&1)===1&&(n^=POLYMOD_GENERATORS$1[r]);return n}function bechChecksum$1(t,e,n=1){const r=t.length;let s=1;for(let o=0;o<r;o++){const a=t.charCodeAt(o);if(a<33||a>126)throw new Error(`Invalid prefix (${t})`);s=bech32Polymod$1(s)^a>>5}s=bech32Polymod$1(s);for(let o=0;o<r;o++)s=bech32Polymod$1(s)^t.charCodeAt(o)&31;for(let o of e)s=bech32Polymod$1(s)^o;for(let o=0;o<6;o++)s=bech32Polymod$1(s);return s^=n,BECH_ALPHABET$1.encode(convertRadix2$1([s%powers[30]],30,5,!1))}function genBech32$1(t){const e=t==="bech32"?1:734539939,n=radix2$1(5),r=n.decode,s=n.encode,o=unsafeWrapper$1(r);function a(f,p,g=90){astr("bech32.encode prefix",f),isBytes$3(p)&&(p=Array.from(p)),anumArr("bech32.encode",p);const w=f.length;if(w===0)throw new TypeError(`Invalid prefix length ${w}`);const y=w+7+p.length;if(g!==!1&&y>g)throw new TypeError(`Length ${y} exceeds limit ${g}`);const b=f.toLowerCase(),x=bechChecksum$1(b,p,e);return`${b}1${BECH_ALPHABET$1.encode(p)}${x}`}function c(f,p=90){astr("bech32.decode input",f);const g=f.length;if(g<8||p!==!1&&g>p)throw new TypeError(`invalid string length: ${g} (${f}). Expected (8..${p})`);const w=f.toLowerCase();if(f!==w&&f!==f.toUpperCase())throw new Error("String must be lowercase or uppercase");const y=w.lastIndexOf("1");if(y===0||y===-1)throw new Error('Letter "1" must be present between prefix and data only');const b=w.slice(0,y),x=w.slice(y+1);if(x.length<6)throw new Error("Data must be at least 6 characters long");const _=BECH_ALPHABET$1.decode(x).slice(0,-6),R=bechChecksum$1(b,_,e);if(!x.endsWith(R))throw new Error(`Invalid checksum in ${f}: expected "${R}"`);return{prefix:b,words:_}}const l=unsafeWrapper$1(c);function u(f){const{prefix:p,words:g}=c(f,!1);return{prefix:p,words:g,bytes:r(g)}}function h(f,p){return a(f,s(p))}return{encode:a,decode:c,encodeFromBytes:h,decodeToBytes:u,decodeUnsafe:l,fromWords:r,fromWordsUnsafe:o,toWords:s}}const bech32$1=genBech32$1("bech32"),bech32m=genBech32$1("bech32m"),utf8$1={encode:t=>new TextDecoder().decode(t),decode:t=>new TextEncoder().encode(t)},hasHexBuiltin=(()=>typeof Uint8Array.from([]).toHex=="function"&&typeof Uint8Array.fromHex=="function")(),hexBuiltin={encode(t){return abytes(t),t.toHex()},decode(t){return astr("hex",t),Uint8Array.fromHex(t)}},hex$1=hasHexBuiltin?hexBuiltin:chain$1(radix2$1(4),alphabet$1("0123456789abcdef"),join$1(""),normalize$2(t=>{if(typeof t!="string"||t.length%2!==0)throw new TypeError(`hex.decode: expected string, got ${typeof t} with length ${t.length}`);return t.toLowerCase()})),CODERS$1={utf8:utf8$1,hex:hex$1,base16:base16$1,base32:base32$1,base64:base64$1,base64url:base64url$1,base58:base58$1,base58xmr:base58xmr$1},coderTypeError="Invalid encoding type. Available types: utf8, hex, base16, base32, base64, base64url, base58, base58xmr",bytesToString=(t,e)=>{if(typeof t!="string"||!CODERS$1.hasOwnProperty(t))throw new TypeError(coderTypeError);if(!isBytes$3(e))throw new TypeError("bytesToString() expects Uint8Array");return CODERS$1[t].encode(e)},str=bytesToString,stringToBytes=(t,e)=>{if(!CODERS$1.hasOwnProperty(t))throw new TypeError(coderTypeError);if(typeof e!="string")throw new TypeError("stringToBytes() expects string");return CODERS$1[t].decode(e)},bytes$3=stringToBytes,index=Object.freeze(Object.defineProperty({__proto__:null,base16:base16$1,base32:base32$1,base32crockford,base32hex,base32hexnopad,base32nopad,base58:base58$1,base58check:base58check$1,base58flickr,base58xmr:base58xmr$1,base58xrp,base64:base64$1,base64nopad,base64url:base64url$1,base64urlnopad,bech32:bech32$1,bech32m,bytes:bytes$3,bytesToString,createBase58check,hex:hex$1,str,stringToBytes,utf8:utf8$1,utils:utils$3},Symbol.toStringTag,{value:"Module"})),EMPTY=new Uint8Array,NULL=new Uint8Array([0]);function equalBytes$3(t,e){if(t.length!==e.length)return!1;for(let n=0;n<t.length;n++)if(t[n]!==e[n])return!1;return!0}function isBytes$2(t){return t instanceof Uint8Array||ArrayBuffer.isView(t)&&t.constructor.name==="Uint8Array"}function concatBytes$4(...t){let e=0;for(let r=0;r<t.length;r++){const s=t[r];if(!isBytes$2(s))throw new Error("Uint8Array expected");e+=s.length}const n=new Uint8Array(e);for(let r=0,s=0;r<t.length;r++){const o=t[r];n.set(o,s),s+=o.length}return n}const createView$2=t=>new DataView(t.buffer,t.byteOffset,t.byteLength);function isPlainObject(t){return Object.prototype.toString.call(t)==="[object Object]"}function isNum(t){return Number.isSafeInteger(t)}const utils$2={equalBytes:equalBytes$3,isBytes:isBytes$2,isCoder,checkBounds,concatBytes:concatBytes$4,createView:createView$2,isPlainObject},lengthCoder=t=>{if(t!==null&&typeof t!="string"&&!isCoder(t)&&!isBytes$2(t)&&!isNum(t))throw new Error(`lengthCoder: expected null | number | Uint8Array | CoderType, got ${t} (${typeof t})`);return{encodeStream(e,n){if(t===null)return;if(isCoder(t))return t.encodeStream(e,n);let r;if(typeof t=="number"?r=t:typeof t=="string"&&(r=Path.resolve(e.stack,t)),typeof r=="bigint"&&(r=Number(r)),r===void 0||r!==n)throw e.err(`Wrong length: ${r} len=${t} exp=${n} (${typeof n})`)},decodeStream(e){let n;if(isCoder(t)?n=Number(t.decodeStream(e)):typeof t=="number"?n=t:typeof t=="string"&&(n=Path.resolve(e.stack,t)),typeof n=="bigint"&&(n=Number(n)),typeof n!="number")throw e.err(`Wrong length: ${n}`);return n}}},Bitset={BITS:32,FULL_MASK:-1>>>0,len:t=>Math.ceil(t/32),create:t=>new Uint32Array(Bitset.len(t)),clean:t=>t.fill(0),debug:t=>Array.from(t).map(e=>(e>>>0).toString(2).padStart(32,"0")),checkLen:(t,e)=>{if(Bitset.len(e)!==t.length)throw new Error(`wrong length=${t.length}. Expected: ${Bitset.len(e)}`)},chunkLen:(t,e,n)=>{if(e<0)throw new Error(`wrong pos=${e}`);if(e+n>t)throw new Error(`wrong range=${e}/${n} of ${t}`)},set:(t,e,n,r=!0)=>!r&&t[e]&n?!1:(t[e]|=n,!0),pos:(t,e)=>({chunk:Math.floor((t+e)/32),mask:1<<32-(t+e)%32-1}),indices:(t,e,n=!1)=>{Bitset.checkLen(t,e);const{FULL_MASK:r,BITS:s}=Bitset,o=s-e%s,a=o?r>>>o<<o:r,c=[];for(let l=0;l<t.length;l++){let u=t[l];if(n&&(u=~u),l===t.length-1&&(u&=a),u!==0)for(let h=0;h<s;h++){const f=1<<s-h-1;u&f&&c.push(l*s+h)}}return c},range:t=>{const e=[];let n;for(const r of t)n===void 0||r!==n.pos+n.length?e.push(n={pos:r,length:1}):n.length+=1;return e},rangeDebug:(t,e,n=!1)=>`[${Bitset.range(Bitset.indices(t,e,n)).map(r=>`(${r.pos}/${r.length})`).join(", ")}]`,setRange:(t,e,n,r,s=!0)=>{Bitset.chunkLen(e,n,r);const{FULL_MASK:o,BITS:a}=Bitset,c=n%a?Math.floor(n/a):void 0,l=n+r,u=l%a?Math.floor(l/a):void 0;if(c!==void 0&&c===u)return Bitset.set(t,c,o>>>a-r<<a-r-n,s);if(c!==void 0&&!Bitset.set(t,c,o>>>n%a,s))return!1;const h=c!==void 0?c+1:n/a,f=u!==void 0?u:l/a;for(let p=h;p<f;p++)if(!Bitset.set(t,p,o,s))return!1;return!(u!==void 0&&c!==u&&!Bitset.set(t,u,o<<a-l%a,s))}},Path={pushObj:(t,e,n)=>{const r={obj:e};t.push(r),n((s,o)=>{r.field=s,o(),r.field=void 0}),t.pop()},path:t=>{const e=[];for(const n of t)n.field!==void 0&&e.push(n.field);return e.join("/")},err:(t,e,n)=>{const r=new Error(`${t}(${Path.path(e)}): ${typeof n=="string"?n:n.message}`);return n instanceof Error&&n.stack&&(r.stack=n.stack),r},resolve:(t,e)=>{const n=e.split("/"),r=t.map(a=>a.obj);let s=0;for(;s<n.length&&n[s]==="..";s++)r.pop();let o=r.pop();for(;s<n.length;s++){if(!o||o[n[s]]===void 0)return;o=o[n[s]]}return o}};class _Reader{constructor(e,n={},r=[],s=void 0,o=0){this.pos=0,this.bitBuf=0,this.bitPos=0,this.data=e,this.opts=n,this.stack=r,this.parent=s,this.parentOffset=o,this.view=createView$2(e)}_enablePointers(){if(this.parent)return this.parent._enablePointers();this.bs||(this.bs=Bitset.create(this.data.length),Bitset.setRange(this.bs,this.data.length,0,this.pos,this.opts.allowMultipleReads))}markBytesBS(e,n){return this.parent?this.parent.markBytesBS(this.parentOffset+e,n):!n||!this.bs?!0:Bitset.setRange(this.bs,this.data.length,e,n,!1)}markBytes(e){const n=this.pos;this.pos+=e;const r=this.markBytesBS(n,e);if(!this.opts.allowMultipleReads&&!r)throw this.err(`multiple read pos=${this.pos} len=${e}`);return r}pushObj(e,n){return Path.pushObj(this.stack,e,n)}readView(e,n){if(!Number.isFinite(e))throw this.err(`readView: wrong length=${e}`);if(this.pos+e>this.data.length)throw this.err("readView: Unexpected end of buffer");const r=n(this.view,this.pos);return this.markBytes(e),r}absBytes(e){if(e>this.data.length)throw new Error("Unexpected end of buffer");return this.data.subarray(e)}finish(){if(!this.opts.allowUnreadBytes){if(this.bitPos)throw this.err(`${this.bitPos} bits left after unpack: ${hex$1.encode(this.data.slice(this.pos))}`);if(this.bs&&!this.parent){const e=Bitset.indices(this.bs,this.data.length,!0);if(e.length){const n=Bitset.range(e).map(({pos:r,length:s})=>`(${r}/${s})[${hex$1.encode(this.data.subarray(r,r+s))}]`).join(", ");throw this.err(`unread byte ranges: ${n} (total=${this.data.length})`)}else return}if(!this.isEnd())throw this.err(`${this.leftBytes} bytes ${this.bitPos} bits left after unpack: ${hex$1.encode(this.data.slice(this.pos))}`)}}err(e){return Path.err("Reader",this.stack,e)}offsetReader(e){if(e>this.data.length)throw this.err("offsetReader: Unexpected end of buffer");return new _Reader(this.absBytes(e),this.opts,this.stack,this,e)}bytes(e,n=!1){if(this.bitPos)throw this.err("readBytes: bitPos not empty");if(!Number.isFinite(e))throw this.err(`readBytes: wrong length=${e}`);if(this.pos+e>this.data.length)throw this.err("readBytes: Unexpected end of buffer");const r=this.data.subarray(this.pos,this.pos+e);return n||this.markBytes(e),r}byte(e=!1){if(this.bitPos)throw this.err("readByte: bitPos not empty");if(this.pos+1>this.data.length)throw this.err("readBytes: Unexpected end of buffer");const n=this.data[this.pos];return e||this.markBytes(1),n}get leftBytes(){return this.data.length-this.pos}get totalBytes(){return this.data.length}isEnd(){return this.pos>=this.data.length&&!this.bitPos}bits(e){if(e>32)throw this.err("BitReader: cannot read more than 32 bits in single call");let n=0;for(;e;){this.bitPos||(this.bitBuf=this.byte(),this.bitPos=8);const r=Math.min(e,this.bitPos);this.bitPos-=r,n=n<<r|this.bitBuf>>this.bitPos&2**r-1,this.bitBuf&=2**this.bitPos-1,e-=r}return n>>>0}find(e,n=this.pos){if(!isBytes$2(e))throw this.err(`find: needle is not bytes! ${e}`);if(this.bitPos)throw this.err("findByte: bitPos not empty");if(!e.length)throw this.err("find: needle is empty");for(let r=n;(r=this.data.indexOf(e[0],r))!==-1;r++){if(r===-1||this.data.length-r<e.length)return;if(equalBytes$3(e,this.data.subarray(r,r+e.length)))return r}}}class _Writer{constructor(e=[]){this.pos=0,this.buffers=[],this.ptrs=[],this.bitBuf=0,this.bitPos=0,this.viewBuf=new Uint8Array(8),this.finished=!1,this.stack=e,this.view=createView$2(this.viewBuf)}pushObj(e,n){return Path.pushObj(this.stack,e,n)}writeView(e,n){if(this.finished)throw this.err("buffer: finished");if(!isNum(e)||e>8)throw new Error(`wrong writeView length=${e}`);n(this.view),this.bytes(this.viewBuf.slice(0,e)),this.viewBuf.fill(0)}err(e){if(this.finished)throw this.err("buffer: finished");return Path.err("Reader",this.stack,e)}bytes(e){if(this.finished)throw this.err("buffer: finished");if(this.bitPos)throw this.err("writeBytes: ends with non-empty bit buffer");this.buffers.push(e),this.pos+=e.length}byte(e){if(this.finished)throw this.err("buffer: finished");if(this.bitPos)throw this.err("writeByte: ends with non-empty bit buffer");this.buffers.push(new Uint8Array([e])),this.pos++}finish(e=!0){if(this.finished)throw this.err("buffer: finished");if(this.bitPos)throw this.err("buffer: ends with non-empty bit buffer");const n=this.buffers.concat(this.ptrs.map(o=>o.buffer)),r=n.map(o=>o.length).reduce((o,a)=>o+a,0),s=new Uint8Array(r);for(let o=0,a=0;o<n.length;o++){const c=n[o];s.set(c,a),a+=c.length}for(let o=this.pos,a=0;a<this.ptrs.length;a++){const c=this.ptrs[a];s.set(c.ptr.encode(o),c.pos),o+=c.buffer.length}if(e){this.buffers=[];for(const o of this.ptrs)o.buffer.fill(0);this.ptrs=[],this.finished=!0,this.bitBuf=0}return s}bits(e,n){if(n>32)throw this.err("writeBits: cannot write more than 32 bits in single call");if(e>=2**n)throw this.err(`writeBits: value (${e}) >= 2**bits (${n})`);for(;n;){const r=Math.min(n,8-this.bitPos);this.bitBuf=this.bitBuf<<r|e>>n-r,this.bitPos+=r,n-=r,e&=2**n-1,this.bitPos===8&&(this.bitPos=0,this.buffers.push(new Uint8Array([this.bitBuf])),this.pos++)}}}const swapEndianness=t=>Uint8Array.from(t).reverse();function checkBounds(t,e,n){if(n){const r=2n**(e-1n);if(t<-r||t>=r)throw new Error(`value out of signed bounds. Expected ${-r} <= ${t} < ${r}`)}else if(0n>t||t>=2n**e)throw new Error(`value out of unsigned bounds. Expected 0 <= ${t} < ${2n**e}`)}function _wrap(t){return{encodeStream:t.encodeStream,decodeStream:t.decodeStream,size:t.size,encode:e=>{const n=new _Writer;return t.encodeStream(n,e),n.finish()},decode:(e,n={})=>{const r=new _Reader(e,n),s=t.decodeStream(r);return r.finish(),s}}}function validate$1(t,e){if(!isCoder(t))throw new Error(`validate: invalid inner value ${t}`);if(typeof e!="function")throw new Error("validate: fn should be function");return _wrap({size:t.size,encodeStream:(n,r)=>{let s;try{s=e(r)}catch(o){throw n.err(o)}t.encodeStream(n,s)},decodeStream:n=>{const r=t.decodeStream(n);try{return e(r)}catch(s){throw n.err(s)}}})}const wrap=t=>{const e=_wrap(t);return t.validate?validate$1(e,t.validate):e},isBaseCoder=t=>isPlainObject(t)&&typeof t.decode=="function"&&typeof t.encode=="function";function isCoder(t){return isPlainObject(t)&&isBaseCoder(t)&&typeof t.encodeStream=="function"&&typeof t.decodeStream=="function"&&(t.size===void 0||isNum(t.size))}function dict(){return{encode:t=>{if(!Array.isArray(t))throw new Error("array expected");const e={};for(const n of t){if(!Array.isArray(n)||n.length!==2)throw new Error("array of two elements expected");const r=n[0],s=n[1];if(e[r]!==void 0)throw new Error(`key(${r}) appears twice in struct`);e[r]=s}return e},decode:t=>{if(!isPlainObject(t))throw new Error(`expected plain object, got ${t}`);return Object.entries(t)}}}const numberBigint={encode:t=>{if(typeof t!="bigint")throw new Error(`expected bigint, got ${typeof t}`);if(t>BigInt(Number.MAX_SAFE_INTEGER))throw new Error(`element bigger than MAX_SAFE_INTEGER=${t}`);return Number(t)},decode:t=>{if(!isNum(t))throw new Error("element is not a safe integer");return BigInt(t)}};function tsEnum(t){if(!isPlainObject(t))throw new Error("plain object expected");return{encode:e=>{if(!isNum(e)||!(e in t))throw new Error(`wrong value ${e}`);return t[e]},decode:e=>{if(typeof e!="string")throw new Error(`wrong value ${typeof e}`);return t[e]}}}function decimal(t,e=!1){if(!isNum(t))throw new Error(`decimal/precision: wrong value ${t}`);if(typeof e!="boolean")throw new Error(`decimal/round: expected boolean, got ${typeof e}`);const n=10n**BigInt(t);return{encode:r=>{if(typeof r!="bigint")throw new Error(`expected bigint, got ${typeof r}`);let s=(r<0n?-r:r).toString(10),o=s.length-t;o<0&&(s=s.padStart(s.length-o,"0"),o=0);let a=s.length-1;for(;a>=o&&s[a]==="0";a--);let c=s.slice(0,o),l=s.slice(o,a+1);return c||(c="0"),r<0n&&(c="-"+c),l?`${c}.${l}`:c},decode:r=>{if(typeof r!="string")throw new Error(`expected string, got ${typeof r}`);if(r==="-0")throw new Error("negative zero is not allowed");let s=!1;if(r.startsWith("-")&&(s=!0,r=r.slice(1)),!/^(0|[1-9]\d*)(\.\d+)?$/.test(r))throw new Error(`wrong string value=${r}`);let o=r.indexOf(".");o=o===-1?r.length:o;const a=r.slice(0,o),c=r.slice(o+1).replace(/0+$/,""),l=BigInt(a)*n;if(!e&&c.length>t)throw new Error(`fractional part cannot be represented with this precision (num=${r}, prec=${t})`);const u=Math.min(c.length,t),h=BigInt(c.slice(0,u))*10n**BigInt(t-u),f=l+h;return s?-f:f}}}function match(t){if(!Array.isArray(t))throw new Error(`expected array, got ${typeof t}`);for(const e of t)if(!isBaseCoder(e))throw new Error(`wrong base coder ${e}`);return{encode:e=>{for(const n of t){const r=n.encode(e);if(r!==void 0)return r}throw new Error(`match/encode: cannot find match in ${e}`)},decode:e=>{for(const n of t){const r=n.decode(e);if(r!==void 0)return r}throw new Error(`match/decode: cannot find match in ${e}`)}}}const reverse=t=>{if(!isBaseCoder(t))throw new Error("BaseCoder expected");return{encode:t.decode,decode:t.encode}},coders={dict,numberBigint,tsEnum,decimal,match,reverse},bigint=(t,e=!1,n=!1,r=!0)=>{if(!isNum(t))throw new Error(`bigint/size: wrong value ${t}`);if(typeof e!="boolean")throw new Error(`bigint/le: expected boolean, got ${typeof e}`);if(typeof n!="boolean")throw new Error(`bigint/signed: expected boolean, got ${typeof n}`);if(typeof r!="boolean")throw new Error(`bigint/sized: expected boolean, got ${typeof r}`);const s=BigInt(t),o=2n**(8n*s-1n);return wrap({size:r?t:void 0,encodeStream:(a,c)=>{n&&c<0&&(c=c|o);const l=[];for(let h=0;h<t;h++)l.push(Number(c&255n)),c>>=8n;let u=new Uint8Array(l).reverse();if(!r){let h=0;for(h=0;h<u.length&&u[h]===0;h++);u=u.subarray(h)}a.bytes(e?u.reverse():u)},decodeStream:a=>{const c=a.bytes(r?t:Math.min(t,a.leftBytes)),l=e?c:swapEndianness(c);let u=0n;for(let h=0;h<l.length;h++)u|=BigInt(l[h])<<8n*BigInt(h);return n&&u&o&&(u=(u^o)-o),u},validate:a=>{if(typeof a!="bigint")throw new Error(`bigint: invalid value: ${a}`);return checkBounds(a,8n*s,!!n),a}})},U256BE=bigint(32,!1),U64LE=bigint(8,!0),I64LE=bigint(8,!0,!0),view=(t,e)=>wrap({size:t,encodeStream:(n,r)=>n.writeView(t,s=>e.write(s,r)),decodeStream:n=>n.readView(t,e.read),validate:n=>{if(typeof n!="number")throw new Error(`viewCoder: expected number, got ${typeof n}`);return e.validate&&e.validate(n),n}}),intView=(t,e,n)=>{const r=t*8,s=2**(r-1),o=l=>{if(!isNum(l))throw new Error(`sintView: value is not safe integer: ${l}`);if(l<-s||l>=s)throw new Error(`sintView: value out of bounds. Expected ${-s} <= ${l} < ${s}`)},a=2**r,c=l=>{if(!isNum(l))throw new Error(`uintView: value is not safe integer: ${l}`);if(0>l||l>=a)throw new Error(`uintView: value out of bounds. Expected 0 <= ${l} < ${a}`)};return view(t,{write:n.write,read:n.read,validate:e?o:c})},U32LE=intView(4,!1,{read:(t,e)=>t.getUint32(e,!0),write:(t,e)=>t.setUint32(0,e,!0)}),U32BE=intView(4,!1,{read:(t,e)=>t.getUint32(e,!1),write:(t,e)=>t.setUint32(0,e,!1)}),I32LE=intView(4,!0,{read:(t,e)=>t.getInt32(e,!0),write:(t,e)=>t.setInt32(0,e,!0)}),U16LE=intView(2,!1,{read:(t,e)=>t.getUint16(e,!0),write:(t,e)=>t.setUint16(0,e,!0)}),U8=intView(1,!1,{read:(t,e)=>t.getUint8(e),write:(t,e)=>t.setUint8(0,e)}),createBytes=(t,e=!1)=>{if(typeof e!="boolean")throw new Error(`bytes/le: expected boolean, got ${typeof e}`);const n=lengthCoder(t),r=isBytes$2(t);return wrap({size:typeof t=="number"?t:void 0,encodeStream:(s,o)=>{r||n.encodeStream(s,o.length),s.bytes(e?swapEndianness(o):o),r&&s.bytes(t)},decodeStream:s=>{let o;if(r){const a=s.find(t);if(!a)throw s.err("bytes: cannot find terminator");o=s.bytes(a-s.pos),s.bytes(t.length)}else o=s.bytes(t===null?s.leftBytes:n.decodeStream(s));return e?swapEndianness(o):o},validate:s=>{if(!isBytes$2(s))throw new Error(`bytes: invalid value ${s}`);return s}})};function prefix(t,e){if(!isCoder(e))throw new Error(`prefix: invalid inner value ${e}`);return apply(createBytes(t),reverse(e))}const string=(t,e=!1)=>validate$1(apply(createBytes(t,e),utf8$1),n=>{if(typeof n!="string")throw new Error(`expected string, got ${typeof n}`);return n}),createHex=(t,e={isLE:!1,with0x:!1})=>{let n=apply(createBytes(t,e.isLE),hex$1);const r=e.with0x;if(typeof r!="boolean")throw new Error(`hex/with0x: expected boolean, got ${typeof r}`);return r&&(n=apply(n,{encode:s=>`0x${s}`,decode:s=>{if(!s.startsWith("0x"))throw new Error("hex(with0x=true).encode input should start with 0x");return s.slice(2)}})),n};function apply(t,e){if(!isCoder(t))throw new Error(`apply: invalid inner value ${t}`);if(!isBaseCoder(e))throw new Error(`apply: invalid base value ${t}`);return wrap({size:t.size,encodeStream:(n,r)=>{let s;try{s=e.decode(r)}catch(o){throw n.err(""+o)}return t.encodeStream(n,s)},decodeStream:n=>{const r=t.decodeStream(n);try{return e.encode(r)}catch(s){throw n.err(""+s)}}})}const flag=(t,e=!1)=>{if(!isBytes$2(t))throw new Error(`flag/flagValue: expected Uint8Array, got ${typeof t}`);if(typeof e!="boolean")throw new Error(`flag/xor: expected boolean, got ${typeof e}`);return wrap({size:t.length,encodeStream:(n,r)=>{!!r!==e&&n.bytes(t)},decodeStream:n=>{let r=n.leftBytes>=t.length;return r&&(r=equalBytes$3(n.bytes(t.length,!0),t),r&&n.bytes(t.length)),r!==e},validate:n=>{if(n!==void 0&&typeof n!="boolean")throw new Error(`flag: expected boolean value or undefined, got ${typeof n}`);return n}})};function flagged(t,e,n){if(!isCoder(e))throw new Error(`flagged: invalid inner value ${e}`);if(typeof t!="string"&&!isCoder(e))throw new Error(`flagged: wrong path=${t}`);return wrap({encodeStream:(r,s)=>{typeof t=="string"?Path.resolve(r.stack,t)?e.encodeStream(r,s):n&&e.encodeStream(r,n):(t.encodeStream(r,!!s),s?e.encodeStream(r,s):n&&e.encodeStream(r,n))},decodeStream:r=>{let s=!1;if(typeof t=="string"?s=!!Path.resolve(r.stack,t):s=t.decodeStream(r),s)return e.decodeStream(r);n&&e.decodeStream(r)}})}function magic(t,e,n=!0){if(!isCoder(t))throw new Error(`magic: invalid inner value ${t}`);if(typeof n!="boolean")throw new Error(`magic: expected boolean, got ${typeof n}`);return wrap({size:t.size,encodeStream:(r,s)=>t.encodeStream(r,e),decodeStream:r=>{const s=t.decodeStream(r);if(n&&typeof s!="object"&&s!==e||isBytes$2(e)&&!equalBytes$3(e,s))throw r.err(`magic: invalid value: ${s} !== ${e}`)},validate:r=>{if(r!==void 0)throw new Error(`magic: wrong value=${typeof r}`);return r}})}function sizeof(t){let e=0;for(const n of t){if(n.size===void 0)return;if(!isNum(n.size))throw new Error(`sizeof: wrong element size=${e}`);e+=n.size}return e}function struct(t){if(!isPlainObject(t))throw new Error(`struct: expected plain object, got ${t}`);for(const e in t)if(!isCoder(t[e]))throw new Error(`struct: field ${e} is not CoderType`);return wrap({size:sizeof(Object.values(t)),encodeStream:(e,n)=>{e.pushObj(n,r=>{for(const s in t)r(s,()=>t[s].encodeStream(e,n[s]))})},decodeStream:e=>{const n={};return e.pushObj(n,r=>{for(const s in t)r(s,()=>n[s]=t[s].decodeStream(e))}),n},validate:e=>{if(typeof e!="object"||e===null)throw new Error(`struct: invalid value ${e}`);return e}})}function tuple(t){if(!Array.isArray(t))throw new Error(`Packed.Tuple: got ${typeof t} instead of array`);for(let e=0;e<t.length;e++)if(!isCoder(t[e]))throw new Error(`tuple: field ${e} is not CoderType`);return wrap({size:sizeof(t),encodeStream:(e,n)=>{if(!Array.isArray(n))throw e.err(`tuple: invalid value ${n}`);e.pushObj(n,r=>{for(let s=0;s<t.length;s++)r(`${s}`,()=>t[s].encodeStream(e,n[s]))})},decodeStream:e=>{const n=[];return e.pushObj(n,r=>{for(let s=0;s<t.length;s++)r(`${s}`,()=>n.push(t[s].decodeStream(e)))}),n},validate:e=>{if(!Array.isArray(e))throw new Error(`tuple: invalid value ${e}`);if(e.length!==t.length)throw new Error(`tuple: wrong length=${e.length}, expected ${t.length}`);return e}})}function array(t,e){if(!isCoder(e))throw new Error(`array: invalid inner value ${e}`);const n=lengthCoder(typeof t=="string"?`../${t}`:t);return wrap({size:typeof t=="number"&&e.size?t*e.size:void 0,encodeStream:(r,s)=>{const o=r;o.pushObj(s,a=>{isBytes$2(t)||n.encodeStream(r,s.length);for(let c=0;c<s.length;c++)a(`${c}`,()=>{const l=s[c],u=r.pos;if(e.encodeStream(r,l),isBytes$2(t)){if(t.length>o.pos-u)return;const h=o.finish(!1).subarray(u,o.pos);if(equalBytes$3(h.subarray(0,t.length),t))throw o.err(`array: inner element encoding same as separator. elm=${l} data=${h}`)}})}),isBytes$2(t)&&r.bytes(t)},decodeStream:r=>{const s=[];return r.pushObj(s,o=>{if(t===null)for(let a=0;!r.isEnd()&&(o(`${a}`,()=>s.push(e.decodeStream(r))),!(e.size&&r.leftBytes<e.size));a++);else if(isBytes$2(t))for(let a=0;;a++){if(equalBytes$3(r.bytes(t.length,!0),t)){r.bytes(t.length);break}o(`${a}`,()=>s.push(e.decodeStream(r)))}else{let a;o("arrayLen",()=>a=n.decodeStream(r));for(let c=0;c<a;c++)o(`${c}`,()=>s.push(e.decodeStream(r)))}}),s},validate:r=>{if(!Array.isArray(r))throw new Error(`array: invalid value ${r}`);return r}})}const Point$3=secp256k1$1.ProjectivePoint,CURVE_ORDER=secp256k1$1.CURVE.n,isBytes$1=utils$2.isBytes,concatBytes$3=utils$2.concatBytes,equalBytes$2=utils$2.equalBytes,hash160=t=>ripemd160(sha256$3(t)),sha256x2=(...t)=>sha256$3(sha256$3(concatBytes$3(...t))),randomPrivateKeyBytes=schnorr$1.utils.randomPrivateKey,pubSchnorr=schnorr$1.getPublicKey,pubECDSA=secp256k1$1.getPublicKey,hasLowR=t=>t.r<CURVE_ORDER/2n;function signECDSA(t,e,n=!1){let r=secp256k1$1.sign(t,e);if(n&&!hasLowR(r)){const s=new Uint8Array(32);let o=0;for(;!hasLowR(r);)if(s.set(U32LE.encode(o++)),r=secp256k1$1.sign(t,e,{extraEntropy:s}),o>4294967295)throw new Error("lowR counter overflow: report the error")}return r.toDERRawBytes()}const signSchnorr=schnorr$1.sign,tagSchnorr=schnorr$1.utils.taggedHash;var PubT;(function(t){t[t.ecdsa=0]="ecdsa",t[t.schnorr=1]="schnorr"})(PubT||(PubT={}));function validatePubkey(t,e){const n=t.length;if(e===PubT.ecdsa){if(n===32)throw new Error("Expected non-Schnorr key");return Point$3.fromHex(t),t}else if(e===PubT.schnorr){if(n!==32)throw new Error("Expected 32-byte Schnorr key");return schnorr$1.utils.lift_x(schnorr$1.utils.bytesToNumberBE(t)),t}else throw new Error("Unknown key type")}function tapTweak(t,e){const n=schnorr$1.utils,r=n.taggedHash("TapTweak",t,e),s=n.bytesToNumberBE(r);if(s>=CURVE_ORDER)throw new Error("tweak higher than curve order");return s}function taprootTweakPrivKey(t,e=Uint8Array.of()){const n=schnorr$1.utils,r=n.bytesToNumberBE(t),s=Point$3.fromPrivateKey(r),o=s.hasEvenY()?r:n.mod(-r,CURVE_ORDER),a=n.pointToBytes(s),c=tapTweak(a,e);return n.numberToBytesBE(n.mod(o+c,CURVE_ORDER),32)}function taprootTweakPubkey(t,e){const n=schnorr$1.utils,r=tapTweak(t,e),o=n.lift_x(n.bytesToNumberBE(t)).add(Point$3.fromPrivateKey(r)),a=o.hasEvenY()?0:1;return[n.pointToBytes(o),a]}const TAPROOT_UNSPENDABLE_KEY=sha256$3(Point$3.BASE.toRawBytes(!1)),NETWORK={bech32:"bc",pubKeyHash:0,scriptHash:5,wif:128},TEST_NETWORK={bech32:"tb",pubKeyHash:111,scriptHash:196,wif:239};function compareBytes(t,e){if(!isBytes$1(t)||!isBytes$1(e))throw new Error(`cmp: wrong type a=${typeof t} b=${typeof e}`);const n=Math.min(t.length,e.length);for(let r=0;r<n;r++)if(t[r]!=e[r])return Math.sign(t[r]-e[r]);return Math.sign(t.length-e.length)}const MAX_SCRIPT_BYTE_LENGTH=520;var OP;(function(t){t[t.OP_0=0]="OP_0",t[t.PUSHDATA1=76]="PUSHDATA1",t[t.PUSHDATA2=77]="PUSHDATA2",t[t.PUSHDATA4=78]="PUSHDATA4",t[t["1NEGATE"]=79]="1NEGATE",t[t.RESERVED=80]="RESERVED",t[t.OP_1=81]="OP_1",t[t.OP_2=82]="OP_2",t[t.OP_3=83]="OP_3",t[t.OP_4=84]="OP_4",t[t.OP_5=85]="OP_5",t[t.OP_6=86]="OP_6",t[t.OP_7=87]="OP_7",t[t.OP_8=88]="OP_8",t[t.OP_9=89]="OP_9",t[t.OP_10=90]="OP_10",t[t.OP_11=91]="OP_11",t[t.OP_12=92]="OP_12",t[t.OP_13=93]="OP_13",t[t.OP_14=94]="OP_14",t[t.OP_15=95]="OP_15",t[t.OP_16=96]="OP_16",t[t.NOP=97]="NOP",t[t.VER=98]="VER",t[t.IF=99]="IF",t[t.NOTIF=100]="NOTIF",t[t.VERIF=101]="VERIF",t[t.VERNOTIF=102]="VERNOTIF",t[t.ELSE=103]="ELSE",t[t.ENDIF=104]="ENDIF",t[t.VERIFY=105]="VERIFY",t[t.RETURN=106]="RETURN",t[t.TOALTSTACK=107]="TOALTSTACK",t[t.FROMALTSTACK=108]="FROMALTSTACK",t[t["2DROP"]=109]="2DROP",t[t["2DUP"]=110]="2DUP",t[t["3DUP"]=111]="3DUP",t[t["2OVER"]=112]="2OVER",t[t["2ROT"]=113]="2ROT",t[t["2SWAP"]=114]="2SWAP",t[t.IFDUP=115]="IFDUP",t[t.DEPTH=116]="DEPTH",t[t.DROP=117]="DROP",t[t.DUP=118]="DUP",t[t.NIP=119]="NIP",t[t.OVER=120]="OVER",t[t.PICK=121]="PICK",t[t.ROLL=122]="ROLL",t[t.ROT=123]="ROT",t[t.SWAP=124]="SWAP",t[t.TUCK=125]="TUCK",t[t.CAT=126]="CAT",t[t.SUBSTR=127]="SUBSTR",t[t.LEFT=128]="LEFT",t[t.RIGHT=129]="RIGHT",t[t.SIZE=130]="SIZE",t[t.INVERT=131]="INVERT",t[t.AND=132]="AND",t[t.OR=133]="OR",t[t.XOR=134]="XOR",t[t.EQUAL=135]="EQUAL",t[t.EQUALVERIFY=136]="EQUALVERIFY",t[t.RESERVED1=137]="RESERVED1",t[t.RESERVED2=138]="RESERVED2",t[t["1ADD"]=139]="1ADD",t[t["1SUB"]=140]="1SUB",t[t["2MUL"]=141]="2MUL",t[t["2DIV"]=142]="2DIV",t[t.NEGATE=143]="NEGATE",t[t.ABS=144]="ABS",t[t.NOT=145]="NOT",t[t["0NOTEQUAL"]=146]="0NOTEQUAL",t[t.ADD=147]="ADD",t[t.SUB=148]="SUB",t[t.MUL=149]="MUL",t[t.DIV=150]="DIV",t[t.MOD=151]="MOD",t[t.LSHIFT=152]="LSHIFT",t[t.RSHIFT=153]="RSHIFT",t[t.BOOLAND=154]="BOOLAND",t[t.BOOLOR=155]="BOOLOR",t[t.NUMEQUAL=156]="NUMEQUAL",t[t.NUMEQUALVERIFY=157]="NUMEQUALVERIFY",t[t.NUMNOTEQUAL=158]="NUMNOTEQUAL",t[t.LESSTHAN=159]="LESSTHAN",t[t.GREATERTHAN=160]="GREATERTHAN",t[t.LESSTHANOREQUAL=161]="LESSTHANOREQUAL",t[t.GREATERTHANOREQUAL=162]="GREATERTHANOREQUAL",t[t.MIN=163]="MIN",t[t.MAX=164]="MAX",t[t.WITHIN=165]="WITHIN",t[t.RIPEMD160=166]="RIPEMD160",t[t.SHA1=167]="SHA1",t[t.SHA256=168]="SHA256",t[t.HASH160=169]="HASH160",t[t.HASH256=170]="HASH256",t[t.CODESEPARATOR=171]="CODESEPARATOR",t[t.CHECKSIG=172]="CHECKSIG",t[t.CHECKSIGVERIFY=173]="CHECKSIGVERIFY",t[t.CHECKMULTISIG=174]="CHECKMULTISIG",t[t.CHECKMULTISIGVERIFY=175]="CHECKMULTISIGVERIFY",t[t.NOP1=176]="NOP1",t[t.CHECKLOCKTIMEVERIFY=177]="CHECKLOCKTIMEVERIFY",t[t.CHECKSEQUENCEVERIFY=178]="CHECKSEQUENCEVERIFY",t[t.NOP4=179]="NOP4",t[t.NOP5=180]="NOP5",t[t.NOP6=181]="NOP6",t[t.NOP7=182]="NOP7",t[t.NOP8=183]="NOP8",t[t.NOP9=184]="NOP9",t[t.NOP10=185]="NOP10",t[t.CHECKSIGADD=186]="CHECKSIGADD",t[t.INVALID=255]="INVALID"})(OP||(OP={}));function ScriptNum(t=6,e=!1){return wrap({encodeStream:(n,r)=>{if(r===0n)return;const s=r<0,o=BigInt(r),a=[];for(let c=s?-o:o;c;c>>=8n)a.push(Number(c&0xffn));a[a.length-1]>=128?a.push(s?128:0):s&&(a[a.length-1]|=128),n.bytes(new Uint8Array(a))},decodeStream:n=>{const r=n.leftBytes;if(r>t)throw new Error(`ScriptNum: number (${r}) bigger than limit=${t}`);if(r===0)return 0n;if(e){const a=n.bytes(r,!0);if(!(a[a.length-1]&127)&&(r<=1||!(a[a.length-2]&128)))throw new Error("Non-minimally encoded ScriptNum")}let s=0,o=0n;for(let a=0;a<r;++a)s=n.byte(),o|=BigInt(s)<<8n*BigInt(a);return s>=128&&(o&=2n**BigInt(r*8)-1n>>1n,o=-o),o}})}function OpToNum(t,e=4,n=!0){if(typeof t=="number")return t;if(isBytes$1(t))try{const r=ScriptNum(e,n).decode(t);return r>Number.MAX_SAFE_INTEGER?void 0:Number(r)}catch{return}}const Script=wrap({encodeStream:(t,e)=>{for(let n of e){if(typeof n=="string"){if(OP[n]===void 0)throw new Error(`Unknown opcode=${n}`);t.byte(OP[n]);continue}else if(typeof n=="number"){if(n===0){t.byte(0);continue}else if(1<=n&&n<=16){t.byte(OP.OP_1-1+n);continue}}if(typeof n=="number"&&(n=ScriptNum().encode(BigInt(n))),!isBytes$1(n))throw new Error(`Wrong Script OP=${n} (${typeof n})`);const r=n.length;r<OP.PUSHDATA1?t.byte(r):r<=255?(t.byte(OP.PUSHDATA1),t.byte(r)):r<=65535?(t.byte(OP.PUSHDATA2),t.bytes(U16LE.encode(r))):(t.byte(OP.PUSHDATA4),t.bytes(U32LE.encode(r))),t.bytes(n)}},decodeStream:t=>{const e=[];for(;!t.isEnd();){const n=t.byte();if(OP.OP_0<n&&n<=OP.PUSHDATA4){let r;if(n<OP.PUSHDATA1)r=n;else if(n===OP.PUSHDATA1)r=U8.decodeStream(t);else if(n===OP.PUSHDATA2)r=U16LE.decodeStream(t);else if(n===OP.PUSHDATA4)r=U32LE.decodeStream(t);else throw new Error("Should be not possible");e.push(t.bytes(r))}else if(n===0)e.push(0);else if(OP.OP_1<=n&&n<=OP.OP_16)e.push(n-(OP.OP_1-1));else{const r=OP[n];if(r===void 0)throw new Error(`Unknown opcode=${n.toString(16)}`);e.push(r)}}return e}}),CSLimits={253:[253,2,253n,65535n],254:[254,4,65536n,4294967295n],255:[255,8,4294967296n,18446744073709551615n]},CompactSize=wrap({encodeStream:(t,e)=>{if(typeof e=="number"&&(e=BigInt(e)),0n<=e&&e<=252n)return t.byte(Number(e));for(const[n,r,s,o]of Object.values(CSLimits))if(!(s>e||e>o)){t.byte(n);for(let a=0;a<r;a++)t.byte(Number(e>>8n*BigInt(a)&0xffn));return}throw t.err(`VarInt too big: ${e}`)},decodeStream:t=>{const e=t.byte();if(e<=252)return BigInt(e);const[n,r,s]=CSLimits[e];let o=0n;for(let a=0;a<r;a++)o|=BigInt(t.byte())<<8n*BigInt(a);if(o<s)throw t.err(`Wrong CompactSize(${8*r})`);return o}}),CompactSizeLen=apply(CompactSize,coders.numberBigint),VarBytes=createBytes(CompactSize),RawWitness=array(CompactSizeLen,VarBytes),BTCArray=t=>array(CompactSize,t),RawInput=struct({txid:createBytes(32,!0),index:U32LE,finalScriptSig:VarBytes,sequence:U32LE}),RawOutput=struct({amount:U64LE,script:VarBytes}),_RawTx=struct({version:I32LE,segwitFlag:flag(new Uint8Array([0,1])),inputs:BTCArray(RawInput),outputs:BTCArray(RawOutput),witnesses:flagged("segwitFlag",array("inputs/length",RawWitness)),lockTime:U32LE});function validateRawTx(t){if(t.segwitFlag&&t.witnesses&&!t.witnesses.length)throw new Error("Segwit flag with empty witnesses array");return t}const RawTx=validate$1(_RawTx,validateRawTx),RawOldTx=struct({version:I32LE,inputs:BTCArray(RawInput),outputs:BTCArray(RawOutput),lockTime:U32LE}),PubKeyECDSA=validate$1(createBytes(null),t=>validatePubkey(t,PubT.ecdsa)),PubKeySchnorr=validate$1(createBytes(32),t=>validatePubkey(t,PubT.schnorr)),SignatureSchnorr=validate$1(createBytes(null),t=>{if(t.length!==64&&t.length!==65)throw new Error("Schnorr signature should be 64 or 65 bytes long");return t}),BIP32Der=struct({fingerprint:U32BE,path:array(null,U32LE)}),TaprootBIP32Der=struct({hashes:array(CompactSizeLen,createBytes(32)),der:BIP32Der}),GlobalXPUB=createBytes(78),tapScriptSigKey=struct({pubKey:PubKeySchnorr,leafHash:createBytes(32)}),_TaprootControlBlock=struct({version:U8,internalKey:createBytes(32),merklePath:array(null,createBytes(32))}),TaprootControlBlock=validate$1(_TaprootControlBlock,t=>{if(t.merklePath.length>128)throw new Error("TaprootControlBlock: merklePath should be of length 0..128 (inclusive)");return t}),tapTree=array(null,struct({depth:U8,version:U8,script:VarBytes})),BytesInf=createBytes(null),Bytes20=createBytes(20),Bytes32=createBytes(32),PSBTGlobal={unsignedTx:[0,!1,RawOldTx,[0],[0],!1],xpub:[1,GlobalXPUB,BIP32Der,[],[0,2],!1],txVersion:[2,!1,U32LE,[2],[2],!1],fallbackLocktime:[3,!1,U32LE,[],[2],!1],inputCount:[4,!1,CompactSizeLen,[2],[2],!1],outputCount:[5,!1,CompactSizeLen,[2],[2],!1],txModifiable:[6,!1,U8,[],[2],!1],version:[251,!1,U32LE,[],[0,2],!1],proprietary:[252,BytesInf,BytesInf,[],[0,2],!1]},PSBTInput={nonWitnessUtxo:[0,!1,RawTx,[],[0,2],!1],witnessUtxo:[1,!1,RawOutput,[],[0,2],!1],partialSig:[2,PubKeyECDSA,BytesInf,[],[0,2],!1],sighashType:[3,!1,U32LE,[],[0,2],!1],redeemScript:[4,!1,BytesInf,[],[0,2],!1],witnessScript:[5,!1,BytesInf,[],[0,2],!1],bip32Derivation:[6,PubKeyECDSA,BIP32Der,[],[0,2],!1],finalScriptSig:[7,!1,BytesInf,[],[0,2],!1],finalScriptWitness:[8,!1,RawWitness,[],[0,2],!1],porCommitment:[9,!1,BytesInf,[],[0,2],!1],ripemd160:[10,Bytes20,BytesInf,[],[0,2],!1],sha256:[11,Bytes32,BytesInf,[],[0,2],!1],hash160:[12,Bytes20,BytesInf,[],[0,2],!1],hash256:[13,Bytes32,BytesInf,[],[0,2],!1],txid:[14,!1,Bytes32,[2],[2],!0],index:[15,!1,U32LE,[2],[2],!0],sequence:[16,!1,U32LE,[],[2],!0],requiredTimeLocktime:[17,!1,U32LE,[],[2],!1],requiredHeightLocktime:[18,!1,U32LE,[],[2],!1],tapKeySig:[19,!1,SignatureSchnorr,[],[0,2],!1],tapScriptSig:[20,tapScriptSigKey,SignatureSchnorr,[],[0,2],!1],tapLeafScript:[21,TaprootControlBlock,BytesInf,[],[0,2],!1],tapBip32Derivation:[22,Bytes32,TaprootBIP32Der,[],[0,2],!1],tapInternalKey:[23,!1,PubKeySchnorr,[],[0,2],!1],tapMerkleRoot:[24,!1,Bytes32,[],[0,2],!1],proprietary:[252,BytesInf,BytesInf,[],[0,2],!1]},PSBTInputFinalKeys=["txid","sequence","index","witnessUtxo","nonWitnessUtxo","finalScriptSig","finalScriptWitness","unknown"],PSBTInputUnsignedKeys=["partialSig","finalScriptSig","finalScriptWitness","tapKeySig","tapScriptSig"],PSBTOutput={redeemScript:[0,!1,BytesInf,[],[0,2],!1],witnessScript:[1,!1,BytesInf,[],[0,2],!1],bip32Derivation:[2,PubKeyECDSA,BIP32Der,[],[0,2],!1],amount:[3,!1,I64LE,[2],[2],!0],script:[4,!1,BytesInf,[2],[2],!0],tapInternalKey:[5,!1,PubKeySchnorr,[],[0,2],!1],tapTree:[6,!1,tapTree,[],[0,2],!1],tapBip32Derivation:[7,PubKeySchnorr,TaprootBIP32Der,[],[0,2],!1],proprietary:[252,BytesInf,BytesInf,[],[0,2],!1]},PSBTOutputUnsignedKeys=[],PSBTKeyPair=array(NULL,struct({key:prefix(CompactSizeLen,struct({type:CompactSizeLen,key:createBytes(null)})),value:createBytes(CompactSizeLen)}));function PSBTKeyInfo(t){const[e,n,r,s,o,a]=t;return{type:e,kc:n,vc:r,reqInc:s,allowInc:o,silentIgnore:a}}struct({type:CompactSizeLen,key:createBytes(null)});function PSBTKeyMap(t){const e={};for(const n in t){const[r,s,o]=t[n];e[r]=[n,s,o]}return wrap({encodeStream:(n,r)=>{let s=[];for(const o in t){const a=r[o];if(a===void 0)continue;const[c,l,u]=t[o];if(!l)s.push({key:{type:c,key:EMPTY},value:u.encode(a)});else{const h=a.map(([f,p])=>[l.encode(f),u.encode(p)]);h.sort((f,p)=>compareBytes(f[0],p[0]));for(const[f,p]of h)s.push({key:{key:f,type:c},value:p})}}if(r.unknown){r.unknown.sort((o,a)=>compareBytes(o[0].key,a[0].key));for(const[o,a]of r.unknown)s.push({key:o,value:a})}PSBTKeyPair.encodeStream(n,s)},decodeStream:n=>{const r=PSBTKeyPair.decodeStream(n),s={},o={};for(const a of r){let c="unknown",l=a.key.key,u=a.value;if(e[a.key.type]){const[h,f,p]=e[a.key.type];if(c=h,!f&&l.length)throw new Error(`PSBT: Non-empty key for ${c} (key=${hex$1.encode(l)} value=${hex$1.encode(u)}`);if(l=f?f.decode(l):void 0,u=p.decode(u),!f){if(s[c])throw new Error(`PSBT: Same keys: ${c} (key=${l} value=${u})`);s[c]=u,o[c]=!0;continue}}else l={type:a.key.type,key:a.key.key};if(o[c])throw new Error(`PSBT: Key type with empty key and no key=${c} val=${u}`);s[c]||(s[c]=[]),s[c].push([l,u])}return s}})}const PSBTInputCoder=validate$1(PSBTKeyMap(PSBTInput),t=>{if(t.finalScriptWitness&&!t.finalScriptWitness.length)throw new Error("validateInput: empty finalScriptWitness");if(t.partialSig&&!t.partialSig.length)throw new Error("Empty partialSig");if(t.partialSig)for(const[e]of t.partialSig)validatePubkey(e,PubT.ecdsa);if(t.bip32Derivation)for(const[e]of t.bip32Derivation)validatePubkey(e,PubT.ecdsa);if(t.requiredTimeLocktime!==void 0&&t.requiredTimeLocktime<5e8)throw new Error(`validateInput: wrong timeLocktime=${t.requiredTimeLocktime}`);if(t.requiredHeightLocktime!==void 0&&(t.requiredHeightLocktime<=0||t.requiredHeightLocktime>=5e8))throw new Error(`validateInput: wrong heighLocktime=${t.requiredHeightLocktime}`);if(t.tapLeafScript)for(const[e,n]of t.tapLeafScript){if((e.version&254)!==n[n.length-1])throw new Error("validateInput: tapLeafScript version mimatch");if(n[n.length-1]&1)throw new Error("validateInput: tapLeafScript version has parity bit!")}return t}),PSBTOutputCoder=validate$1(PSBTKeyMap(PSBTOutput),t=>{if(t.bip32Derivation)for(const[e]of t.bip32Derivation)validatePubkey(e,PubT.ecdsa);return t}),PSBTGlobalCoder=validate$1(PSBTKeyMap(PSBTGlobal),t=>{if((t.version||0)===0){if(!t.unsignedTx)throw new Error("PSBTv0: missing unsignedTx");for(const n of t.unsignedTx.inputs)if(n.finalScriptSig&&n.finalScriptSig.length)throw new Error("PSBTv0: input scriptSig found in unsignedTx")}return t}),_RawPSBTV0=struct({magic:magic(string(new Uint8Array([255])),"psbt"),global:PSBTGlobalCoder,inputs:array("global/unsignedTx/inputs/length",PSBTInputCoder),outputs:array(null,PSBTOutputCoder)}),_RawPSBTV2=struct({magic:magic(string(new Uint8Array([255])),"psbt"),global:PSBTGlobalCoder,inputs:array("global/inputCount",PSBTInputCoder),outputs:array("global/outputCount",PSBTOutputCoder)}),_DebugPSBT=struct({magic:magic(string(new Uint8Array([255])),"psbt"),items:array(null,apply(array(NULL,tuple([createHex(CompactSizeLen),createBytes(CompactSize)])),coders.dict()))});function validatePSBTFields(t,e,n){for(const r in n){if(r==="unknown"||!e[r])continue;const{allowInc:s}=PSBTKeyInfo(e[r]);if(!s.includes(t))throw new Error(`PSBTv${t}: field ${r} is not allowed`)}for(const r in e){const{reqInc:s}=PSBTKeyInfo(e[r]);if(s.includes(t)&&n[r]===void 0)throw new Error(`PSBTv${t}: missing required field ${r}`)}}function cleanPSBTFields(t,e,n){const r={};for(const s in n){const o=s;if(o!=="unknown"){if(!e[o])continue;const{allowInc:a,silentIgnore:c}=PSBTKeyInfo(e[o]);if(!a.includes(t)){if(c)continue;throw new Error(`Failed to serialize in PSBTv${t}: ${o} but versions allows inclusion=${a}`)}}r[o]=n[o]}return r}function validatePSBT(t){const e=t&&t.global&&t.global.version||0;validatePSBTFields(e,PSBTGlobal,t.global);for(const a of t.inputs)validatePSBTFields(e,PSBTInput,a);for(const a of t.outputs)validatePSBTFields(e,PSBTOutput,a);const n=e?t.global.inputCount:t.global.unsignedTx.inputs.length;if(t.inputs.length<n)throw new Error("Not enough inputs");const r=t.inputs.slice(n);if(r.length>1||r.length&&Object.keys(r[0]).length)throw new Error(`Unexpected inputs left in tx=${r}`);const s=e?t.global.outputCount:t.global.unsignedTx.outputs.length;if(t.outputs.length<s)throw new Error("Not outputs inputs");const o=t.outputs.slice(s);if(o.length>1||o.length&&Object.keys(o[0]).length)throw new Error(`Unexpected outputs left in tx=${o}`);return t}function mergeKeyMap(t,e,n,r,s){const o={...n,...e};for(const a in t){const c=a,[l,u,h]=t[c],f=r&&!r.includes(a);if(e[a]===void 0&&a in e){if(f)throw new Error(`Cannot remove signed field=${a}`);delete o[a]}else if(u){const p=n&&n[a]?n[a]:[];let g=e[c];if(g){if(!Array.isArray(g))throw new Error(`keyMap(${a}): KV pairs should be [k, v][]`);g=g.map(b=>{if(b.length!==2)throw new Error(`keyMap(${a}): KV pairs should be [k, v][]`);return[typeof b[0]=="string"?u.decode(hex$1.decode(b[0])):b[0],typeof b[1]=="string"?h.decode(hex$1.decode(b[1])):b[1]]});const w={},y=(b,x,_)=>{if(w[b]===void 0){w[b]=[x,_];return}const R=hex$1.encode(h.encode(w[b][1])),$=hex$1.encode(h.encode(_));if(R!==$)throw new Error(`keyMap(${c}): same key=${b} oldVal=${R} newVal=${$}`)};for(const[b,x]of p){const _=hex$1.encode(u.encode(b));y(_,b,x)}for(const[b,x]of g){const _=hex$1.encode(u.encode(b));if(x===void 0){if(f)throw new Error(`Cannot remove signed field=${c}/${b}`);delete w[_]}else y(_,b,x)}o[c]=Object.values(w)}}else if(typeof o[a]=="string")o[a]=h.decode(hex$1.decode(o[a]));else if(f&&a in e&&n&&n[a]!==void 0&&!equalBytes$2(h.encode(e[a]),h.encode(n[a])))throw new Error(`Cannot change signed field=${a}`)}for(const a in o)if(!t[a]){if(s&&a==="unknown")continue;delete o[a]}return o}const RawPSBTV0=validate$1(_RawPSBTV0,validatePSBT),RawPSBTV2=validate$1(_RawPSBTV2,validatePSBT),OutP2A={encode(t){if(!(t.length!==2||t[0]!==1||!isBytes$1(t[1])||hex$1.encode(t[1])!=="4e73"))return{type:"p2a",script:Script.encode(t)}},decode:t=>{if(t.type==="p2a")return[1,hex$1.decode("4e73")]}};function isValidPubkey(t,e){try{return validatePubkey(t,e),!0}catch{return!1}}const OutPK={encode(t){if(!(t.length!==2||!isBytes$1(t[0])||!isValidPubkey(t[0],PubT.ecdsa)||t[1]!=="CHECKSIG"))return{type:"pk",pubkey:t[0]}},decode:t=>t.type==="pk"?[t.pubkey,"CHECKSIG"]:void 0},OutPKH={encode(t){if(!(t.length!==5||t[0]!=="DUP"||t[1]!=="HASH160"||!isBytes$1(t[2]))&&!(t[3]!=="EQUALVERIFY"||t[4]!=="CHECKSIG"))return{type:"pkh",hash:t[2]}},decode:t=>t.type==="pkh"?["DUP","HASH160",t.hash,"EQUALVERIFY","CHECKSIG"]:void 0},OutSH={encode(t){if(!(t.length!==3||t[0]!=="HASH160"||!isBytes$1(t[1])||t[2]!=="EQUAL"))return{type:"sh",hash:t[1]}},decode:t=>t.type==="sh"?["HASH160",t.hash,"EQUAL"]:void 0},OutWSH={encode(t){if(!(t.length!==2||t[0]!==0||!isBytes$1(t[1]))&&t[1].length===32)return{type:"wsh",hash:t[1]}},decode:t=>t.type==="wsh"?[0,t.hash]:void 0},OutWPKH={encode(t){if(!(t.length!==2||t[0]!==0||!isBytes$1(t[1]))&&t[1].length===20)return{type:"wpkh",hash:t[1]}},decode:t=>t.type==="wpkh"?[0,t.hash]:void 0},OutMS={encode(t){const e=t.length-1;if(t[e]!=="CHECKMULTISIG")return;const n=t[0],r=t[e-1];if(typeof n!="number"||typeof r!="number")return;const s=t.slice(1,-2);if(r===s.length){for(const o of s)if(!isBytes$1(o))return;return{type:"ms",m:n,pubkeys:s}}},decode:t=>t.type==="ms"?[t.m,...t.pubkeys,t.pubkeys.length,"CHECKMULTISIG"]:void 0},OutTR={encode(t){if(!(t.length!==2||t[0]!==1||!isBytes$1(t[1])))return{type:"tr",pubkey:t[1]}},decode:t=>t.type==="tr"?[1,t.pubkey]:void 0},OutTRNS={encode(t){const e=t.length-1;if(t[e]!=="CHECKSIG")return;const n=[];for(let r=0;r<e;r++){const s=t[r];if(r&1){if(s!=="CHECKSIGVERIFY"||r===e-1)return;continue}if(!isBytes$1(s))return;n.push(s)}return{type:"tr_ns",pubkeys:n}},decode:t=>{if(t.type!=="tr_ns")return;const e=[];for(let n=0;n<t.pubkeys.length-1;n++)e.push(t.pubkeys[n],"CHECKSIGVERIFY");return e.push(t.pubkeys[t.pubkeys.length-1],"CHECKSIG"),e}},OutTRMS={encode(t){const e=t.length-1;if(t[e]!=="NUMEQUAL"||t[1]!=="CHECKSIG")return;const n=[],r=OpToNum(t[e-1]);if(typeof r=="number"){for(let s=0;s<e-1;s++){const o=t[s];if(s&1){if(o!==(s===1?"CHECKSIG":"CHECKSIGADD"))throw new Error("OutScript.encode/tr_ms: wrong element");continue}if(!isBytes$1(o))throw new Error("OutScript.encode/tr_ms: wrong key element");n.push(o)}return{type:"tr_ms",pubkeys:n,m:r}}},decode:t=>{if(t.type!=="tr_ms")return;const e=[t.pubkeys[0],"CHECKSIG"];for(let n=1;n<t.pubkeys.length;n++)e.push(t.pubkeys[n],"CHECKSIGADD");return e.push(t.m,"NUMEQUAL"),e}},OutUnknown={encode(t){return{type:"unknown",script:Script.encode(t)}},decode:t=>t.type==="unknown"?Script.decode(t.script):void 0},OutScripts=[OutP2A,OutPK,OutPKH,OutSH,OutWSH,OutWPKH,OutMS,OutTR,OutTRNS,OutTRMS,OutUnknown],_OutScript=apply(Script,coders.match(OutScripts)),OutScript=validate$1(_OutScript,t=>{if(t.type==="pk"&&!isValidPubkey(t.pubkey,PubT.ecdsa))throw new Error("OutScript/pk: wrong key");if((t.type==="pkh"||t.type==="sh"||t.type==="wpkh")&&(!isBytes$1(t.hash)||t.hash.length!==20))throw new Error(`OutScript/${t.type}: wrong hash`);if(t.type==="wsh"&&(!isBytes$1(t.hash)||t.hash.length!==32))throw new Error("OutScript/wsh: wrong hash");if(t.type==="tr"&&(!isBytes$1(t.pubkey)||!isValidPubkey(t.pubkey,PubT.schnorr)))throw new Error("OutScript/tr: wrong taproot public key");if((t.type==="ms"||t.type==="tr_ns"||t.type==="tr_ms")&&!Array.isArray(t.pubkeys))throw new Error("OutScript/multisig: wrong pubkeys array");if(t.type==="ms"){const e=t.pubkeys.length;for(const n of t.pubkeys)if(!isValidPubkey(n,PubT.ecdsa))throw new Error("OutScript/multisig: wrong pubkey");if(t.m<=0||e>16||t.m>e)throw new Error("OutScript/multisig: invalid params")}if(t.type==="tr_ns"||t.type==="tr_ms"){for(const e of t.pubkeys)if(!isValidPubkey(e,PubT.schnorr))throw new Error(`OutScript/${t.type}: wrong pubkey`)}if(t.type==="tr_ms"){const e=t.pubkeys.length;if(t.m<=0||e>999||t.m>e)throw new Error("OutScript/tr_ms: invalid params")}return t});function checkWSH(t,e){if(!equalBytes$2(t.hash,sha256$3(e)))throw new Error("checkScript: wsh wrong witnessScript hash");const n=OutScript.decode(e);if(n.type==="tr"||n.type==="tr_ns"||n.type==="tr_ms")throw new Error(`checkScript: P2${n.type} cannot be wrapped in P2SH`);if(n.type==="wpkh"||n.type==="sh")throw new Error(`checkScript: P2${n.type} cannot be wrapped in P2WSH`)}function checkScript(t,e,n){if(t){const r=OutScript.decode(t);if(r.type==="tr_ns"||r.type==="tr_ms"||r.type==="ms"||r.type=="pk")throw new Error(`checkScript: non-wrapped ${r.type}`);if(r.type==="sh"&&e){if(!equalBytes$2(r.hash,hash160(e)))throw new Error("checkScript: sh wrong redeemScript hash");const s=OutScript.decode(e);if(s.type==="tr"||s.type==="tr_ns"||s.type==="tr_ms")throw new Error(`checkScript: P2${s.type} cannot be wrapped in P2SH`);if(s.type==="sh")throw new Error("checkScript: P2SH cannot be wrapped in P2SH")}r.type==="wsh"&&n&&checkWSH(r,n)}if(e){const r=OutScript.decode(e);r.type==="wsh"&&n&&checkWSH(r,n)}}function uniqPubkey(t){const e={};for(const n of t){const r=hex$1.encode(n);if(e[r])throw new Error(`Multisig: non-uniq pubkey: ${t.map(hex$1.encode)}`);e[r]=!0}}const p2pk=(t,e=NETWORK)=>{if(!isValidPubkey(t,PubT.ecdsa))throw new Error("P2PK: invalid publicKey");return{type:"pk",script:OutScript.encode({type:"pk",pubkey:t})}},p2pkh=(t,e=NETWORK)=>{if(!isValidPubkey(t,PubT.ecdsa))throw new Error("P2PKH: invalid publicKey");const n=hash160(t);return{type:"pkh",script:OutScript.encode({type:"pkh",hash:n}),address:Address(e).encode({type:"pkh",hash:n}),hash:n}},p2sh=(t,e=NETWORK)=>{const n=t.script;if(!isBytes$1(n))throw new Error(`Wrong script: ${typeof t.script}, expected Uint8Array`);const r=hash160(n),s=OutScript.encode({type:"sh",hash:r});return checkScript(s,n,t.witnessScript),t.witnessScript?{type:"sh",redeemScript:n,script:OutScript.encode({type:"sh",hash:r}),address:Address(e).encode({type:"sh",hash:r}),hash:r,witnessScript:t.witnessScript}:{type:"sh",redeemScript:n,script:OutScript.encode({type:"sh",hash:r}),address:Address(e).encode({type:"sh",hash:r}),hash:r}},p2wsh=(t,e=NETWORK)=>{const n=t.script;if(!isBytes$1(n))throw new Error(`Wrong script: ${typeof n}, expected Uint8Array`);const r=sha256$3(n),s=OutScript.encode({type:"wsh",hash:r});return checkScript(s,void 0,n),{type:"wsh",witnessScript:n,script:OutScript.encode({type:"wsh",hash:r}),address:Address(e).encode({type:"wsh",hash:r}),hash:r}},p2wpkh=(t,e=NETWORK)=>{if(!isValidPubkey(t,PubT.ecdsa))throw new Error("P2WPKH: invalid publicKey");if(t.length===65)throw new Error("P2WPKH: uncompressed public key");const n=hash160(t);return{type:"wpkh",script:OutScript.encode({type:"wpkh",hash:n}),address:Address(e).encode({type:"wpkh",hash:n}),hash:n}},p2ms=(t,e,n=!1)=>(n||uniqPubkey(e),{type:"ms",script:OutScript.encode({type:"ms",pubkeys:e,m:t})});function checkTaprootScript(t,e,n=!1,r){const s=OutScript.decode(t);if(s.type==="unknown"){if(r){const c=apply(Script,coders.match(r)).decode(t);if(c!==void 0){if(typeof c.type!="string"||!c.type.startsWith("tr_"))throw new Error(`P2TR: invalid custom type=${c.type}`);return}}if(n)return}if(!["tr_ns","tr_ms"].includes(s.type))throw new Error(`P2TR: invalid leaf script=${s.type}`);const o=s;if(!n&&o.pubkeys)for(const a of o.pubkeys){if(equalBytes$2(a,TAPROOT_UNSPENDABLE_KEY))throw new Error("Unspendable taproot key in leaf script");if(equalBytes$2(a,e))throw new Error("Using P2TR with leaf script with same key as internal key is not supported")}}function taprootListToTree(t){const e=Array.from(t);for(;e.length>=2;){e.sort((a,c)=>(c.weight||1)-(a.weight||1));const r=e.pop(),s=e.pop(),o=((s==null?void 0:s.weight)||1)+((r==null?void 0:r.weight)||1);e.push({weight:o,childs:[(s==null?void 0:s.childs)||s,(r==null?void 0:r.childs)||r]})}const n=e[0];return(n==null?void 0:n.childs)||n}function taprootAddPath(t,e=[]){if(!t)throw new Error("taprootAddPath: empty tree");if(t.type==="leaf")return{...t,path:e};if(t.type!=="branch")throw new Error(`taprootAddPath: wrong type=${t}`);return{...t,path:e,left:taprootAddPath(t.left,[t.right.hash,...e]),right:taprootAddPath(t.right,[t.left.hash,...e])}}function taprootWalkTree(t){if(!t)throw new Error("taprootAddPath: empty tree");if(t.type==="leaf")return[t];if(t.type!=="branch")throw new Error(`taprootWalkTree: wrong type=${t}`);return[...taprootWalkTree(t.left),...taprootWalkTree(t.right)]}function taprootHashTree(t,e,n=!1,r){if(!t)throw new Error("taprootHashTree: empty tree");if(Array.isArray(t)&&t.length===1&&(t=t[0]),!Array.isArray(t)){const{leafVersion:l,script:u}=t;if(t.tapLeafScript||t.tapMerkleRoot&&!equalBytes$2(t.tapMerkleRoot,EMPTY))throw new Error("P2TR: tapRoot leafScript cannot have tree");const h=typeof u=="string"?hex$1.decode(u):u;if(!isBytes$1(h))throw new Error(`checkScript: wrong script type=${h}`);return checkTaprootScript(h,e,n,r),{type:"leaf",version:l,script:h,hash:tapLeafHash(h,l)}}if(t.length!==2&&(t=taprootListToTree(t)),t.length!==2)throw new Error("hashTree: non binary tree!");const s=taprootHashTree(t[0],e,n,r),o=taprootHashTree(t[1],e,n,r);let[a,c]=[s.hash,o.hash];return compareBytes(c,a)===-1&&([a,c]=[c,a]),{type:"branch",left:s,right:o,hash:tagSchnorr("TapBranch",a,c)}}const TAP_LEAF_VERSION=192,tapLeafHash=(t,e=TAP_LEAF_VERSION)=>tagSchnorr("TapLeaf",new Uint8Array([e]),VarBytes.encode(t));function p2tr(t,e,n=NETWORK,r=!1,s){if(!t&&!e)throw new Error("p2tr: should have pubKey or scriptTree (or both)");const o=typeof t=="string"?hex$1.decode(t):t||TAPROOT_UNSPENDABLE_KEY;if(!isValidPubkey(o,PubT.schnorr))throw new Error("p2tr: non-schnorr pubkey");if(e){let a=taprootAddPath(taprootHashTree(e,o,r,s));const c=a.hash,[l,u]=taprootTweakPubkey(o,c),h=taprootWalkTree(a).map(f=>({...f,controlBlock:TaprootControlBlock.encode({version:(f.version||TAP_LEAF_VERSION)+u,internalKey:o,merklePath:f.path})}));return{type:"tr",script:OutScript.encode({type:"tr",pubkey:l}),address:Address(n).encode({type:"tr",pubkey:l}),tweakedPubkey:l,tapInternalKey:o,leaves:h,tapLeafScript:h.map(f=>[TaprootControlBlock.decode(f.controlBlock),concatBytes$3(f.script,new Uint8Array([f.version||TAP_LEAF_VERSION]))]),tapMerkleRoot:c}}else{const a=taprootTweakPubkey(o,EMPTY)[0];return{type:"tr",script:OutScript.encode({type:"tr",pubkey:a}),address:Address(n).encode({type:"tr",pubkey:a}),tweakedPubkey:a,tapInternalKey:o}}}function combinations(t,e){const n=[];if(!Array.isArray(e))throw new Error("combinations: lst arg should be array");const r=e.length;if(t>r)throw new Error("combinations: m > lst.length, no combinations possible");const s=Array.from({length:t},(a,c)=>c),o=s.length-1;e:for(;;){n.push(s.map(c=>e[c])),s[o]+=1;let a=o;for(;a>=0&&s[a]>r-t+a;a--){if(s[a]=0,a===0)break e;s[a-1]+=1}for(a+=1;a<s.length;a++)s[a]=s[a-1]+1}return n}const p2tr_ns=(t,e,n=!1)=>(n||uniqPubkey(e),combinations(t,e).map(r=>({type:"tr_ns",script:OutScript.encode({type:"tr_ns",pubkeys:r})}))),p2tr_pk=t=>p2tr_ns(1,[t],void 0)[0];function p2tr_ms(t,e,n=!1){return n||uniqPubkey(e),{type:"tr_ms",script:OutScript.encode({type:"tr_ms",pubkeys:e,m:t})}}function getAddress(t,e,n=NETWORK){if(t==="tr")return p2tr(pubSchnorr(e),void 0,n).address;const r=pubECDSA(e);if(t==="pkh")return p2pkh(r,n).address;if(t==="wpkh")return p2wpkh(r,n).address;throw new Error(`getAddress: unknown type=${t}`)}const _sortPubkeys=t=>Array.from(t).sort(compareBytes);function multisig(t,e,n=!1,r=!1,s=NETWORK){const o=p2ms(t,n?_sortPubkeys(e):e);return r?p2wsh(o,s):p2sh(o,s)}function sortedMultisig(t,e,n=!1,r=NETWORK){return multisig(t,e,!0,n,r)}const base58check=createBase58check(sha256$3);function validateWitness(t,e){if(e.length<2||e.length>40)throw new Error("Witness: invalid length");if(t>16)throw new Error("Witness: invalid version");if(t===0&&!(e.length===20||e.length===32))throw new Error("Witness: invalid length for version")}function programToWitness(t,e,n=NETWORK){validateWitness(t,e);const r=t===0?bech32$1:bech32m;return r.encode(n.bech32,[t].concat(r.toWords(e)))}function formatKey(t,e){return base58check.encode(concatBytes$3(Uint8Array.from(e),t))}function WIF(t=NETWORK){return{encode(e){const n=concatBytes$3(e,new Uint8Array([1]));return formatKey(n.subarray(0,33),[t.wif])},decode(e){let n=base58check.decode(e);if(n[0]!==t.wif)throw new Error("Wrong WIF prefix");if(n=n.subarray(1),n.length!==33)throw new Error("Wrong WIF length");if(n[32]!==1)throw new Error("Wrong WIF postfix");return n.subarray(0,-1)}}}function Address(t=NETWORK){return{encode(e){const{type:n}=e;if(n==="wpkh")return programToWitness(0,e.hash,t);if(n==="wsh")return programToWitness(0,e.hash,t);if(n==="tr")return programToWitness(1,e.pubkey,t);if(n==="pkh")return formatKey(e.hash,[t.pubKeyHash]);if(n==="sh")return formatKey(e.hash,[t.scriptHash]);throw new Error(`Unknown address type=${n}`)},decode(e){if(e.length<14||e.length>74)throw new Error("Invalid address length");if(t.bech32&&e.toLowerCase().startsWith(`${t.bech32}1`)){let r;try{if(r=bech32$1.decode(e),r.words[0]!==0)throw new Error(`bech32: wrong version=${r.words[0]}`)}catch{if(r=bech32m.decode(e),r.words[0]===0)throw new Error(`bech32m: wrong version=${r.words[0]}`)}if(r.prefix!==t.bech32)throw new Error(`wrong bech32 prefix=${r.prefix}`);const[s,...o]=r.words,a=bech32$1.fromWords(o);if(validateWitness(s,a),s===0&&a.length===32)return{type:"wsh",hash:a};if(s===0&&a.length===20)return{type:"wpkh",hash:a};if(s===1&&a.length===32)return{type:"tr",pubkey:a};throw new Error("Unknown witness program")}const n=base58check.decode(e);if(n.length!==21)throw new Error("Invalid base58 address");if(n[0]===t.pubKeyHash)return{type:"pkh",hash:n.slice(1)};if(n[0]===t.scriptHash)return{type:"sh",hash:n.slice(1)};throw new Error(`Invalid address prefix=${n[0]}`)}}}const EMPTY32=new Uint8Array(32),EMPTY_OUTPUT={amount:0xffffffffffffffffn,script:EMPTY},toVsize=t=>Math.ceil(t/4),PRECISION=8,DEFAULT_VERSION=2,DEFAULT_LOCKTIME=0,DEFAULT_SEQUENCE=4294967295,Decimal=coders.decimal(PRECISION),def=(t,e)=>t===void 0?e:t;function cloneDeep(t){if(Array.isArray(t))return t.map(e=>cloneDeep(e));if(isBytes$1(t))return Uint8Array.from(t);if(["number","bigint","boolean","string","undefined"].includes(typeof t))return t;if(t===null)return t;if(typeof t=="object")return Object.fromEntries(Object.entries(t).map(([e,n])=>[e,cloneDeep(n)]));throw new Error(`cloneDeep: unknown type=${t} (${typeof t})`)}var SignatureHash;(function(t){t[t.DEFAULT=0]="DEFAULT",t[t.ALL=1]="ALL",t[t.NONE=2]="NONE",t[t.SINGLE=3]="SINGLE",t[t.ANYONECANPAY=128]="ANYONECANPAY"})(SignatureHash||(SignatureHash={}));var SigHash;(function(t){t[t.DEFAULT=0]="DEFAULT",t[t.ALL=1]="ALL",t[t.NONE=2]="NONE",t[t.SINGLE=3]="SINGLE",t[t.DEFAULT_ANYONECANPAY=128]="DEFAULT_ANYONECANPAY",t[t.ALL_ANYONECANPAY=129]="ALL_ANYONECANPAY",t[t.NONE_ANYONECANPAY=130]="NONE_ANYONECANPAY",t[t.SINGLE_ANYONECANPAY=131]="SINGLE_ANYONECANPAY"})(SigHash||(SigHash={}));function getTaprootKeys(t,e,n,r=EMPTY){return equalBytes$2(n,e)&&(t=taprootTweakPrivKey(t,r),e=pubSchnorr(t)),{privKey:t,pubKey:e}}function outputBeforeSign(t){if(t.script===void 0||t.amount===void 0)throw new Error("Transaction/output: script and amount required");return{script:t.script,amount:t.amount}}function inputBeforeSign(t){if(t.txid===void 0||t.index===void 0)throw new Error("Transaction/input: txid and index required");return{txid:t.txid,index:t.index,sequence:def(t.sequence,DEFAULT_SEQUENCE),finalScriptSig:def(t.finalScriptSig,EMPTY)}}function cleanFinalInput(t){for(const e in t){const n=e;PSBTInputFinalKeys.includes(n)||delete t[n]}}const TxHashIdx=struct({txid:createBytes(32,!0),index:U32LE});function validateSigHash(t){if(typeof t!="number"||typeof SigHash[t]!="string")throw new Error(`Invalid SigHash=${t}`);return t}function unpackSighash(t){const e=t&31;return{isAny:!!(t&SignatureHash.ANYONECANPAY),isNone:e===SignatureHash.NONE,isSingle:e===SignatureHash.SINGLE}}function validateOpts$1(t){if(t!==void 0&&{}.toString.call(t)!=="[object Object]")throw new Error(`Wrong object type for transaction options: ${t}`);const e={...t,version:def(t.version,DEFAULT_VERSION),lockTime:def(t.lockTime,0),PSBTVersion:def(t.PSBTVersion,0)};if(typeof e.allowUnknowInput<"u"&&(t.allowUnknownInputs=e.allowUnknowInput),typeof e.allowUnknowOutput<"u"&&(t.allowUnknownOutputs=e.allowUnknowOutput),typeof e.lockTime!="number")throw new Error("Transaction lock time should be number");if(U32LE.encode(e.lockTime),e.PSBTVersion!==0&&e.PSBTVersion!==2)throw new Error(`Unknown PSBT version ${e.PSBTVersion}`);for(const n of["allowUnknownVersion","allowUnknownOutputs","allowUnknownInputs","disableScriptCheck","bip174jsCompat","allowLegacyWitnessUtxo","lowR"]){const r=e[n];if(r!==void 0&&typeof r!="boolean")throw new Error(`Transation options wrong type: ${n}=${r} (${typeof r})`)}if(e.allowUnknownVersion?typeof e.version=="number":![-1,0,1,2,3].includes(e.version))throw new Error(`Unknown version: ${e.version}`);if(e.customScripts!==void 0){const n=e.customScripts;if(!Array.isArray(n))throw new Error(`wrong custom scripts type (expected array): customScripts=${n} (${typeof n})`);for(const r of n){if(typeof r.encode!="function"||typeof r.decode!="function")throw new Error(`wrong script=${r} (${typeof r})`);if(r.finalizeTaproot!==void 0&&typeof r.finalizeTaproot!="function")throw new Error(`wrong script=${r} (${typeof r})`)}}return Object.freeze(e)}function validateInput$1(t){if(t.nonWitnessUtxo&&t.index!==void 0){const e=t.nonWitnessUtxo.outputs.length-1;if(t.index>e)throw new Error(`validateInput: index(${t.index}) not in nonWitnessUtxo`);const n=t.nonWitnessUtxo.outputs[t.index];if(t.witnessUtxo&&(!equalBytes$2(t.witnessUtxo.script,n.script)||t.witnessUtxo.amount!==n.amount))throw new Error("validateInput: witnessUtxo different from nonWitnessUtxo");if(t.txid){if(t.nonWitnessUtxo.outputs.length-1<t.index)throw new Error("nonWitnessUtxo: incorect output index");const s=Transaction.fromRaw(RawTx.encode(t.nonWitnessUtxo),{allowUnknownOutputs:!0,disableScriptCheck:!0,allowUnknownInputs:!0}),o=hex$1.encode(t.txid);if(s.isFinal&&s.id!==o)throw new Error(`nonWitnessUtxo: wrong txid, exp=${o} got=${s.id}`)}}return t}function getPrevOut(t){if(t.nonWitnessUtxo){if(t.index===void 0)throw new Error("Unknown input index");return t.nonWitnessUtxo.outputs[t.index]}else{if(t.witnessUtxo)return t.witnessUtxo;throw new Error("Cannot find previous output info")}}function normalizeInput(t,e,n,r=!1,s=!1){let{nonWitnessUtxo:o,txid:a}=t;typeof o=="string"&&(o=hex$1.decode(o)),isBytes$1(o)&&(o=RawTx.decode(o)),!("nonWitnessUtxo"in t)&&o===void 0&&(o=e==null?void 0:e.nonWitnessUtxo),typeof a=="string"&&(a=hex$1.decode(a)),a===void 0&&(a=e==null?void 0:e.txid);let c={...e,...t,nonWitnessUtxo:o,txid:a};!("nonWitnessUtxo"in t)&&c.nonWitnessUtxo===void 0&&delete c.nonWitnessUtxo,c.sequence===void 0&&(c.sequence=DEFAULT_SEQUENCE),c.tapMerkleRoot===null&&delete c.tapMerkleRoot,c=mergeKeyMap(PSBTInput,c,e,n,s),PSBTInputCoder.encode(c);let l;return c.nonWitnessUtxo&&c.index!==void 0?l=c.nonWitnessUtxo.outputs[c.index]:c.witnessUtxo&&(l=c.witnessUtxo),l&&!r&&checkScript(l&&l.script,c.redeemScript,c.witnessScript),c}function getInputType(t,e=!1){let n="legacy",r=SignatureHash.ALL;const s=getPrevOut(t),o=OutScript.decode(s.script);let a=o.type,c=o;const l=[o];if(o.type==="tr")return r=SignatureHash.DEFAULT,{txType:"taproot",type:"tr",last:o,lastScript:s.script,defaultSighash:r,sighash:t.sighashType||r};{if((o.type==="wpkh"||o.type==="wsh")&&(n="segwit"),o.type==="sh"){if(!t.redeemScript)throw new Error("inputType: sh without redeemScript");let p=OutScript.decode(t.redeemScript);(p.type==="wpkh"||p.type==="wsh")&&(n="segwit"),l.push(p),c=p,a+=`-${p.type}`}if(c.type==="wsh"){if(!t.witnessScript)throw new Error("inputType: wsh without witnessScript");let p=OutScript.decode(t.witnessScript);p.type==="wsh"&&(n="segwit"),l.push(p),c=p,a+=`-${p.type}`}const u=l[l.length-1];if(u.type==="sh"||u.type==="wsh")throw new Error("inputType: sh/wsh cannot be terminal type");const h=OutScript.encode(u),f={type:a,txType:n,last:u,lastScript:h,defaultSighash:r,sighash:t.sighashType||r};if(n==="legacy"&&!e&&!t.nonWitnessUtxo)throw new Error("Transaction/sign: legacy input without nonWitnessUtxo, can result in attack that forces paying higher fees. Pass allowLegacyWitnessUtxo=true, if you sure");return f}}class Transaction{constructor(e={}){this.global={},this.inputs=[],this.outputs=[];const n=this.opts=validateOpts$1(e);n.lockTime!==DEFAULT_LOCKTIME&&(this.global.fallbackLocktime=n.lockTime),this.global.txVersion=n.version}static fromRaw(e,n={}){const r=RawTx.decode(e),s=new Transaction({...n,version:r.version,lockTime:r.lockTime});for(const o of r.outputs)s.addOutput(o);if(s.outputs=r.outputs,s.inputs=r.inputs,r.witnesses)for(let o=0;o<r.witnesses.length;o++)s.inputs[o].finalScriptWitness=r.witnesses[o];return s}static fromPSBT(e,n={}){let r;try{r=RawPSBTV0.decode(e)}catch(f){try{r=RawPSBTV2.decode(e)}catch{throw f}}const s=r.global.version||0;if(s!==0&&s!==2)throw new Error(`Wrong PSBT version=${s}`);const o=r.global.unsignedTx,a=s===0?o==null?void 0:o.version:r.global.txVersion,c=s===0?o==null?void 0:o.lockTime:r.global.fallbackLocktime,l=new Transaction({...n,version:a,lockTime:c,PSBTVersion:s}),u=s===0?o==null?void 0:o.inputs.length:r.global.inputCount;l.inputs=r.inputs.slice(0,u).map((f,p)=>{var g;return validateInput$1({finalScriptSig:EMPTY,...(g=r.global.unsignedTx)==null?void 0:g.inputs[p],...f})});const h=s===0?o==null?void 0:o.outputs.length:r.global.outputCount;return l.outputs=r.outputs.slice(0,h).map((f,p)=>{var g;return{...f,...(g=r.global.unsignedTx)==null?void 0:g.outputs[p]}}),l.global={...r.global,txVersion:a},c!==DEFAULT_LOCKTIME&&(l.global.fallbackLocktime=c),l}toPSBT(e=this.opts.PSBTVersion){if(e!==0&&e!==2)throw new Error(`Wrong PSBT version=${e}`);const n=this.inputs.map(o=>validateInput$1(cleanPSBTFields(e,PSBTInput,o)));for(const o of n)o.partialSig&&!o.partialSig.length&&delete o.partialSig,o.finalScriptSig&&!o.finalScriptSig.length&&delete o.finalScriptSig,o.finalScriptWitness&&!o.finalScriptWitness.length&&delete o.finalScriptWitness;const r=this.outputs.map(o=>cleanPSBTFields(e,PSBTOutput,o)),s={...this.global};return e===0?(s.unsignedTx=RawOldTx.decode(RawOldTx.encode({version:this.version,lockTime:this.lockTime,inputs:this.inputs.map(inputBeforeSign).map(o=>({...o,finalScriptSig:EMPTY})),outputs:this.outputs.map(outputBeforeSign)})),delete s.fallbackLocktime,delete s.txVersion):(s.version=e,s.txVersion=this.version,s.inputCount=this.inputs.length,s.outputCount=this.outputs.length,s.fallbackLocktime&&s.fallbackLocktime===DEFAULT_LOCKTIME&&delete s.fallbackLocktime),this.opts.bip174jsCompat&&(n.length||n.push({}),r.length||r.push({})),(e===0?RawPSBTV0:RawPSBTV2).encode({global:s,inputs:n,outputs:r})}get lockTime(){let e=DEFAULT_LOCKTIME,n=0,r=DEFAULT_LOCKTIME,s=0;for(const o of this.inputs)o.requiredHeightLocktime&&(e=Math.max(e,o.requiredHeightLocktime),n++),o.requiredTimeLocktime&&(r=Math.max(r,o.requiredTimeLocktime),s++);return n&&n>=s?e:r!==DEFAULT_LOCKTIME?r:this.global.fallbackLocktime||DEFAULT_LOCKTIME}get version(){if(this.global.txVersion===void 0)throw new Error("No global.txVersion");return this.global.txVersion}inputStatus(e){this.checkInputIdx(e);const n=this.inputs[e];return n.finalScriptSig&&n.finalScriptSig.length||n.finalScriptWitness&&n.finalScriptWitness.length?"finalized":n.tapKeySig||n.tapScriptSig&&n.tapScriptSig.length||n.partialSig&&n.partialSig.length?"signed":"unsigned"}inputSighash(e){this.checkInputIdx(e);const n=this.inputs[e].sighashType,r=n===void 0?SignatureHash.DEFAULT:n,s=r===SignatureHash.DEFAULT?SignatureHash.ALL:r&3;return{sigInputs:r&SignatureHash.ANYONECANPAY,sigOutputs:s}}signStatus(){let e=!0,n=!0,r=[],s=[];for(let o=0;o<this.inputs.length;o++){if(this.inputStatus(o)==="unsigned")continue;const{sigInputs:c,sigOutputs:l}=this.inputSighash(o);if(c===SignatureHash.ANYONECANPAY?r.push(o):e=!1,l===SignatureHash.ALL)n=!1;else if(l===SignatureHash.SINGLE)s.push(o);else if(l!==SignatureHash.NONE)throw new Error(`Wrong signature hash output type: ${l}`)}return{addInput:e,addOutput:n,inputs:r,outputs:s}}get isFinal(){for(let e=0;e<this.inputs.length;e++)if(this.inputStatus(e)!=="finalized")return!1;return!0}get hasWitnesses(){let e=!1;for(const n of this.inputs)n.finalScriptWitness&&n.finalScriptWitness.length&&(e=!0);return e}get weight(){if(!this.isFinal)throw new Error("Transaction is not finalized");let e=32;const n=this.outputs.map(outputBeforeSign);e+=4*CompactSizeLen.encode(this.outputs.length).length;for(const r of n)e+=32+4*VarBytes.encode(r.script).length;this.hasWitnesses&&(e+=2),e+=4*CompactSizeLen.encode(this.inputs.length).length;for(const r of this.inputs)e+=160+4*VarBytes.encode(r.finalScriptSig||EMPTY).length,this.hasWitnesses&&r.finalScriptWitness&&(e+=RawWitness.encode(r.finalScriptWitness).length);return e}get vsize(){return toVsize(this.weight)}toBytes(e=!1,n=!1){return RawTx.encode({version:this.version,lockTime:this.lockTime,inputs:this.inputs.map(inputBeforeSign).map(r=>({...r,finalScriptSig:e&&r.finalScriptSig||EMPTY})),outputs:this.outputs.map(outputBeforeSign),witnesses:this.inputs.map(r=>r.finalScriptWitness||[]),segwitFlag:n&&this.hasWitnesses})}get unsignedTx(){return this.toBytes(!1,!1)}get hex(){return hex$1.encode(this.toBytes(!0,this.hasWitnesses))}get hash(){if(!this.isFinal)throw new Error("Transaction is not finalized");return hex$1.encode(sha256x2(this.toBytes(!0)))}get id(){if(!this.isFinal)throw new Error("Transaction is not finalized");return hex$1.encode(sha256x2(this.toBytes(!0)).reverse())}checkInputIdx(e){if(!Number.isSafeInteger(e)||0>e||e>=this.inputs.length)throw new Error(`Wrong input index=${e}`)}getInput(e){return this.checkInputIdx(e),cloneDeep(this.inputs[e])}get inputsLength(){return this.inputs.length}addInput(e,n=!1){if(!n&&!this.signStatus().addInput)throw new Error("Tx has signed inputs, cannot add new one");return this.inputs.push(normalizeInput(e,void 0,void 0,this.opts.disableScriptCheck)),this.inputs.length-1}updateInput(e,n,r=!1){this.checkInputIdx(e);let s;if(!r){const o=this.signStatus();(!o.addInput||o.inputs.includes(e))&&(s=PSBTInputUnsignedKeys)}this.inputs[e]=normalizeInput(n,this.inputs[e],s,this.opts.disableScriptCheck,this.opts.allowUnknown)}checkOutputIdx(e){if(!Number.isSafeInteger(e)||0>e||e>=this.outputs.length)throw new Error(`Wrong output index=${e}`)}getOutput(e){return this.checkOutputIdx(e),cloneDeep(this.outputs[e])}getOutputAddress(e,n=NETWORK){const r=this.getOutput(e);if(r.script)return Address(n).encode(OutScript.decode(r.script))}get outputsLength(){return this.outputs.length}normalizeOutput(e,n,r){let{amount:s,script:o}=e;if(s===void 0&&(s=n==null?void 0:n.amount),typeof s!="bigint")throw new Error(`Wrong amount type, should be of type bigint in sats, but got ${s} of type ${typeof s}`);typeof o=="string"&&(o=hex$1.decode(o)),o===void 0&&(o=n==null?void 0:n.script);let a={...n,...e,amount:s,script:o};if(a.amount===void 0&&delete a.amount,a=mergeKeyMap(PSBTOutput,a,n,r,this.opts.allowUnknown),PSBTOutputCoder.encode(a),a.script&&!this.opts.allowUnknownOutputs&&OutScript.decode(a.script).type==="unknown")throw new Error("Transaction/output: unknown output script type, there is a chance that input is unspendable. Pass allowUnknownOutputs=true, if you sure");return this.opts.disableScriptCheck||checkScript(a.script,a.redeemScript,a.witnessScript),a}addOutput(e,n=!1){if(!n&&!this.signStatus().addOutput)throw new Error("Tx has signed outputs, cannot add new one");return this.outputs.push(this.normalizeOutput(e)),this.outputs.length-1}updateOutput(e,n,r=!1){this.checkOutputIdx(e);let s;if(!r){const o=this.signStatus();(!o.addOutput||o.outputs.includes(e))&&(s=PSBTOutputUnsignedKeys)}this.outputs[e]=this.normalizeOutput(n,this.outputs[e],s)}addOutputAddress(e,n,r=NETWORK){return this.addOutput({script:OutScript.encode(Address(r).decode(e)),amount:n})}get fee(){let e=0n;for(const r of this.inputs){const s=getPrevOut(r);if(!s)throw new Error("Empty input amount");e+=s.amount}const n=this.outputs.map(outputBeforeSign);for(const r of n)e-=r.amount;return e}preimageLegacy(e,n,r){const{isAny:s,isNone:o,isSingle:a}=unpackSighash(r);if(e<0||!Number.isSafeInteger(e))throw new Error(`Invalid input idx=${e}`);if(a&&e>=this.outputs.length||e>=this.inputs.length)return U256BE.encode(1n);n=Script.encode(Script.decode(n).filter(h=>h!=="CODESEPARATOR"));let c=this.inputs.map(inputBeforeSign).map((h,f)=>({...h,finalScriptSig:f===e?n:EMPTY}));s?c=[c[e]]:(o||a)&&(c=c.map((h,f)=>({...h,sequence:f===e?h.sequence:0})));let l=this.outputs.map(outputBeforeSign);o?l=[]:a&&(l=l.slice(0,e).fill(EMPTY_OUTPUT).concat([l[e]]));const u=RawTx.encode({lockTime:this.lockTime,version:this.version,segwitFlag:!1,inputs:c,outputs:l});return sha256x2(u,I32LE.encode(r))}preimageWitnessV0(e,n,r,s){const{isAny:o,isNone:a,isSingle:c}=unpackSighash(r);let l=EMPTY32,u=EMPTY32,h=EMPTY32;const f=this.inputs.map(inputBeforeSign),p=this.outputs.map(outputBeforeSign);o||(l=sha256x2(...f.map(TxHashIdx.encode))),!o&&!c&&!a&&(u=sha256x2(...f.map(w=>U32LE.encode(w.sequence)))),!c&&!a?h=sha256x2(...p.map(RawOutput.encode)):c&&e<p.length&&(h=sha256x2(RawOutput.encode(p[e])));const g=f[e];return sha256x2(I32LE.encode(this.version),l,u,createBytes(32,!0).encode(g.txid),U32LE.encode(g.index),VarBytes.encode(n),U64LE.encode(s),U32LE.encode(g.sequence),h,U32LE.encode(this.lockTime),U32LE.encode(r))}preimageWitnessV1(e,n,r,s,o=-1,a,c=192,l){if(!Array.isArray(s)||this.inputs.length!==s.length)throw new Error(`Invalid amounts array=${s}`);if(!Array.isArray(n)||this.inputs.length!==n.length)throw new Error(`Invalid prevOutScript array=${n}`);const u=[U8.encode(0),U8.encode(r),I32LE.encode(this.version),U32LE.encode(this.lockTime)],h=r===SignatureHash.DEFAULT?SignatureHash.ALL:r&3,f=r&SignatureHash.ANYONECANPAY,p=this.inputs.map(inputBeforeSign),g=this.outputs.map(outputBeforeSign);f!==SignatureHash.ANYONECANPAY&&u.push(...[p.map(TxHashIdx.encode),s.map(U64LE.encode),n.map(VarBytes.encode),p.map(y=>U32LE.encode(y.sequence))].map(y=>sha256$3(concatBytes$3(...y)))),h===SignatureHash.ALL&&u.push(sha256$3(concatBytes$3(...g.map(RawOutput.encode))));const w=(l?1:0)|(a?2:0);if(u.push(new Uint8Array([w])),f===SignatureHash.ANYONECANPAY){const y=p[e];u.push(TxHashIdx.encode(y),U64LE.encode(s[e]),VarBytes.encode(n[e]),U32LE.encode(y.sequence))}else u.push(U32LE.encode(e));return w&1&&u.push(sha256$3(VarBytes.encode(l||EMPTY))),h===SignatureHash.SINGLE&&u.push(e<g.length?sha256$3(RawOutput.encode(g[e])):EMPTY32),a&&u.push(tapLeafHash(a,c),U8.encode(0),I32LE.encode(o)),tagSchnorr("TapSighash",...u)}signIdx(e,n,r,s){this.checkInputIdx(n);const o=this.inputs[n],a=getInputType(o,this.opts.allowLegacyWitnessUtxo);if(!isBytes$1(e)){if(!o.bip32Derivation||!o.bip32Derivation.length)throw new Error("bip32Derivation: empty");const h=o.bip32Derivation.filter(p=>p[1].fingerprint==e.fingerprint).map(([p,{path:g}])=>{let w=e;for(const y of g)w=w.deriveChild(y);if(!equalBytes$2(w.publicKey,p))throw new Error("bip32Derivation: wrong pubKey");if(!w.privateKey)throw new Error("bip32Derivation: no privateKey");return w});if(!h.length)throw new Error(`bip32Derivation: no items with fingerprint=${e.fingerprint}`);let f=!1;for(const p of h)this.signIdx(p.privateKey,n)&&(f=!0);return f}r?r.forEach(validateSigHash):r=[a.defaultSighash];const c=a.sighash;if(!r.includes(c))throw new Error(`Input with not allowed sigHash=${c}. Allowed: ${r.join(", ")}`);const{sigOutputs:l}=this.inputSighash(n);if(l===SignatureHash.SINGLE&&n>=this.outputs.length)throw new Error(`Input with sighash SINGLE, but there is no output with corresponding index=${n}`);const u=getPrevOut(o);if(a.txType==="taproot"){const h=this.inputs.map(getPrevOut),f=h.map(b=>b.script),p=h.map(b=>b.amount);let g=!1,w=pubSchnorr(e),y=o.tapMerkleRoot||EMPTY;if(o.tapInternalKey){const{pubKey:b,privKey:x}=getTaprootKeys(e,w,o.tapInternalKey,y),[_,R]=taprootTweakPubkey(o.tapInternalKey,y);if(equalBytes$2(_,b)){const $=this.preimageWitnessV1(n,f,c,p),A=concatBytes$3(signSchnorr($,x,s),c!==SignatureHash.DEFAULT?new Uint8Array([c]):EMPTY);this.updateInput(n,{tapKeySig:A},!0),g=!0}}if(o.tapLeafScript){o.tapScriptSig=o.tapScriptSig||[];for(const[b,x]of o.tapLeafScript){const _=x.subarray(0,-1),R=Script.decode(_),$=x[x.length-1],A=tapLeafHash(_,$);if(R.findIndex(j=>isBytes$1(j)&&equalBytes$2(j,w))===-1)continue;const v=this.preimageWitnessV1(n,f,c,p,void 0,_,$),D=concatBytes$3(signSchnorr(v,e,s),c!==SignatureHash.DEFAULT?new Uint8Array([c]):EMPTY);this.updateInput(n,{tapScriptSig:[[{pubKey:w,leafHash:A},D]]},!0),g=!0}}if(!g)throw new Error("No taproot scripts signed");return!0}else{const h=pubECDSA(e);let f=!1;const p=hash160(h);for(const y of Script.decode(a.lastScript))isBytes$1(y)&&(equalBytes$2(y,h)||equalBytes$2(y,p))&&(f=!0);if(!f)throw new Error(`Input script doesn't have pubKey: ${a.lastScript}`);let g;if(a.txType==="legacy")g=this.preimageLegacy(n,a.lastScript,c);else if(a.txType==="segwit"){let y=a.lastScript;a.last.type==="wpkh"&&(y=OutScript.encode({type:"pkh",hash:a.last.hash})),g=this.preimageWitnessV0(n,y,c,u.amount)}else throw new Error(`Transaction/sign: unknown tx type: ${a.txType}`);const w=signECDSA(g,e,this.opts.lowR);this.updateInput(n,{partialSig:[[h,concatBytes$3(w,new Uint8Array([c]))]]},!0)}return!0}sign(e,n,r){let s=0;for(let o=0;o<this.inputs.length;o++)try{this.signIdx(e,o,n,r)&&s++}catch{}if(!s)throw new Error("No inputs signed");return s}finalizeIdx(e){if(this.checkInputIdx(e),this.fee<0n)throw new Error("Outputs spends more than inputs amount");const n=this.inputs[e],r=getInputType(n,this.opts.allowLegacyWitnessUtxo);if(r.txType==="taproot"){if(n.tapKeySig)n.finalScriptWitness=[n.tapKeySig];else if(n.tapLeafScript&&n.tapScriptSig){const l=n.tapLeafScript.sort((u,h)=>TaprootControlBlock.encode(u[0]).length-TaprootControlBlock.encode(h[0]).length);for(const[u,h]of l){const f=h.slice(0,-1),p=h[h.length-1],g=OutScript.decode(f),w=tapLeafHash(f,p),y=n.tapScriptSig.filter(x=>equalBytes$2(x[0].leafHash,w));let b=[];if(g.type==="tr_ms"){const x=g.m,_=g.pubkeys;let R=0;for(const $ of _){const A=y.findIndex(L=>equalBytes$2(L[0].pubKey,$));if(R===x||A===-1){b.push(EMPTY);continue}b.push(y[A][1]),R++}if(R!==x)continue}else if(g.type==="tr_ns"){for(const x of g.pubkeys){const _=y.findIndex(R=>equalBytes$2(R[0].pubKey,x));_!==-1&&b.push(y[_][1])}if(b.length!==g.pubkeys.length)continue}else if(g.type==="unknown"&&this.opts.allowUnknownInputs){const x=Script.decode(f);if(b=y.map(([{pubKey:_},R])=>{const $=x.findIndex(A=>isBytes$1(A)&&equalBytes$2(A,_));if($===-1)throw new Error("finalize/taproot: cannot find position of pubkey in script");return{signature:R,pos:$}}).sort((_,R)=>_.pos-R.pos).map(_=>_.signature),!b.length)continue}else{const x=this.opts.customScripts;if(x)for(const _ of x){if(!_.finalizeTaproot)continue;const R=Script.decode(f),$=_.encode(R);if($===void 0)continue;const A=_.finalizeTaproot(f,$,y);if(A){n.finalScriptWitness=A.concat(TaprootControlBlock.encode(u)),n.finalScriptSig=EMPTY,cleanFinalInput(n);return}}throw new Error("Finalize: Unknown tapLeafScript")}n.finalScriptWitness=b.reverse().concat([f,TaprootControlBlock.encode(u)]);break}if(!n.finalScriptWitness)throw new Error("finalize/taproot: empty witness")}else throw new Error("finalize/taproot: unknown input");n.finalScriptSig=EMPTY,cleanFinalInput(n);return}if(!n.partialSig||!n.partialSig.length)throw new Error("Not enough partial sign");let s=EMPTY,o=[];if(r.last.type==="ms"){const l=r.last.m,u=r.last.pubkeys;let h=[];for(const f of u){const p=n.partialSig.find(g=>equalBytes$2(f,g[0]));p&&h.push(p[1])}if(h=h.slice(0,l),h.length!==l)throw new Error(`Multisig: wrong signatures count, m=${l} n=${u.length} signatures=${h.length}`);s=Script.encode([0,...h])}else if(r.last.type==="pk")s=Script.encode([n.partialSig[0][1]]);else if(r.last.type==="pkh")s=Script.encode([n.partialSig[0][1],n.partialSig[0][0]]);else if(r.last.type==="wpkh")s=EMPTY,o=[n.partialSig[0][1],n.partialSig[0][0]];else if(r.last.type==="unknown"&&!this.opts.allowUnknownInputs)throw new Error("Unknown inputs not allowed");let a,c;if(r.type.includes("wsh-")&&(s.length&&r.lastScript.length&&(o=Script.decode(s).map(l=>{if(l===0)return EMPTY;if(isBytes$1(l))return l;throw new Error(`Wrong witness op=${l}`)})),o=o.concat(r.lastScript)),r.txType==="segwit"&&(c=o),r.type.startsWith("sh-wsh-")?a=Script.encode([Script.encode([0,sha256$3(r.lastScript)])]):r.type.startsWith("sh-")?a=Script.encode([...Script.decode(s),r.lastScript]):r.type.startsWith("wsh-")||r.txType!=="segwit"&&(a=s),!a&&!c)throw new Error("Unknown error finalizing input");a&&(n.finalScriptSig=a),c&&(n.finalScriptWitness=c),cleanFinalInput(n)}finalize(){for(let e=0;e<this.inputs.length;e++)this.finalizeIdx(e)}extract(){if(!this.isFinal)throw new Error("Transaction has unfinalized inputs");if(!this.outputs.length)throw new Error("Transaction has no outputs");if(this.fee<0n)throw new Error("Outputs spends more than inputs amount");return this.toBytes(!0,!0)}combine(e){for(const s of["PSBTVersion","version","lockTime"])if(this.opts[s]!==e.opts[s])throw new Error(`Transaction/combine: different ${s} this=${this.opts[s]} other=${e.opts[s]}`);for(const s of["inputs","outputs"])if(this[s].length!==e[s].length)throw new Error(`Transaction/combine: different ${s} length this=${this[s].length} other=${e[s].length}`);const n=this.global.unsignedTx?RawOldTx.encode(this.global.unsignedTx):EMPTY,r=e.global.unsignedTx?RawOldTx.encode(e.global.unsignedTx):EMPTY;if(!equalBytes$2(n,r))throw new Error("Transaction/combine: different unsigned tx");this.global=mergeKeyMap(PSBTGlobal,this.global,e.global,void 0,this.opts.allowUnknown);for(let s=0;s<this.inputs.length;s++)this.updateInput(s,e.inputs[s],!0);for(let s=0;s<this.outputs.length;s++)this.updateOutput(s,e.outputs[s],!0);return this}clone(){return Transaction.fromPSBT(this.toPSBT(this.opts.PSBTVersion),this.opts)}}function PSBTCombine(t){if(!t||!Array.isArray(t)||!t.length)throw new Error("PSBTCombine: wrong PSBT list");const e=Transaction.fromPSBT(t[0]);for(let n=1;n<t.length;n++)e.combine(Transaction.fromPSBT(t[n]));return e.toPSBT()}const HARDENED_OFFSET=2147483648;function bip32Path(t){const e=[];if(!/^[mM]'?/.test(t))throw new Error('Path must start with "m" or "M"');if(/^[mM]'?$/.test(t))return e;const n=t.replace(/^[mM]'?\//,"").split("/");for(const r of n){const s=/^(\d+)('?)$/.exec(r);if(!s||s.length!==3)throw new Error(`Invalid child index: ${r}`);let o=+s[1];if(!Number.isSafeInteger(o)||o>=HARDENED_OFFSET)throw new Error("Invalid index");s[2]==="'"&&(o+=HARDENED_OFFSET),e.push(o)}return e}class InvalidContributionErr extends Error{constructor(e,n){super(n),this.idx=e}}const{taggedHash:taggedHash$1,pointToBytes:pointToBytes$1}=schnorr$1.utils,Point$2=secp256k1$1.ProjectivePoint,PUBKEY_LEN=33,ZERO=new Uint8Array(PUBKEY_LEN),SECP_N=secp256k1$1.CURVE.n,compressed=apply(createBytes(33),{decode:t=>isZero(t)?ZERO:t.toRawBytes(!0),encode:t=>equalBytes$4(t,ZERO)?Point$2.ZERO:Point$2.fromHex(t)}),scalar=validate$1(U256BE,t=>(aInRange("n",t,1n,SECP_N),t)),PubNonce=struct({R1:compressed,R2:compressed}),SecretNonce=struct({k1:scalar,k2:scalar,publicKey:createBytes(PUBKEY_LEN)});function abytesOptional(t,...e){t!==void 0&&abytes$2(t,...e)}function abytesArray(t,...e){if(!Array.isArray(t))throw new Error("expected array");t.forEach(n=>abytes$2(n,...e))}function aXonly(t){if(!Array.isArray(t))throw new Error("expected array");t.forEach((e,n)=>{if(typeof e!="boolean")throw new Error("expected boolean in xOnly array, got"+e+"("+n+")")})}const modN$1=t=>mod$1(t,SECP_N),taggedInt=(t,...e)=>modN$1(bytesToNumberBE$1(taggedHash$1(t,...e))),evenScalar=(t,e)=>t.hasEvenY()?e:modN$1(-e);function mulBase(t){return Point$2.BASE.multiply(t)}function isZero(t){return t.equals(Point$2.ZERO)}function sortKeys(t){return abytesArray(t,PUBKEY_LEN),t.sort(compareBytes)}function getSecondKey(t){abytesArray(t,PUBKEY_LEN);for(let e=1;e<t.length;e++)if(!equalBytes$4(t[e],t[0]))return t[e];return ZERO}function keyAggL(t){return abytesArray(t,PUBKEY_LEN),taggedHash$1("KeyAgg list",...t)}function keyAggCoeffInternal(t,e,n){return abytes$2(t,PUBKEY_LEN),abytes$2(e,PUBKEY_LEN),equalBytes$4(t,e)?1n:taggedInt("KeyAgg coefficient",n,t)}function keyAggregate(t,e=[],n=[]){if(abytesArray(t,PUBKEY_LEN),abytesArray(e,32),e.length!==n.length)throw new Error("The tweaks and isXonly arrays must have the same length");const r=getSecondKey(t),s=keyAggL(t);let o=Point$2.ZERO;for(let l=0;l<t.length;l++){let u;try{u=Point$2.fromHex(t[l])}catch{throw new InvalidContributionErr(l,"pubkey")}o=o.add(u.multiply(keyAggCoeffInternal(t[l],r,s)))}let a=1n,c=0n;for(let l=0;l<e.length;l++){const u=n[l]&&!o.hasEvenY()?modN$1(-1n):1n,h=bytesToNumberBE$1(e[l]);if(aInRange("tweak",h,0n,SECP_N),o=o.multiply(u).add(mulBase(h)),isZero(o))throw new Error("The result of tweaking cannot be infinity");a=modN$1(u*a),c=modN$1(h+u*c)}return{aggPublicKey:o,gAcc:a,tweakAcc:c}}function aux(t,e){const n=taggedHash$1("MuSig/aux",e);if(t.length!==n.length)throw new Error("Cannot XOR arrays of different lengths");const r=new Uint8Array(t.length);for(let s=0;s<t.length;s++)r[s]=t[s]^n[s];return r}const nonceHash=(t,e,n,r,s,o)=>taggedInt("MuSig/nonce",t,new Uint8Array([e.length]),e,new Uint8Array([n.length]),n,s,numberToBytesBE$1(o.length,4),o,new Uint8Array([r]));function nonceGen(t,e,n=new Uint8Array(0),r,s=new Uint8Array(0),o=randomBytes$2(32)){abytes$2(t,PUBKEY_LEN),abytesOptional(e,32),abytes$2(n,0,32),abytesOptional(r),abytes$2(s),abytes$2(o,32),e!==void 0&&(o=aux(e,o));const a=r!==void 0?concatBytes$5(new Uint8Array([1]),numberToBytesBE$1(r.length,8),r):new Uint8Array([0]),c=nonceHash(o,t,n,0,a,s),l=nonceHash(o,t,n,1,a,s);return{secret:SecretNonce.encode({k1:c,k2:l,publicKey:t}),public:PubNonce.encode({R1:mulBase(c),R2:mulBase(l)})}}class Session{constructor(e,n,r,s=[],o=[]){if(abytesArray(n,33),abytesArray(s,32),aXonly(o),abytes$2(r),s.length!==o.length)throw new Error("The tweaks and isXonly arrays must have the same length");const{aggPublicKey:a,gAcc:c,tweakAcc:l}=keyAggregate(n,s,o),{R1:u,R2:h}=PubNonce.decode(e);this.publicKeys=n,this.Q=a,this.gAcc=c,this.tweakAcc=l,this.b=taggedInt("MuSig/noncecoef",e,pointToBytes$1(a),r);const f=u.add(h.multiply(this.b));this.R=isZero(f)?Point$2.BASE:f,this.e=taggedInt("BIP0340/challenge",pointToBytes$1(this.R),pointToBytes$1(a),r),this.tweaks=s,this.isXonly=o,this.L=keyAggL(n),this.secondKey=getSecondKey(n)}getSessionKeyAggCoeff(e){const{publicKeys:n}=this,r=e.toRawBytes(!0);if(!n.some(o=>equalBytes$4(o,r)))throw new Error("The signer's pubkey must be included in the list of pubkeys");return keyAggCoeffInternal(r,this.secondKey,this.L)}partialSigVerifyInternal(e,n,r){const{Q:s,gAcc:o,b:a,R:c,e:l}=this,u=bytesToNumberBE$1(e);if(u>=SECP_N)return!1;const{R1:h,R2:f}=PubNonce.decode(n),p=h.add(f.multiply(a)),g=c.hasEvenY()?p:p.negate(),w=Point$2.fromHex(r),y=this.getSessionKeyAggCoeff(w),b=modN$1(evenScalar(s,1n)*o),x=mulBase(u),_=g.add(w.multiply(modN$1(l*y*b)));return x.equals(_)}sign(e,n,r=!1){if(abytes$2(n,32),typeof r!="boolean")throw new Error("expected boolean");const{Q:s,gAcc:o,b:a,R:c,e:l}=this,{k1:u,k2:h,publicKey:f}=SecretNonce.decode(e);e.fill(0,0,64),aInRange("k1",u,0n,SECP_N),aInRange("k2",h,0n,SECP_N);const p=evenScalar(c,u),g=evenScalar(c,h),w=bytesToNumberBE$1(n);aInRange("d_",w,1n,SECP_N);const y=mulBase(w),b=y.toRawBytes(!0);if(!equalBytes$4(b,f))throw new Error("Public key does not match nonceGen argument");const x=this.getSessionKeyAggCoeff(y),_=evenScalar(s,1n),R=modN$1(_*o*w),$=modN$1(p+a*g+l*x*R),A=numberToBytesBE$1($,32);if(!r){const L=PubNonce.encode({R1:mulBase(u),R2:mulBase(h)});if(!this.partialSigVerifyInternal(A,L,b))throw new Error("Partial signature verification failed")}return A}partialSigVerify(e,n,r){const{publicKeys:s,tweaks:o,isXonly:a}=this;if(abytes$2(e,32),abytesArray(n,66),abytesArray(s,PUBKEY_LEN),abytesArray(o,32),aXonly(a),anumber$1(r),n.length!==s.length)throw new Error("The pubNonces and publicKeys arrays must have the same length");if(o.length!==a.length)throw new Error("The tweaks and isXonly arrays must have the same length");if(r>=n.length)throw new Error("index outside of pubKeys/pubNonces");return this.partialSigVerifyInternal(e,n[r],s[r])}partialSigAgg(e){abytesArray(e,32);const{Q:n,tweakAcc:r,R:s,e:o}=this;let a=0n;for(let l=0;l<e.length;l++){const u=bytesToNumberBE$1(e[l]);if(u>=SECP_N)throw new InvalidContributionErr(l,"psig");a=modN$1(a+u)}const c=evenScalar(n,1n);return a=modN$1(a+o*c*r),concatBytes$5(pointToBytes$1(s),numberToBytesBE$1(a,32))}}function generateNonces(t){const e=nonceGen(t);return{secNonce:e.secret,pubNonce:e.public}}/*! noble-secp256k1 - MIT License (c) 2019 Paul Miller (paulmillr.com) */const B256=2n**256n,P=B256-0x1000003d1n,N=B256-0x14551231950b75fc4402da1732fc9bebfn,Gx=0x79be667ef9dcbbac55a06295ce870b07029bfcdb2dce28d959f2815b16f81798n,Gy=0x483ada7726a3c4655da4fbfc0e1108a8fd17b448a68554199c47d08ffb10d4b8n,CURVE={p:P,n:N,a:0n,b:7n,Gx,Gy},fLen=32,curve=t=>M(M(t*t)*t+CURVE.b),err=(t="")=>{throw new Error(t)},isB=t=>typeof t=="bigint",isS=t=>typeof t=="string",fe$1=t=>isB(t)&&0n<t&&t<P,ge$1=t=>isB(t)&&0n<t&&t<N,isu8=t=>t instanceof Uint8Array||ArrayBuffer.isView(t)&&t.constructor.name==="Uint8Array",au8=(t,e)=>!isu8(t)||typeof e=="number"&&e>0&&t.length!==e?err("Uint8Array expected"):t,u8n$1=t=>new Uint8Array(t),toU8=(t,e)=>au8(isS(t)?h2b$1(t):u8n$1(au8(t)),e),M=(t,e=P)=>{const n=t%e;return n>=0n?n:e+n},aPoint=t=>t instanceof Point$1?t:err("Point expected");let Point$1=class Ne{constructor(e,n,r){this.px=e,this.py=n,this.pz=r,Object.freeze(this)}static fromAffine(e){return e.x===0n&&e.y===0n?I:new Ne(e.x,e.y,1n)}static fromHex(e){e=toU8(e);let n;const r=e[0],s=e.subarray(1),o=slc(s,0,fLen),a=e.length;if(a===33&&[2,3].includes(r)){fe$1(o)||err("Point hex invalid: x not FE");let c=sqrt(curve(o));const l=(c&1n)===1n;(r&1)===1!==l&&(c=M(-c)),n=new Ne(o,c,1n)}return a===65&&r===4&&(n=new Ne(o,slc(s,fLen,2*fLen),1n)),n?n.ok():err("Point invalid: not on curve")}static fromPrivateKey(e){return G.mul(toPriv(e))}get x(){return this.aff().x}get y(){return this.aff().y}equals(e){const{px:n,py:r,pz:s}=this,{px:o,py:a,pz:c}=aPoint(e),l=M(n*c),u=M(o*s),h=M(r*c),f=M(a*s);return l===u&&h===f}negate(){return new Ne(this.px,M(-this.py),this.pz)}double(){return this.add(this)}add(e){const{px:n,py:r,pz:s}=this,{px:o,py:a,pz:c}=aPoint(e),{a:l,b:u}=CURVE;let h=0n,f=0n,p=0n;const g=M(u*3n);let w=M(n*o),y=M(r*a),b=M(s*c),x=M(n+r),_=M(o+a);x=M(x*_),_=M(w+y),x=M(x-_),_=M(n+s);let R=M(o+c);return _=M(_*R),R=M(w+b),_=M(_-R),R=M(r+s),h=M(a+c),R=M(R*h),h=M(y+b),R=M(R-h),p=M(l*_),h=M(g*b),p=M(h+p),h=M(y-p),p=M(y+p),f=M(h*p),y=M(w+w),y=M(y+w),b=M(l*b),_=M(g*_),y=M(y+b),b=M(w-b),b=M(l*b),_=M(_+b),w=M(y*_),f=M(f+w),w=M(R*_),h=M(x*h),h=M(h-w),w=M(x*y),p=M(R*p),p=M(p+w),new Ne(h,f,p)}mul(e,n=!0){if(!n&&e===0n)return I;if(ge$1(e)||err("scalar invalid"),this.equals(G))return wNAF$1(e).p;let r=I,s=G;for(let o=this;e>0n;o=o.double(),e>>=1n)e&1n?r=r.add(o):n&&(s=s.add(o));return r}mulAddQUns(e,n,r){return this.mul(n,!1).add(e.mul(r,!1)).ok()}toAffine(){const{px:e,py:n,pz:r}=this;if(this.equals(I))return{x:0n,y:0n};if(r===1n)return{x:e,y:n};const s=inv(r,P);return M(r*s)!==1n&&err("inverse invalid"),{x:M(e*s),y:M(n*s)}}assertValidity(){const{x:e,y:n}=this.aff();return(!fe$1(e)||!fe$1(n))&&err("Point invalid: x or y"),M(n*n)===curve(e)?this:err("Point invalid: not on curve")}multiply(e){return this.mul(e)}aff(){return this.toAffine()}ok(){return this.assertValidity()}toHex(e=!0){const{x:n,y:r}=this.aff();return(e?(r&1n)===0n?"02":"03":"04")+n2h(n)+(e?"":n2h(r))}toRawBytes(e=!0){return h2b$1(this.toHex(e))}};Point$1.BASE=new Point$1(Gx,Gy,1n);Point$1.ZERO=new Point$1(0n,1n,0n);const{BASE:G,ZERO:I}=Point$1,padh=(t,e)=>t.toString(16).padStart(e,"0"),b2h=t=>Array.from(au8(t)).map(e=>padh(e,2)).join(""),C={_0:48,_9:57,A:65,F:70,a:97,f:102},_ch=t=>{if(t>=C._0&&t<=C._9)return t-C._0;if(t>=C.A&&t<=C.F)return t-(C.A-10);if(t>=C.a&&t<=C.f)return t-(C.a-10)},h2b$1=t=>{const e="hex invalid";if(!isS(t))return err(e);const n=t.length,r=n/2;if(n%2)return err(e);const s=u8n$1(r);for(let o=0,a=0;o<r;o++,a+=2){const c=_ch(t.charCodeAt(a)),l=_ch(t.charCodeAt(a+1));if(c===void 0||l===void 0)return err(e);s[o]=c*16+l}return s},b2n$1=t=>BigInt("0x"+(b2h(t)||"0")),slc=(t,e,n)=>b2n$1(t.slice(e,n)),n2b=t=>isB(t)&&t>=0n&&t<B256?h2b$1(padh(t,2*fLen)):err("bigint expected"),n2h=t=>b2h(n2b(t)),inv=(t,e)=>{(t===0n||e<=0n)&&err("no inverse n="+t+" mod="+e);let n=M(t,e),r=e,s=0n,o=1n;for(;n!==0n;){const a=r/n,c=r%n,l=s-o*a;r=n,n=c,s=o,o=l}return r===1n?M(s,e):err("no inverse")},sqrt=t=>{let e=1n;for(let n=t,r=(P+1n)/4n;r>0n;r>>=1n)r&1n&&(e=e*n%P),n=n*n%P;return M(e*e)===t?e:err("sqrt invalid")},toPriv=t=>(isB(t)||(t=b2n$1(toU8(t,fLen))),ge$1(t)?t:err("private key invalid 3")),W=8,precompute=()=>{const t=[],e=256/W+1;let n=G,r=n;for(let s=0;s<e;s++){r=n,t.push(r);for(let o=1;o<2**(W-1);o++)r=r.add(n),t.push(r);n=r.double()}return t};let Gpows;const wNAF$1=t=>{const e=Gpows||(Gpows=precompute()),n=(h,f)=>{let p=f.negate();return h?p:f};let r=I,s=G;const o=1+256/W,a=2**(W-1),c=BigInt(2**W-1),l=2**W,u=BigInt(W);for(let h=0;h<o;h++){const f=h*a;let p=Number(t&c);t>>=u,p>a&&(p-=l,t+=1n);const g=f,w=f+Math.abs(p)-1,y=h%2!==0,b=p<0;p===0?s=s.add(n(y,e[g])):r=r.add(n(b,e[w]))}return{p:r,f:s}};function aggregateKeys(t,e,n={}){e&&(t=sortKeys(t));const{aggPublicKey:r}=keyAggregate(t);if(!n.taprootTweak)return{preTweakedKey:r.toRawBytes(!0),finalKey:r.toRawBytes(!0)};const s=schnorr$1.utils.taggedHash("TapTweak",r.toRawBytes(!0).subarray(1),n.taprootTweak??new Uint8Array(0)),{aggPublicKey:o}=keyAggregate(t,[s],[!0]);return{preTweakedKey:r.toRawBytes(!0),finalKey:o.toRawBytes(!0)}}class PartialSignatureError extends Error{constructor(e){super(e),this.name="PartialSignatureError"}}class PartialSig{constructor(e,n){if(this.s=e,this.R=n,e.length!==32)throw new PartialSignatureError("Invalid s length");if(n.length!==33)throw new PartialSignatureError("Invalid R length")}encode(){return new Uint8Array(this.s)}static decode(e){if(e.length!==32)throw new PartialSignatureError("Invalid partial signature length");if(bytesToNumberBE$1(e)>=CURVE.n)throw new PartialSignatureError("s value overflows curve order");const r=new Uint8Array(33);return new PartialSig(e,r)}}function sign(t,e,n,r,s,o){let a;if((o==null?void 0:o.taprootTweak)!==void 0){const{preTweakedKey:u}=aggregateKeys(o!=null&&o.sortKeys?sortKeys(r):r,!0);a=schnorr$1.utils.taggedHash("TapTweak",u.subarray(1),o.taprootTweak)}const l=new Session(n,o!=null&&o.sortKeys?sortKeys(r):r,s,a?[a]:void 0,a?[!0]:void 0).sign(t,e);return PartialSig.decode(l)}var commonjsGlobal=typeof globalThis<"u"?globalThis:typeof window<"u"?window:typeof global<"u"?global:typeof self<"u"?self:{};function getDefaultExportFromCjs(t){return t&&t.__esModule&&Object.prototype.hasOwnProperty.call(t,"default")?t.default:t}const SEQUENCE_FINAL=4294967295,SEQUENCE_LOCKTIME_DISABLE_FLAG=1<<31,SEQUENCE_LOCKTIME_GRANULARITY=9,SEQUENCE_LOCKTIME_MASK=65535,SEQUENCE_LOCKTIME_TYPE_FLAG=1<<22,BLOCKS_MAX=SEQUENCE_LOCKTIME_MASK,SECONDS_MOD=1<<SEQUENCE_LOCKTIME_GRANULARITY,SECONDS_MAX=SEQUENCE_LOCKTIME_MASK<<SEQUENCE_LOCKTIME_GRANULARITY;function decode$1(t){return t&SEQUENCE_LOCKTIME_DISABLE_FLAG?{}:t&SEQUENCE_LOCKTIME_TYPE_FLAG?{seconds:(t&SEQUENCE_LOCKTIME_MASK)<<SEQUENCE_LOCKTIME_GRANULARITY}:{blocks:t&SEQUENCE_LOCKTIME_MASK}}function encode$1({blocks:t,seconds:e}){if(t!==void 0&&e!==void 0)throw new TypeError("Cannot encode blocks AND seconds");if(t===void 0&&e===void 0)return SEQUENCE_FINAL;if(e!==void 0){if(!Number.isFinite(e))throw new TypeError("Expected Number seconds");if(e>SECONDS_MAX)throw new TypeError("Expected Number seconds <= "+SECONDS_MAX);if(e%SECONDS_MOD!==0)throw new TypeError("Expected Number seconds as a multiple of "+SECONDS_MOD);return SEQUENCE_LOCKTIME_TYPE_FLAG|e>>SEQUENCE_LOCKTIME_GRANULARITY}if(!Number.isFinite(t))throw new TypeError("Expected Number blocks");if(t>SEQUENCE_LOCKTIME_MASK)throw new TypeError("Expected Number blocks <= "+BLOCKS_MAX);return t}var bip68={decode:decode$1,encode:encode$1},ArkPsbtFieldKey;(function(t){t.VtxoTaprootTree="taptree",t.VtxoTreeExpiry="expiry",t.Cosigner="cosigner",t.ConditionWitness="condition"})(ArkPsbtFieldKey||(ArkPsbtFieldKey={}));const ArkPsbtFieldKeyType=255;function setArkPsbtField(t,e,n,r){var s;t.updateInput(e,{unknown:[...((s=t.getInput(e))==null?void 0:s.unknown)??[],n.encode(r)]})}function getArkPsbtFields(t,e,n){var o;const r=((o=t.getInput(e))==null?void 0:o.unknown)??[],s=[];for(const a of r){const c=n.decode(a);c&&s.push(c)}return s}const VtxoTaprootTree={key:ArkPsbtFieldKey.VtxoTaprootTree,encode:t=>[{type:ArkPsbtFieldKeyType,key:encodedPsbtFieldKey[ArkPsbtFieldKey.VtxoTaprootTree]},t],decode:t=>nullIfCatch(()=>checkKeyIncludes(t[0],ArkPsbtFieldKey.VtxoTaprootTree)?t[1]:null)};ArkPsbtFieldKey.ConditionWitness;const CosignerPublicKey={key:ArkPsbtFieldKey.Cosigner,encode:t=>[{type:ArkPsbtFieldKeyType,key:new Uint8Array([...encodedPsbtFieldKey[ArkPsbtFieldKey.Cosigner],t.index])},t.key],decode:t=>nullIfCatch(()=>checkKeyIncludes(t[0],ArkPsbtFieldKey.Cosigner)?{index:t[0].key[t[0].key.length-1],key:t[1]}:null)};ArkPsbtFieldKey.VtxoTreeExpiry;const encodedPsbtFieldKey=Object.fromEntries(Object.values(ArkPsbtFieldKey).map(t=>[t,new TextEncoder().encode(t)])),nullIfCatch=t=>{try{return t()}catch{return null}};function checkKeyIncludes(t,e){const n=hex$1.encode(encodedPsbtFieldKey[e]);return hex$1.encode(new Uint8Array([t.type,...t.key])).includes(n)}const ErrMissingVtxoGraph=new Error("missing vtxo graph");class TreeSignerSession{constructor(e){this.secretKey=e,this.myNonces=null,this.aggregateNonces=null,this.graph=null,this.scriptRoot=null,this.rootSharedOutputAmount=null}static random(){const e=randomPrivateKeyBytes();return new TreeSignerSession(e)}init(e,n,r){this.graph=e,this.scriptRoot=n,this.rootSharedOutputAmount=r}getPublicKey(){return secp256k1$1.getPublicKey(this.secretKey)}getNonces(){if(!this.graph)throw ErrMissingVtxoGraph;this.myNonces||(this.myNonces=this.generateNonces());const e=new Map;for(const[n,r]of this.myNonces)e.set(n,{pubNonce:r.pubNonce});return e}setAggregatedNonces(e){if(this.aggregateNonces)throw new Error("nonces already set");this.aggregateNonces=e}sign(){if(!this.graph)throw ErrMissingVtxoGraph;if(!this.aggregateNonces)throw new Error("nonces not set");if(!this.myNonces)throw new Error("nonces not generated");const e=new Map;for(const n of this.graph){const r=this.signPartial(n);e.set(n.txid,r)}return e}generateNonces(){if(!this.graph)throw ErrMissingVtxoGraph;const e=new Map,n=secp256k1$1.getPublicKey(this.secretKey);for(const r of this.graph){const s=generateNonces(n);e.set(r.txid,s)}return e}signPartial(e){if(!this.graph||!this.scriptRoot||!this.rootSharedOutputAmount)throw TreeSignerSession.NOT_INITIALIZED;if(!this.myNonces||!this.aggregateNonces)throw new Error("session not properly initialized");const n=this.myNonces.get(e.txid);if(!n)throw new Error("missing private nonce");const r=this.aggregateNonces.get(e.txid);if(!r)throw new Error("missing aggregate nonce");const s=[],o=[],a=getArkPsbtFields(e.root,0,CosignerPublicKey).map(u=>u.key),{finalKey:c}=aggregateKeys(a,!0,{taprootTweak:this.scriptRoot});for(let u=0;u<e.root.inputsLength;u++){const h=getPrevOutput(c,this.graph,this.rootSharedOutputAmount,e.root);s.push(h.amount),o.push(h.script)}const l=e.root.preimageWitnessV1(0,o,SigHash.DEFAULT,s);return sign(n.secNonce,this.secretKey,r.pubNonce,a,l,{taprootTweak:this.scriptRoot,sortKeys:!0})}}TreeSignerSession.NOT_INITIALIZED=new Error("session not initialized, call init method");function getPrevOutput(t,e,n,r){const s=Script.encode(["OP_1",t.slice(1)]);if(hex$1.encode(sha256x2(r.toBytes(!0)).reverse())===e.txid)return{amount:n,script:s};const a=r.getInput(0);if(!a.txid)throw new Error("missing parent input txid");const c=hex$1.encode(new Uint8Array(a.txid)),l=e.find(c);if(!l)throw new Error("parent  tx not found");if(a.index===void 0)throw new Error("missing input index");const u=l.root.getOutput(a.index);if(!u)throw new Error("parent output not found");if(!u.amount)throw new Error("parent output amount not found");return{amount:u.amount,script:s}}const ZERO_32$1=new Uint8Array(32).fill(0),ALL_SIGHASH=Object.values(SigHash).filter(t=>typeof t=="number");class SingleKey{constructor(e){this.key=e||randomPrivateKeyBytes()}static fromPrivateKey(e){return new SingleKey(e)}static fromHex(e){return new SingleKey(hex$1.decode(e))}async sign(e,n){const r=e.clone();if(!n){try{if(!r.sign(this.key,ALL_SIGHASH,ZERO_32$1))throw new Error("Failed to sign transaction")}catch(s){if(!(s instanceof Error&&s.message.includes("No inputs signed")))throw s}return r}for(const s of n)if(!r.signIdx(this.key,s,ALL_SIGHASH,ZERO_32$1))throw new Error(`Failed to sign input #${s}`);return r}xOnlyPublicKey(){return pubSchnorr(this.key)}signerSession(){return TreeSignerSession.random()}}class ArkAddress{constructor(e,n,r,s=0){if(this.serverPubKey=e,this.vtxoTaprootKey=n,this.hrp=r,this.version=s,e.length!==32)throw new Error("Invalid server public key length, expected 32 bytes, got "+e.length);if(n.length!==32)throw new Error("Invalid vtxo taproot public key length, expected 32 bytes, got "+n.length)}static decode(e){const n=bech32m.decodeUnsafe(e,1023);if(!n)throw new Error("Invalid address");const r=new Uint8Array(bech32m.fromWords(n.words));if(r.length!==1+32+32)throw new Error("Invalid data length, expected 65 bytes, got "+r.length);const s=r[0],o=r.slice(1,33),a=r.slice(33,65);return new ArkAddress(o,a,n.prefix,s)}encode(){const e=new Uint8Array(65);e[0]=this.version,e.set(this.serverPubKey,1),e.set(this.vtxoTaprootKey,33);const n=bech32m.toWords(e);return bech32m.encode(this.hrp,n,1023)}get pkScript(){return Script.encode(["OP_1",this.vtxoTaprootKey])}get subdustPkScript(){return Script.encode(["RETURN",this.vtxoTaprootKey])}}const MinimalScriptNum=ScriptNum(void 0,!0);var TapscriptType;(function(t){t.Multisig="multisig",t.CSVMultisig="csv-multisig",t.ConditionCSVMultisig="condition-csv-multisig",t.ConditionMultisig="condition-multisig",t.CLTVMultisig="cltv-multisig"})(TapscriptType||(TapscriptType={}));function decodeTapscript(t){const e=[MultisigTapscript,CSVMultisigTapscript,ConditionCSVMultisigTapscript,ConditionMultisigTapscript,CLTVMultisigTapscript];for(const n of e)try{return n.decode(t)}catch{continue}throw new Error(`Failed to decode: script ${hex$1.encode(t)} is not a valid tapscript`)}var MultisigTapscript;(function(t){let e;(function(c){c[c.CHECKSIG=0]="CHECKSIG",c[c.CHECKSIGADD=1]="CHECKSIGADD"})(e=t.MultisigType||(t.MultisigType={}));function n(c){if(c.pubkeys.length===0)throw new Error("At least 1 pubkey is required");for(const u of c.pubkeys)if(u.length!==32)throw new Error(`Invalid pubkey length: expected 32, got ${u.length}`);if(c.type||(c.type=e.CHECKSIG),c.type===e.CHECKSIGADD)return{type:TapscriptType.Multisig,params:c,script:p2tr_ms(c.pubkeys.length,c.pubkeys).script};const l=[];for(let u=0;u<c.pubkeys.length;u++)l.push(c.pubkeys[u]),u<c.pubkeys.length-1?l.push("CHECKSIGVERIFY"):l.push("CHECKSIG");return{type:TapscriptType.Multisig,params:c,script:Script.encode(l)}}t.encode=n;function r(c){if(c.length===0)throw new Error("Failed to decode: script is empty");try{return s(c)}catch{try{return o(c)}catch(u){throw new Error(`Failed to decode script: ${u instanceof Error?u.message:String(u)}`)}}}t.decode=r;function s(c){const l=Script.decode(c),u=[];let h=!1;for(let p=0;p<l.length;p++){const g=l[p];if(typeof g!="string"&&typeof g!="number"){if(g.length!==32)throw new Error(`Invalid pubkey length: expected 32, got ${g.length}`);if(u.push(g),p+1>=l.length||l[p+1]!=="CHECKSIGADD"&&l[p+1]!=="CHECKSIG")throw new Error("Expected CHECKSIGADD or CHECKSIG after pubkey");p++;continue}if(p===l.length-1){if(g!=="NUMEQUAL")throw new Error("Expected NUMEQUAL at end of script");h=!0}}if(!h)throw new Error("Missing NUMEQUAL operation");if(u.length===0)throw new Error("Invalid script: must have at least 1 pubkey");const f=n({pubkeys:u,type:e.CHECKSIGADD});if(hex$1.encode(f.script)!==hex$1.encode(c))throw new Error("Invalid script format: script reconstruction mismatch");return{type:TapscriptType.Multisig,params:{pubkeys:u,type:e.CHECKSIGADD},script:c}}function o(c){const l=Script.decode(c),u=[];for(let f=0;f<l.length;f++){const p=l[f];if(typeof p!="string"&&typeof p!="number"){if(p.length!==32)throw new Error(`Invalid pubkey length: expected 32, got ${p.length}`);if(u.push(p),f+1>=l.length)throw new Error("Unexpected end of script");const g=l[f+1];if(g!=="CHECKSIGVERIFY"&&g!=="CHECKSIG")throw new Error("Expected CHECKSIGVERIFY or CHECKSIG after pubkey");if(f===l.length-2&&g!=="CHECKSIG")throw new Error("Last operation must be CHECKSIG");f++;continue}}if(u.length===0)throw new Error("Invalid script: must have at least 1 pubkey");const h=n({pubkeys:u,type:e.CHECKSIG});if(hex$1.encode(h.script)!==hex$1.encode(c))throw new Error("Invalid script format: script reconstruction mismatch");return{type:TapscriptType.Multisig,params:{pubkeys:u,type:e.CHECKSIG},script:c}}function a(c){return c.type===TapscriptType.Multisig}t.is=a})(MultisigTapscript||(MultisigTapscript={}));var CSVMultisigTapscript;(function(t){function e(s){for(const u of s.pubkeys)if(u.length!==32)throw new Error(`Invalid pubkey length: expected 32, got ${u.length}`);const o=MinimalScriptNum.encode(BigInt(bip68.encode(s.timelock.type==="blocks"?{blocks:Number(s.timelock.value)}:{seconds:Number(s.timelock.value)}))),a=[o.length===1?o[0]:o,"CHECKSEQUENCEVERIFY","DROP"],c=MultisigTapscript.encode(s),l=new Uint8Array([...Script.encode(a),...c.script]);return{type:TapscriptType.CSVMultisig,params:s,script:l}}t.encode=e;function n(s){if(s.length===0)throw new Error("Failed to decode: script is empty");const o=Script.decode(s);if(o.length<3)throw new Error("Invalid script: too short (expected at least 3)");const a=o[0];if(typeof a=="string"||typeof a=="number")throw new Error("Invalid script: expected sequence number");if(o[1]!=="CHECKSEQUENCEVERIFY"||o[2]!=="DROP")throw new Error("Invalid script: expected CHECKSEQUENCEVERIFY DROP");const c=new Uint8Array(Script.encode(o.slice(3)));let l;try{l=MultisigTapscript.decode(c)}catch(g){throw new Error(`Invalid multisig script: ${g instanceof Error?g.message:String(g)}`)}const u=Number(MinimalScriptNum.decode(a)),h=bip68.decode(u),f=h.blocks!==void 0?{type:"blocks",value:BigInt(h.blocks)}:{type:"seconds",value:BigInt(h.seconds)},p=e({timelock:f,...l.params});if(hex$1.encode(p.script)!==hex$1.encode(s))throw new Error("Invalid script format: script reconstruction mismatch");return{type:TapscriptType.CSVMultisig,params:{timelock:f,...l.params},script:s}}t.decode=n;function r(s){return s.type===TapscriptType.CSVMultisig}t.is=r})(CSVMultisigTapscript||(CSVMultisigTapscript={}));var ConditionCSVMultisigTapscript;(function(t){function e(s){const o=new Uint8Array([...s.conditionScript,...Script.encode(["VERIFY"]),...CSVMultisigTapscript.encode(s).script]);return{type:TapscriptType.ConditionCSVMultisig,params:s,script:o}}t.encode=e;function n(s){if(s.length===0)throw new Error("Failed to decode: script is empty");const o=Script.decode(s);if(o.length<1)throw new Error("Invalid script: too short (expected at least 1)");let a=-1;for(let f=o.length-1;f>=0;f--)o[f]==="VERIFY"&&(a=f);if(a===-1)throw new Error("Invalid script: missing VERIFY operation");const c=new Uint8Array(Script.encode(o.slice(0,a))),l=new Uint8Array(Script.encode(o.slice(a+1)));let u;try{u=CSVMultisigTapscript.decode(l)}catch(f){throw new Error(`Invalid CSV multisig script: ${f instanceof Error?f.message:String(f)}`)}const h=e({conditionScript:c,...u.params});if(hex$1.encode(h.script)!==hex$1.encode(s))throw new Error("Invalid script format: script reconstruction mismatch");return{type:TapscriptType.ConditionCSVMultisig,params:{conditionScript:c,...u.params},script:s}}t.decode=n;function r(s){return s.type===TapscriptType.ConditionCSVMultisig}t.is=r})(ConditionCSVMultisigTapscript||(ConditionCSVMultisigTapscript={}));var ConditionMultisigTapscript;(function(t){function e(s){const o=new Uint8Array([...s.conditionScript,...Script.encode(["VERIFY"]),...MultisigTapscript.encode(s).script]);return{type:TapscriptType.ConditionMultisig,params:s,script:o}}t.encode=e;function n(s){if(s.length===0)throw new Error("Failed to decode: script is empty");const o=Script.decode(s);if(o.length<1)throw new Error("Invalid script: too short (expected at least 1)");let a=-1;for(let f=o.length-1;f>=0;f--)o[f]==="VERIFY"&&(a=f);if(a===-1)throw new Error("Invalid script: missing VERIFY operation");const c=new Uint8Array(Script.encode(o.slice(0,a))),l=new Uint8Array(Script.encode(o.slice(a+1)));let u;try{u=MultisigTapscript.decode(l)}catch(f){throw new Error(`Invalid multisig script: ${f instanceof Error?f.message:String(f)}`)}const h=e({conditionScript:c,...u.params});if(hex$1.encode(h.script)!==hex$1.encode(s))throw new Error("Invalid script format: script reconstruction mismatch");return{type:TapscriptType.ConditionMultisig,params:{conditionScript:c,...u.params},script:s}}t.decode=n;function r(s){return s.type===TapscriptType.ConditionMultisig}t.is=r})(ConditionMultisigTapscript||(ConditionMultisigTapscript={}));var CLTVMultisigTapscript;(function(t){function e(s){const o=MinimalScriptNum.encode(s.absoluteTimelock),a=[o.length===1?o[0]:o,"CHECKLOCKTIMEVERIFY","DROP"],c=Script.encode(a),l=new Uint8Array([...c,...MultisigTapscript.encode(s).script]);return{type:TapscriptType.CLTVMultisig,params:s,script:l}}t.encode=e;function n(s){if(s.length===0)throw new Error("Failed to decode: script is empty");const o=Script.decode(s);if(o.length<3)throw new Error("Invalid script: too short (expected at least 3)");const a=o[0];if(typeof a=="string"||typeof a=="number")throw new Error("Invalid script: expected locktime number");if(o[1]!=="CHECKLOCKTIMEVERIFY"||o[2]!=="DROP")throw new Error("Invalid script: expected CHECKLOCKTIMEVERIFY DROP");const c=new Uint8Array(Script.encode(o.slice(3)));let l;try{l=MultisigTapscript.decode(c)}catch(f){throw new Error(`Invalid multisig script: ${f instanceof Error?f.message:String(f)}`)}const u=MinimalScriptNum.decode(a),h=e({absoluteTimelock:u,...l.params});if(hex$1.encode(h.script)!==hex$1.encode(s))throw new Error("Invalid script format: script reconstruction mismatch");return{type:TapscriptType.CLTVMultisig,params:{absoluteTimelock:u,...l.params},script:s}}t.decode=n;function r(s){return s.type===TapscriptType.CLTVMultisig}t.is=r})(CLTVMultisigTapscript||(CLTVMultisigTapscript={}));function scriptFromTapLeafScript(t){return t[1].subarray(0,t[1].length-1)}class VtxoScript{static decode(e){const n=decodeTaprootTree(e);return new VtxoScript(n)}constructor(e){this.scripts=e;const n=taprootListToTree(e.map(s=>({script:s,leafVersion:TAP_LEAF_VERSION}))),r=p2tr(TAPROOT_UNSPENDABLE_KEY,n,void 0,!0);if(!r.tapLeafScript||r.tapLeafScript.length!==e.length)throw new Error("invalid scripts");this.leaves=r.tapLeafScript,this.tweakedPublicKey=r.tweakedPubkey}encode(){return encodeTaprootTree(this.scripts)}address(e,n){return new ArkAddress(n,this.tweakedPublicKey,e)}get pkScript(){return Script.encode(["OP_1",this.tweakedPublicKey])}onchainAddress(e){return Address(e).encode({type:"tr",pubkey:this.tweakedPublicKey})}findLeaf(e){const n=this.leaves.find(r=>hex$1.encode(scriptFromTapLeafScript(r))===e);if(!n)throw new Error(`leaf '${e}' not found`);return n}exitPaths(){const e=[];for(const n of this.leaves)try{const r=CSVMultisigTapscript.decode(scriptFromTapLeafScript(n));e.push(r);continue}catch{try{const s=ConditionCSVMultisigTapscript.decode(scriptFromTapLeafScript(n));e.push(s)}catch{continue}}return e}}function decodeTaprootTree(t){let e=0;const n=[],[r,s]=decodeCompactSizeUint(t,e);e+=s;for(let o=0;o<r;o++){e+=1,e+=1;const[a,c]=decodeCompactSizeUint(t,e);e+=c;const l=t.slice(e,e+a);n.push(l),e+=a}return n}function decodeCompactSizeUint(t,e){const n=t[e];return n<253?[n,1]:n===253?[new DataView(t.buffer).getUint16(e+1,!0),3]:n===254?[new DataView(t.buffer).getUint32(e+1,!0),5]:[Number(new DataView(t.buffer).getBigUint64(e+1,!0)),9]}function encodeTaprootTree(t){const e=[];e.push(encodeCompactSizeUint(t.length));for(const o of t)e.push(new Uint8Array([1])),e.push(new Uint8Array([192])),e.push(encodeCompactSizeUint(o.length)),e.push(o);const n=e.reduce((o,a)=>o+a.length,0),r=new Uint8Array(n);let s=0;for(const o of e)r.set(o,s),s+=o.length;return r}function encodeCompactSizeUint(t){if(t<253)return new Uint8Array([t]);if(t<=65535){const e=new Uint8Array(3);return e[0]=253,new DataView(e.buffer).setUint16(1,t,!0),e}else if(t<=4294967295){const e=new Uint8Array(5);return e[0]=254,new DataView(e.buffer).setUint32(1,t,!0),e}else{const e=new Uint8Array(9);return e[0]=255,new DataView(e.buffer).setBigUint64(1,BigInt(t),!0),e}}var VHTLC;(function(t){class e extends VtxoScript{constructor(s){n(s);const{sender:o,receiver:a,server:c,preimageHash:l,refundLocktime:u,unilateralClaimDelay:h,unilateralRefundDelay:f,unilateralRefundWithoutReceiverDelay:p}=s,g=preimageConditionScript(l),w=ConditionMultisigTapscript.encode({conditionScript:g,pubkeys:[a,c]}).script,y=MultisigTapscript.encode({pubkeys:[o,a,c]}).script,b=CLTVMultisigTapscript.encode({absoluteTimelock:u,pubkeys:[o,c]}).script,x=ConditionCSVMultisigTapscript.encode({conditionScript:g,timelock:h,pubkeys:[a]}).script,_=CSVMultisigTapscript.encode({timelock:f,pubkeys:[o,a]}).script,R=CSVMultisigTapscript.encode({timelock:p,pubkeys:[o]}).script;super([w,y,b,x,_,R]),this.options=s,this.claimScript=hex$1.encode(w),this.refundScript=hex$1.encode(y),this.refundWithoutReceiverScript=hex$1.encode(b),this.unilateralClaimScript=hex$1.encode(x),this.unilateralRefundScript=hex$1.encode(_),this.unilateralRefundWithoutReceiverScript=hex$1.encode(R)}claim(){return this.findLeaf(this.claimScript)}refund(){return this.findLeaf(this.refundScript)}refundWithoutReceiver(){return this.findLeaf(this.refundWithoutReceiverScript)}unilateralClaim(){return this.findLeaf(this.unilateralClaimScript)}unilateralRefund(){return this.findLeaf(this.unilateralRefundScript)}unilateralRefundWithoutReceiver(){return this.findLeaf(this.unilateralRefundWithoutReceiverScript)}}t.Script=e;function n(r){const{sender:s,receiver:o,server:a,preimageHash:c,refundLocktime:l,unilateralClaimDelay:u,unilateralRefundDelay:h,unilateralRefundWithoutReceiverDelay:f}=r;if(!c||c.length!==20)throw new Error("preimage hash must be 20 bytes");if(!o||o.length!==32)throw new Error("Invalid public key length (receiver)");if(!s||s.length!==32)throw new Error("Invalid public key length (sender)");if(!a||a.length!==32)throw new Error("Invalid public key length (server)");if(typeof l!="bigint"||l<=0n)throw new Error("refund locktime must be greater than 0");if(!u||typeof u.value!="bigint"||u.value<=0n)throw new Error("unilateral claim delay must greater than 0");if(u.type==="seconds"&&u.value%512n!==0n)throw new Error("seconds timelock must be multiple of 512");if(u.type==="seconds"&&u.value<512n)throw new Error("seconds timelock must be greater or equal to 512");if(!h||typeof h.value!="bigint"||h.value<=0n)throw new Error("unilateral refund delay must greater than 0");if(h.type==="seconds"&&h.value%512n!==0n)throw new Error("seconds timelock must be multiple of 512");if(h.type==="seconds"&&h.value<512n)throw new Error("seconds timelock must be greater or equal to 512");if(!f||typeof f.value!="bigint"||f.value<=0n)throw new Error("unilateral refund without receiver delay must greater than 0");if(f.type==="seconds"&&f.value%512n!==0n)throw new Error("seconds timelock must be multiple of 512");if(f.type==="seconds"&&f.value<512n)throw new Error("seconds timelock must be greater or equal to 512")}})(VHTLC||(VHTLC={}));function preimageConditionScript(t){return Script.encode(["HASH160",t,"EQUAL"])}var DefaultVtxo;(function(t){class e extends VtxoScript{constructor(r){const{pubKey:s,serverPubKey:o,csvTimelock:a=e.DEFAULT_TIMELOCK}=r,c=MultisigTapscript.encode({pubkeys:[s,o]}).script,l=CSVMultisigTapscript.encode({timelock:a,pubkeys:[s]}).script;super([c,l]),this.options=r,this.forfeitScript=hex$1.encode(c),this.exitScript=hex$1.encode(l)}forfeit(){return this.findLeaf(this.forfeitScript)}exit(){return this.findLeaf(this.exitScript)}}e.DEFAULT_TIMELOCK={value:144n,type:"blocks"},t.Script=e})(DefaultVtxo||(DefaultVtxo={}));var TxType;(function(t){t.TxSent="SENT",t.TxReceived="RECEIVED"})(TxType||(TxType={}));function isSpendable(t){return t.spentBy===void 0||t.spentBy===""}function isRecoverable(t){return t.virtualStatus.state==="swept"&&isSpendable(t)}function isSubdust(t,e){return t.value<e}function vtxosToTxs(t,e,n){var a;const r=[];let s=[...e];for(const c of[...t,...e]){if(c.virtualStatus.state!=="preconfirmed"&&c.virtualStatus.commitmentTxIds&&c.virtualStatus.commitmentTxIds.some(w=>n.has(w)))continue;const l=findVtxosSpentInSettlement(s,c);s=removeVtxosFromList(s,l);const u=reduceVtxosAmount(l);if(c.value<=u)continue;const h=findVtxosSpentInPayment(s,c);s=removeVtxosFromList(s,h);const f=reduceVtxosAmount(h);if(c.value<=f)continue;const p={commitmentTxid:c.spentBy||"",boardingTxid:"",arkTxid:""};let g=c.virtualStatus.state!=="preconfirmed";c.virtualStatus.state==="preconfirmed"&&(p.arkTxid=c.txid,c.spentBy&&(g=!0)),r.push({key:p,amount:c.value-u-f,type:TxType.TxReceived,createdAt:c.createdAt.getTime(),settled:g})}const o=new Map;for(const c of e){if(c.settledBy){o.has(c.settledBy)||o.set(c.settledBy,[]);const u=o.get(c.settledBy);o.set(c.settledBy,[...u,c])}if(!c.arkTxId)continue;o.has(c.arkTxId)||o.set(c.arkTxId,[]);const l=o.get(c.arkTxId);o.set(c.arkTxId,[...l,c])}for(const[c,l]of o){const u=findVtxosResultedFromTxid([...t,...e],c),h=reduceVtxosAmount(u),f=reduceVtxosAmount(l);if(f<=h)continue;const p=getVtxo(u,l),g={commitmentTxid:((a=p.virtualStatus.commitmentTxIds)==null?void 0:a[0])||"",boardingTxid:"",arkTxid:""};p.virtualStatus.state==="preconfirmed"&&(g.arkTxid=p.txid),r.push({key:g,amount:f-h,type:TxType.TxSent,createdAt:p.createdAt.getTime(),settled:!0})}return r}function findVtxosSpentInSettlement(t,e){return e.virtualStatus.state==="preconfirmed"?[]:t.filter(n=>{var r;return n.settledBy?((r=e.virtualStatus.commitmentTxIds)==null?void 0:r.includes(n.settledBy))??!1:!1})}function findVtxosSpentInPayment(t,e){return t.filter(n=>n.arkTxId?n.arkTxId===e.txid:!1)}function findVtxosResultedFromTxid(t,e){return t.filter(n=>{var r;return n.virtualStatus.state!=="preconfirmed"&&((r=n.virtualStatus.commitmentTxIds)!=null&&r.includes(e))?!0:n.txid===e})}function reduceVtxosAmount(t){return t.reduce((e,n)=>e+n.value,0)}function getVtxo(t,e){return t.length===0?e[0]:t[0]}function removeVtxosFromList(t,e){return t.filter(n=>{for(const r of e)if(n.txid===r.txid&&n.vout===r.vout)return!1;return!0})}const getNetwork=t=>networks[t],networks={bitcoin:withArkPrefix(NETWORK,"ark"),testnet:withArkPrefix(TEST_NETWORK,"tark"),signet:withArkPrefix(TEST_NETWORK,"tark"),mutinynet:withArkPrefix(TEST_NETWORK,"tark"),regtest:withArkPrefix({...TEST_NETWORK,bech32:"bcrt",pubKeyHash:111,scriptHash:196},"tark")};function withArkPrefix(t,e){return{...t,hrp:e}}const ESPLORA_URL={bitcoin:"https://mempool.space/api",testnet:"https://mempool.space/testnet/api",signet:"https://mempool.space/signet/api",mutinynet:"https://mutinynet.com/api",regtest:"http://localhost:3000"};class EsploraProvider{constructor(e){this.baseUrl=e}async getCoins(e){const n=await fetch(`${this.baseUrl}/address/${e}/utxo`);if(!n.ok)throw new Error(`Failed to fetch UTXOs: ${n.statusText}`);return n.json()}async getFeeRate(){const e=await fetch(`${this.baseUrl}/fee-estimates`);if(!e.ok)throw new Error(`Failed to fetch fee rate: ${e.statusText}`);return(await e.json())[1]??void 0}async broadcastTransaction(...e){switch(e.length){case 1:return this.broadcastTx(e[0]);case 2:return this.broadcastPackage(e[0],e[1]);default:throw new Error("Only 1 or 1C1P package can be broadcast")}}async getTxOutspends(e){const n=await fetch(`${this.baseUrl}/tx/${e}/outspends`);if(!n.ok){const r=await n.text();throw new Error(`Failed to get transaction outspends: ${r}`)}return n.json()}async getTransactions(e){const n=await fetch(`${this.baseUrl}/address/${e}/txs`);if(!n.ok){const r=await n.text();throw new Error(`Failed to get transactions: ${r}`)}return n.json()}async getTxStatus(e){const n=await fetch(`${this.baseUrl}/tx/${e}`);if(!n.ok)throw new Error(n.statusText);if(!(await n.json()).status.confirmed)return{confirmed:!1};const s=await fetch(`${this.baseUrl}/tx/${e}/status`);if(!s.ok)throw new Error(`Failed to get transaction status: ${s.statusText}`);const o=await s.json();return o.confirmed?{confirmed:o.confirmed,blockTime:o.block_time,blockHeight:o.block_height}:{confirmed:!1}}async watchAddresses(e,n){let r=null;const s=this.baseUrl.replace(/^http(s)?:/,"ws$1:")+"/v1/ws",o=async()=>{const u=()=>Promise.all(e.map(p=>this.getTransactions(p))).then(p=>p.flat()),h=await u(),f=p=>`${p.txid}_${p.status.block_time}`;r=setInterval(async()=>{try{const p=await u(),g=new Set(h.map(f)),w=p.filter(y=>!g.has(f(y)));w.length>0&&(h.push(...w),n(w))}catch(p){console.error("Error in polling mechanism:",p)}},5e3)};let a=null;try{a=new WebSocket(s),a.addEventListener("open",()=>{const l={"track-addresses":e};a.send(JSON.stringify(l))}),a.addEventListener("message",l=>{try{const u=[],h=JSON.parse(l.data.toString());if(!h["multi-address-transactions"])return;const f=h["multi-address-transactions"];for(const p in f)for(const g of["mempool","confirmed","removed"])f[p][g]&&u.push(...f[p][g].filter(isExplorerTransaction));u.length>0&&n(u)}catch(u){console.error("Failed to process WebSocket message:",u)}}),a.addEventListener("error",async()=>{await o()})}catch{r&&clearInterval(r),await o()}return()=>{a&&a.readyState===WebSocket.OPEN&&a.close(),r&&clearInterval(r)}}async getChainTip(){const e=await fetch(`${this.baseUrl}/blocks/tip`);if(!e.ok)throw new Error(`Failed to get chain tip: ${e.statusText}`);const n=await e.json();if(!isValidBlocksTip(n))throw new Error(`Invalid chain tip: ${JSON.stringify(n)}`);if(n.length===0)throw new Error("No chain tip found");const r=n[0].id;return{height:n[0].height,time:n[0].mediantime,hash:r}}async broadcastPackage(e,n){const r=await fetch(`${this.baseUrl}/txs/package`,{method:"POST",headers:{"Content-Type":"application/json"},body:JSON.stringify([e,n])});if(!r.ok){const s=await r.text();throw new Error(`Failed to broadcast package: ${s}`)}return r.json()}async broadcastTx(e){const n=await fetch(`${this.baseUrl}/tx`,{method:"POST",headers:{"Content-Type":"text/plain"},body:e});if(!n.ok){const r=await n.text();throw new Error(`Failed to broadcast transaction: ${r}`)}return n.text()}}function isValidBlocksTip(t){return Array.isArray(t)&&t.every(e=>{e&&typeof e=="object"&&typeof e.id=="string"&&e.id.length>0&&typeof e.height=="number"&&e.height>=0&&typeof e.mediantime=="number"&&e.mediantime>0})}const isExplorerTransaction=t=>typeof t.txid=="string"&&Array.isArray(t.vout)&&t.vout.every(e=>typeof e.scriptpubkey_address=="string"&&typeof e.value=="string")&&typeof t.status=="object"&&typeof t.status.confirmed=="boolean"&&typeof t.status.block_time=="number";var SettlementEventType;(function(t){t.BatchStarted="batch_started",t.BatchFinalization="batch_finalization",t.BatchFinalized="batch_finalized",t.BatchFailed="batch_failed",t.TreeSigningStarted="tree_signing_started",t.TreeNoncesAggregated="tree_nonces_aggregated",t.TreeTx="tree_tx",t.TreeSignature="tree_signature"})(SettlementEventType||(SettlementEventType={}));class RestArkProvider{constructor(e){this.serverUrl=e}async getInfo(){const e=`${this.serverUrl}/v1/info`,n=await fetch(e);if(!n.ok)throw new Error(`Failed to get server info: ${n.statusText}`);const r=await n.json();return{...r,vtxoTreeExpiry:BigInt(r.vtxoTreeExpiry??0),unilateralExitDelay:BigInt(r.unilateralExitDelay??0),roundInterval:BigInt(r.roundInterval??0),dust:BigInt(r.dust??0),utxoMinAmount:BigInt(r.utxoMinAmount??0),utxoMaxAmount:BigInt(r.utxoMaxAmount??-1),vtxoMinAmount:BigInt(r.vtxoMinAmount??0),vtxoMaxAmount:BigInt(r.vtxoMaxAmount??-1),boardingExitDelay:BigInt(r.boardingExitDelay??0),marketHour:"marketHour"in r&&r.marketHour!=null?{nextStartTime:BigInt(r.marketHour.nextStartTime??0),nextEndTime:BigInt(r.marketHour.nextEndTime??0),period:BigInt(r.marketHour.period??0),roundInterval:BigInt(r.marketHour.roundInterval??0)}:void 0}}async submitTx(e,n){const r=`${this.serverUrl}/v1/tx/submit`,s=await fetch(r,{method:"POST",headers:{"Content-Type":"application/json"},body:JSON.stringify({signedArkTx:e,checkpointTxs:n})});if(!s.ok){const a=await s.text();try{const c=JSON.parse(a);throw new Error(`Failed to submit virtual transaction: ${c.message||c.error||a}`)}catch{throw new Error(`Failed to submit virtual transaction: ${a}`)}}const o=await s.json();return{arkTxid:o.arkTxid,finalArkTx:o.finalArkTx,signedCheckpointTxs:o.signedCheckpointTxs}}async finalizeTx(e,n){const r=`${this.serverUrl}/v1/tx/finalize`,s=await fetch(r,{method:"POST",headers:{"Content-Type":"application/json"},body:JSON.stringify({arkTxid:e,finalCheckpointTxs:n})});if(!s.ok){const o=await s.text();throw new Error(`Failed to finalize offchain transaction: ${o}`)}}async registerIntent(e){const n=`${this.serverUrl}/v1/batch/registerIntent`,r=await fetch(n,{method:"POST",headers:{"Content-Type":"application/json"},body:JSON.stringify({intent:{signature:e.signature,message:e.message}})});if(!r.ok){const o=await r.text();throw new Error(`Failed to register intent: ${o}`)}return(await r.json()).intentId}async deleteIntent(e){const n=`${this.serverUrl}/v1/batch/deleteIntent`,r=await fetch(n,{method:"POST",headers:{"Content-Type":"application/json"},body:JSON.stringify({proof:{signature:e.signature,message:e.message}})});if(!r.ok){const s=await r.text();throw new Error(`Failed to delete intent: ${s}`)}}async confirmRegistration(e){const n=`${this.serverUrl}/v1/batch/ack`,r=await fetch(n,{method:"POST",headers:{"Content-Type":"application/json"},body:JSON.stringify({intentId:e})});if(!r.ok){const s=await r.text();throw new Error(`Failed to confirm registration: ${s}`)}}async submitTreeNonces(e,n,r){const s=`${this.serverUrl}/v1/batch/tree/submitNonces`,o=await fetch(s,{method:"POST",headers:{"Content-Type":"application/json"},body:JSON.stringify({batchId:e,pubkey:n,treeNonces:encodeMusig2Nonces(r)})});if(!o.ok){const a=await o.text();throw new Error(`Failed to submit tree nonces: ${a}`)}}async submitTreeSignatures(e,n,r){const s=`${this.serverUrl}/v1/batch/tree/submitSignatures`,o=await fetch(s,{method:"POST",headers:{"Content-Type":"application/json"},body:JSON.stringify({batchId:e,pubkey:n,treeSignatures:encodeMusig2Signatures(r)})});if(!o.ok){const a=await o.text();throw new Error(`Failed to submit tree signatures: ${a}`)}}async submitSignedForfeitTxs(e,n){const r=`${this.serverUrl}/v1/batch/submitForfeitTxs`,s=await fetch(r,{method:"POST",headers:{"Content-Type":"application/json"},body:JSON.stringify({signedForfeitTxs:e,signedCommitmentTx:n})});if(!s.ok)throw new Error(`Failed to submit forfeit transactions: ${s.statusText}`)}async*getEventStream(e,n){const r=`${this.serverUrl}/v1/batch/events`,s=n.length>0?`?${n.map(o=>`topics=${encodeURIComponent(o)}`).join("&")}`:"";for(;!(e!=null&&e.aborted);)try{const o=await fetch(r+s,{headers:{Accept:"application/json"},signal:e});if(!o.ok)throw new Error(`Unexpected status ${o.status} when fetching event stream`);if(!o.body)throw new Error("Response body is null");const a=o.body.getReader(),c=new TextDecoder;let l="";for(;!(e!=null&&e.aborted);){const{done:u,value:h}=await a.read();if(u)break;l+=c.decode(h,{stream:!0});const f=l.split(`
`);for(let p=0;p<f.length-1;p++){const g=f[p].trim();if(g)try{const w=JSON.parse(g),y=this.parseSettlementEvent(w.result);y&&(yield y)}catch(w){throw console.error("Failed to parse event:",w),w}}l=f[f.length-1]}}catch(o){if(o instanceof Error&&o.name==="AbortError")break;if(isFetchTimeoutError(o)){console.debug("Timeout error ignored");continue}throw console.error("Event stream error:",o),o}}async*getTransactionsStream(e){const n=`${this.serverUrl}/v1/txs`;for(;!(e!=null&&e.aborted);)try{const r=await fetch(n,{headers:{Accept:"application/json"},signal:e});if(!r.ok)throw new Error(`Unexpected status ${r.status} when fetching transaction stream`);if(!r.body)throw new Error("Response body is null");const s=r.body.getReader(),o=new TextDecoder;let a="";for(;!(e!=null&&e.aborted);){const{done:c,value:l}=await s.read();if(c)break;a+=o.decode(l,{stream:!0});const u=a.split(`
`);for(let h=0;h<u.length-1;h++){const f=u[h].trim();if(!f)continue;const p=JSON.parse(f),g=this.parseTransactionNotification(p.result);g&&(yield g)}a=u[u.length-1]}}catch(r){if(r instanceof Error&&r.name==="AbortError")break;if(isFetchTimeoutError(r)){console.debug("Timeout error ignored");continue}throw console.error("Address subscription error:",r),r}}parseSettlementEvent(e){if(e.batchStarted)return{type:SettlementEventType.BatchStarted,id:e.batchStarted.id,intentIdHashes:e.batchStarted.intentIdHashes,batchExpiry:BigInt(e.batchStarted.batchExpiry)};if(e.batchFinalization)return{type:SettlementEventType.BatchFinalization,id:e.batchFinalization.id,commitmentTx:e.batchFinalization.commitmentTx};if(e.batchFinalized)return{type:SettlementEventType.BatchFinalized,id:e.batchFinalized.id,commitmentTxid:e.batchFinalized.commitmentTxid};if(e.batchFailed)return{type:SettlementEventType.BatchFailed,id:e.batchFailed.id,reason:e.batchFailed.reason};if(e.treeSigningStarted)return{type:SettlementEventType.TreeSigningStarted,id:e.treeSigningStarted.id,cosignersPublicKeys:e.treeSigningStarted.cosignersPubkeys,unsignedCommitmentTx:e.treeSigningStarted.unsignedCommitmentTx};if(e.treeNoncesAggregated)return{type:SettlementEventType.TreeNoncesAggregated,id:e.treeNoncesAggregated.id,treeNonces:decodeMusig2Nonces(e.treeNoncesAggregated.treeNonces)};if(e.treeTx){const n=Object.fromEntries(Object.entries(e.treeTx.children).map(([r,s])=>[parseInt(r),s]));return{type:SettlementEventType.TreeTx,id:e.treeTx.id,topic:e.treeTx.topic,batchIndex:e.treeTx.batchIndex,chunk:{txid:e.treeTx.txid,tx:e.treeTx.tx,children:n}}}return e.treeSignature?{type:SettlementEventType.TreeSignature,id:e.treeSignature.id,topic:e.treeSignature.topic,batchIndex:e.treeSignature.batchIndex,txid:e.treeSignature.txid,signature:e.treeSignature.signature}:(console.warn("Unknown event type:",e),null)}parseTransactionNotification(e){return e.commitmentTx?{commitmentTx:{txid:e.commitmentTx.txid,tx:e.commitmentTx.tx,spentVtxos:e.commitmentTx.spentVtxos.map(mapVtxo),spendableVtxos:e.commitmentTx.spendableVtxos.map(mapVtxo),checkpointTxs:e.commitmentTx.checkpointTxs}}:e.arkTx?{arkTx:{txid:e.arkTx.txid,tx:e.arkTx.tx,spentVtxos:e.arkTx.spentVtxos.map(mapVtxo),spendableVtxos:e.arkTx.spendableVtxos.map(mapVtxo),checkpointTxs:e.arkTx.checkpointTxs}}:(console.warn("Unknown transaction notification type:",e),null)}}function encodeMusig2Nonces(t){const e={};for(const[n,r]of t)e[n]=hex$1.encode(r.pubNonce);return JSON.stringify(e)}function encodeMusig2Signatures(t){const e={};for(const[n,r]of t)e[n]=hex$1.encode(r.encode());return JSON.stringify(e)}function decodeMusig2Nonces(t){const e=JSON.parse(t);return new Map(Object.entries(e).map(([n,r])=>{if(typeof r!="string")throw new Error("invalid nonce");return[n,{pubNonce:hex$1.decode(r)}]}))}function isFetchTimeoutError(t){const e=n=>n instanceof Error?n.name==="TypeError"&&n.message==="Failed to fetch"||n.name==="HeadersTimeoutError"||n.name==="BodyTimeoutError"||n.code==="UND_ERR_HEADERS_TIMEOUT"||n.code==="UND_ERR_BODY_TIMEOUT":!1;return e(t)||e(t.cause)}function mapVtxo(t){return{outpoint:{txid:t.outpoint.txid,vout:t.outpoint.vout},amount:t.amount,script:t.script,createdAt:t.createdAt,expiresAt:t.expiresAt,commitmentTxids:t.commitmentTxids,isPreconfirmed:t.isPreconfirmed,isSwept:t.isSwept,isUnrolled:t.isUnrolled,isSpent:t.isSpent,spentBy:t.spentBy,settledBy:t.settledBy,arkTxid:t.arkTxid}}const ANCHOR_VALUE=0n,ANCHOR_PKSCRIPT=new Uint8Array([81,2,78,115]),P2A={script:ANCHOR_PKSCRIPT,amount:ANCHOR_VALUE};hex$1.encode(P2A.script);function buildForfeitTx(t,e,n){const r=new Transaction({version:3,lockTime:n});let s=0n;for(const o of t){if(!o.witnessUtxo)throw new Error("input needs witness utxo");s+=o.witnessUtxo.amount,r.addInput(o)}return r.addOutput({script:e,amount:s}),r.addOutput(P2A),r}const ErrInvalidSettlementTxOutputs=new Error("invalid settlement transaction outputs"),ErrEmptyTree=new Error("empty tree"),ErrNumberOfInputs=new Error("invalid number of inputs"),ErrWrongSettlementTxid=new Error("wrong settlement txid"),ErrInvalidAmount=new Error("invalid amount"),ErrNoLeaves=new Error("no leaves"),ErrInvalidTaprootScript=new Error("invalid taproot script"),ErrInvalidRoundTxOutputs=new Error("invalid round transaction outputs"),ErrWrongCommitmentTxid=new Error("wrong commitment txid"),ErrMissingCosignersPublicKeys=new Error("missing cosigners public keys"),BATCH_OUTPUT_VTXO_INDEX=0,BATCH_OUTPUT_CONNECTORS_INDEX=1;function validateConnectorsTxGraph(t,e){if(e.validate(),e.root.inputsLength!==1)throw ErrNumberOfInputs;const n=e.root.getInput(0),r=Transaction.fromPSBT(base64$1.decode(t));if(r.outputsLength<=BATCH_OUTPUT_CONNECTORS_INDEX)throw ErrInvalidSettlementTxOutputs;const s=hex$1.encode(sha256x2(r.toBytes(!0)).reverse());if(!n.txid||hex$1.encode(n.txid)!==s||n.index!==BATCH_OUTPUT_CONNECTORS_INDEX)throw ErrWrongSettlementTxid}function validateVtxoTxGraph(t,e,n){var l;if(e.outputsLength<BATCH_OUTPUT_VTXO_INDEX+1)throw ErrInvalidRoundTxOutputs;const r=(l=e.getOutput(BATCH_OUTPUT_VTXO_INDEX))==null?void 0:l.amount;if(!r)throw ErrInvalidRoundTxOutputs;if(!t.root)throw ErrEmptyTree;const s=t.root.getInput(0),o=hex$1.encode(sha256x2(e.toBytes(!0)).reverse());if(!s.txid||hex$1.encode(s.txid)!==o||s.index!==BATCH_OUTPUT_VTXO_INDEX)throw ErrWrongCommitmentTxid;let a=0n;for(let u=0;u<t.root.outputsLength;u++){const h=t.root.getOutput(u);h!=null&&h.amount&&(a+=h.amount)}if(a!==r)throw ErrInvalidAmount;if(t.leaves().length===0)throw ErrNoLeaves;t.validate();for(const u of t)for(const[h,f]of u.children){const p=u.root.getOutput(h);if(!(p!=null&&p.script))throw new Error(`parent output ${h} not found`);const g=p.script.slice(2);if(g.length!==32)throw new Error(`parent output ${h} has invalid script`);const w=getArkPsbtFields(f.root,0,CosignerPublicKey);if(w.length===0)throw ErrMissingCosignersPublicKeys;const y=w.map(x=>x.key),{finalKey:b}=aggregateKeys(y,!0,{taprootTweak:n});if(!b||hex$1.encode(b.slice(1))!==hex$1.encode(g))throw ErrInvalidTaprootScript}}function buildOffchainTx(t,e,n){const r=t.map(o=>buildCheckpointTx(o,n));return{arkTx:buildVirtualTx(r.map(o=>o.input),e),checkpoints:r.map(o=>o.tx)}}function buildVirtualTx(t,e){let n=0n;for(const s of t){const o=decodeTapscript(scriptFromTapLeafScript(s.tapLeafScript));if(CLTVMultisigTapscript.is(o)){if(n!==0n&&isSeconds(n)!==isSeconds(o.params.absoluteTimelock))throw new Error("cannot mix seconds and blocks locktime");o.params.absoluteTimelock>n&&(n=o.params.absoluteTimelock)}}const r=new Transaction({version:3,allowUnknown:!0,allowUnknownOutputs:!0,lockTime:Number(n)});for(const[s,o]of t.entries())r.addInput({txid:o.txid,index:o.vout,sequence:n?DEFAULT_SEQUENCE-1:void 0,witnessUtxo:{script:VtxoScript.decode(o.tapTree).pkScript,amount:BigInt(o.value)},tapLeafScript:[o.tapLeafScript]}),setArkPsbtField(r,s,VtxoTaprootTree,o.tapTree);for(const s of e)r.addOutput(s);return r.addOutput(P2A),r}function buildCheckpointTx(t,e){const n=decodeTapscript(t.checkpointTapLeafScript??scriptFromTapLeafScript(t.tapLeafScript)),r=new VtxoScript([e.script,n.script]),s=buildVirtualTx([t],[{amount:BigInt(t.value),script:r.pkScript}]),o=r.findLeaf(hex$1.encode(n.script)),a={txid:hex$1.encode(sha256x2(s.toBytes(!0)).reverse()),vout:0,value:t.value,tapLeafScript:o,tapTree:r.encode()};return{tx:s,input:a}}const nLocktimeMinSeconds=500000000n;function isSeconds(t){return t>=nLocktimeMinSeconds}class ArkNote{constructor(e,n,r=ArkNote.DefaultHRP){this.preimage=e,this.value=n,this.HRP=r,this.vout=0;const s=sha256$3(this.preimage);this.vtxoScript=new VtxoScript([noteTapscript(s)]);const o=this.vtxoScript.leaves[0];this.txid=hex$1.encode(new Uint8Array(s).reverse()),this.tapTree=this.vtxoScript.encode(),this.forfeitTapLeafScript=o,this.intentTapLeafScript=o,this.value=n,this.status={confirmed:!0},this.extraWitness=[this.preimage]}encode(){const e=new Uint8Array(ArkNote.Length);return e.set(this.preimage,0),writeUInt32BE(e,this.value,this.preimage.length),e}static decode(e,n=ArkNote.DefaultHRP){if(e.length!==ArkNote.Length)throw new Error(`invalid data length: expected ${ArkNote.Length} bytes, got ${e.length}`);const r=e.subarray(0,ArkNote.PreimageLength),s=readUInt32BE(e,ArkNote.PreimageLength);return new ArkNote(r,s,n)}static fromString(e,n=ArkNote.DefaultHRP){if(e=e.trim(),!e.startsWith(n))throw new Error(`invalid human-readable part: expected ${n} prefix (note '${e}')`);const r=e.slice(n.length),s=base58$1.decode(r);if(s.length===0)throw new Error("failed to decode base58 string");return ArkNote.decode(s,n)}toString(){return this.HRP+base58$1.encode(this.encode())}}ArkNote.DefaultHRP="arknote";ArkNote.PreimageLength=32;ArkNote.ValueLength=4;ArkNote.Length=ArkNote.PreimageLength+ArkNote.ValueLength;ArkNote.FakeOutpointIndex=0;function writeUInt32BE(t,e,n){new DataView(t.buffer,t.byteOffset+n,4).setUint32(0,e,!1)}function readUInt32BE(t,e){return new DataView(t.buffer,t.byteOffset+e,4).getUint32(0,!1)}function noteTapscript(t){return Script.encode(["SHA256",t,"EQUAL"])}class BIP322Error extends Error{constructor(e){super(e),this.name="BIP322Error"}}const ErrMissingInputs=new BIP322Error("missing inputs"),ErrMissingData=new BIP322Error("missing data"),ErrMissingWitnessUtxo=new BIP322Error("missing witness utxo");var BIP322;(function(t){function e(r,s,o=[]){if(s.length==0)throw ErrMissingInputs;validateInputs(s),validateOutputs(o);const a=craftToSpendTx(r,s[0].witnessUtxo.script);return craftToSignTx(a,s,o)}t.create=e;function n(r,s=o=>o.finalize()){return s(r),base64$1.encode(r.extract())}t.signature=n})(BIP322||(BIP322={}));const OP_RETURN_EMPTY_PKSCRIPT=new Uint8Array([OP.RETURN]),ZERO_32=new Uint8Array(32).fill(0),MAX_INDEX=4294967295,TAG_BIP322="BIP0322-signed-message";function validateInput(t){if(t.index===void 0||t.txid===void 0)throw ErrMissingData;if(t.witnessUtxo===void 0)throw ErrMissingWitnessUtxo;return!0}function validateInputs(t){return t.forEach(validateInput),!0}function validateOutput(t){if(t.amount===void 0||t.script===void 0)throw ErrMissingData;return!0}function validateOutputs(t){return t.forEach(validateOutput),!0}function craftToSpendTx(t,e){const n=hashMessage(t),r=new Transaction({version:0,allowUnknownOutputs:!0,allowUnknown:!0,allowUnknownInputs:!0});return r.addInput({txid:ZERO_32,index:MAX_INDEX,sequence:0}),r.addOutput({amount:0n,script:e}),r.updateInput(0,{finalScriptSig:Script.encode(["OP_0",n])}),r}function craftToSignTx(t,e,n){const r=e[0],s=new Transaction({version:2,allowUnknownOutputs:n.length===0,allowUnknown:!0,allowUnknownInputs:!0,lockTime:0});s.addInput({...r,txid:t.id,index:0,witnessUtxo:{script:r.witnessUtxo.script,amount:0n},sighashType:SigHash.ALL});for(const o of e)s.addInput({...o,sighashType:SigHash.ALL});n.length===0&&(n=[{amount:0n,script:OP_RETURN_EMPTY_PKSCRIPT}]);for(const o of n)s.addOutput({amount:o.amount,script:o.script});return s}function hashMessage(t){return schnorr$1.utils.taggedHash(TAG_BIP322,new TextEncoder().encode(t))}var IndexerTxType;(function(t){t[t.INDEXER_TX_TYPE_UNSPECIFIED=0]="INDEXER_TX_TYPE_UNSPECIFIED",t[t.INDEXER_TX_TYPE_RECEIVED=1]="INDEXER_TX_TYPE_RECEIVED",t[t.INDEXER_TX_TYPE_SENT=2]="INDEXER_TX_TYPE_SENT"})(IndexerTxType||(IndexerTxType={}));var ChainTxType;(function(t){t.UNSPECIFIED="INDEXER_CHAINED_TX_TYPE_UNSPECIFIED",t.COMMITMENT="INDEXER_CHAINED_TX_TYPE_COMMITMENT",t.ARK="INDEXER_CHAINED_TX_TYPE_ARK",t.TREE="INDEXER_CHAINED_TX_TYPE_TREE",t.CHECKPOINT="INDEXER_CHAINED_TX_TYPE_CHECKPOINT"})(ChainTxType||(ChainTxType={}));class RestIndexerProvider{constructor(e){this.serverUrl=e}async getVtxoTree(e,n){let r=`${this.serverUrl}/v1/batch/${e.txid}/${e.vout}/tree`;const s=new URLSearchParams;n&&(n.pageIndex!==void 0&&s.append("page.index",n.pageIndex.toString()),n.pageSize!==void 0&&s.append("page.size",n.pageSize.toString())),s.toString()&&(r+="?"+s.toString());const o=await fetch(r);if(!o.ok)throw new Error(`Failed to fetch vtxo tree: ${o.statusText}`);const a=await o.json();if(!Response$1.isVtxoTreeResponse(a))throw new Error("Invalid vtxo tree data received");return a.vtxoTree.forEach(c=>{c.children=Object.fromEntries(Object.entries(c.children).map(([l,u])=>[Number(l),u]))}),a}async getVtxoTreeLeaves(e,n){let r=`${this.serverUrl}/v1/batch/${e.txid}/${e.vout}/tree/leaves`;const s=new URLSearchParams;n&&(n.pageIndex!==void 0&&s.append("page.index",n.pageIndex.toString()),n.pageSize!==void 0&&s.append("page.size",n.pageSize.toString())),s.toString()&&(r+="?"+s.toString());const o=await fetch(r);if(!o.ok)throw new Error(`Failed to fetch vtxo tree leaves: ${o.statusText}`);const a=await o.json();if(!Response$1.isVtxoTreeLeavesResponse(a))throw new Error("Invalid vtxos tree leaves data received");return a}async getBatchSweepTransactions(e){const n=`${this.serverUrl}/v1/batch/${e.txid}/${e.vout}/sweepTxs`,r=await fetch(n);if(!r.ok)throw new Error(`Failed to fetch batch sweep transactions: ${r.statusText}`);const s=await r.json();if(!Response$1.isBatchSweepTransactionsResponse(s))throw new Error("Invalid batch sweep transactions data received");return s}async getCommitmentTx(e){const n=`${this.serverUrl}/v1/commitmentTx/${e}`,r=await fetch(n);if(!r.ok)throw new Error(`Failed to fetch commitment tx: ${r.statusText}`);const s=await r.json();if(!Response$1.isCommitmentTx(s))throw new Error("Invalid commitment tx data received");return s}async getCommitmentTxConnectors(e,n){let r=`${this.serverUrl}/v1/commitmentTx/${e}/connectors`;const s=new URLSearchParams;n&&(n.pageIndex!==void 0&&s.append("page.index",n.pageIndex.toString()),n.pageSize!==void 0&&s.append("page.size",n.pageSize.toString())),s.toString()&&(r+="?"+s.toString());const o=await fetch(r);if(!o.ok)throw new Error(`Failed to fetch commitment tx connectors: ${o.statusText}`);const a=await o.json();if(!Response$1.isConnectorsResponse(a))throw new Error("Invalid commitment tx connectors data received");return a.connectors.forEach(c=>{c.children=Object.fromEntries(Object.entries(c.children).map(([l,u])=>[Number(l),u]))}),a}async getCommitmentTxForfeitTxs(e,n){let r=`${this.serverUrl}/v1/commitmentTx/${e}/forfeitTxs`;const s=new URLSearchParams;n&&(n.pageIndex!==void 0&&s.append("page.index",n.pageIndex.toString()),n.pageSize!==void 0&&s.append("page.size",n.pageSize.toString())),s.toString()&&(r+="?"+s.toString());const o=await fetch(r);if(!o.ok)throw new Error(`Failed to fetch commitment tx forfeitTxs: ${o.statusText}`);const a=await o.json();if(!Response$1.isForfeitTxsResponse(a))throw new Error("Invalid commitment tx forfeitTxs data received");return a}async*getSubscription(e,n){const r=`${this.serverUrl}/v1/script/subscription/${e}`;for(;!n.aborted;)try{const s=await fetch(r,{headers:{Accept:"application/json"}});if(!s.ok)throw new Error(`Unexpected status ${s.status} when subscribing to address updates`);if(!s.body)throw new Error("Response body is null");const o=s.body.getReader(),a=new TextDecoder;let c="";for(;!n.aborted;){const{done:l,value:u}=await o.read();if(l)break;c+=a.decode(u,{stream:!0});const h=c.split(`
`);for(let f=0;f<h.length-1;f++){const p=h[f].trim();if(!p)continue;const g=JSON.parse(p);"result"in g&&(yield{txid:g.result.txid,scripts:g.result.scripts||[],newVtxos:(g.result.newVtxos||[]).map(convertVtxo),spentVtxos:(g.result.spentVtxos||[]).map(convertVtxo),tx:g.result.tx,checkpointTxs:g.result.checkpointTxs})}c=h[h.length-1]}}catch(s){if(s instanceof Error&&s.name==="AbortError")break;if(isFetchTimeoutError(s)){console.debug("Timeout error ignored");continue}throw console.error("Subscription error:",s),s}}async getVirtualTxs(e,n){let r=`${this.serverUrl}/v1/virtualTx/${e.join(",")}`;const s=new URLSearchParams;n&&(n.pageIndex!==void 0&&s.append("page.index",n.pageIndex.toString()),n.pageSize!==void 0&&s.append("page.size",n.pageSize.toString())),s.toString()&&(r+="?"+s.toString());const o=await fetch(r);if(!o.ok)throw new Error(`Failed to fetch virtual txs: ${o.statusText}`);const a=await o.json();if(!Response$1.isVirtualTxsResponse(a))throw new Error("Invalid virtual txs data received");return a}async getVtxoChain(e,n){let r=`${this.serverUrl}/v1/vtxo/${e.txid}/${e.vout}/chain`;const s=new URLSearchParams;n&&(n.pageIndex!==void 0&&s.append("page.index",n.pageIndex.toString()),n.pageSize!==void 0&&s.append("page.size",n.pageSize.toString())),s.toString()&&(r+="?"+s.toString());const o=await fetch(r);if(!o.ok)throw new Error(`Failed to fetch vtxo chain: ${o.statusText}`);const a=await o.json();if(!Response$1.isVtxoChainResponse(a))throw new Error("Invalid vtxo chain data received");return a}async getVtxos(e){if(e!=null&&e.scripts&&(e!=null&&e.outpoints))throw new Error("scripts and outpoints are mutually exclusive options");if(!(e!=null&&e.scripts)&&!(e!=null&&e.outpoints))throw new Error("Either scripts or outpoints must be provided");let n=`${this.serverUrl}/v1/vtxos`;const r=new URLSearchParams;e!=null&&e.scripts&&e.scripts.length>0&&e.scripts.forEach(a=>{r.append("scripts",a)}),e!=null&&e.outpoints&&e.outpoints.length>0&&e.outpoints.forEach(a=>{r.append("outpoints",`${a.txid}:${a.vout}`)}),e&&(e.spendableOnly!==void 0&&r.append("spendableOnly",e.spendableOnly.toString()),e.spentOnly!==void 0&&r.append("spentOnly",e.spentOnly.toString()),e.recoverableOnly!==void 0&&r.append("recoverableOnly",e.recoverableOnly.toString()),e.pageIndex!==void 0&&r.append("page.index",e.pageIndex.toString()),e.pageSize!==void 0&&r.append("page.size",e.pageSize.toString())),r.toString()&&(n+="?"+r.toString());const s=await fetch(n);if(!s.ok)throw new Error(`Failed to fetch vtxos: ${s.statusText}`);const o=await s.json();if(!Response$1.isVtxosResponse(o))throw new Error("Invalid vtxos data received");return{vtxos:o.vtxos.map(convertVtxo),page:o.page}}async subscribeForScripts(e,n){const r=`${this.serverUrl}/v1/script/subscribe`,s=await fetch(r,{headers:{"Content-Type":"application/json"},method:"POST",body:JSON.stringify({scripts:e,subscriptionId:n})});if(!s.ok){const a=await s.text();throw new Error(`Failed to subscribe to scripts: ${a}`)}const o=await s.json();if(!o.subscriptionId)throw new Error("Subscription ID not found");return o.subscriptionId}async unsubscribeForScripts(e,n){const r=`${this.serverUrl}/v1/script/unsubscribe`,s=await fetch(r,{headers:{"Content-Type":"application/json"},method:"POST",body:JSON.stringify({subscriptionId:e,scripts:n})});if(!s.ok){const o=await s.text();throw new Error(`Failed to unsubscribe to scripts: ${o}`)}}}function convertVtxo(t){return{txid:t.outpoint.txid,vout:t.outpoint.vout,value:Number(t.amount),status:{confirmed:!t.isSwept&&!t.isPreconfirmed},virtualStatus:{state:t.isSwept?"swept":t.isPreconfirmed?"preconfirmed":"settled",commitmentTxIds:t.commitmentTxids,batchExpiry:t.expiresAt?Number(t.expiresAt)*1e3:void 0},spentBy:t.spentBy??"",settledBy:t.settledBy,arkTxId:t.arkTxid,createdAt:new Date(Number(t.createdAt)*1e3),isUnrolled:t.isUnrolled}}var Response$1;(function(t){function e(v){return typeof v=="object"&&typeof v.totalOutputAmount=="string"&&typeof v.totalOutputVtxos=="number"&&typeof v.expiresAt=="string"&&typeof v.swept=="boolean"}function n(v){return typeof v=="object"&&typeof v.txid=="string"&&typeof v.expiresAt=="string"&&Object.values(ChainTxType).includes(v.type)&&Array.isArray(v.spends)&&v.spends.every(D=>typeof D=="string")}function r(v){return typeof v=="object"&&typeof v.startedAt=="string"&&typeof v.endedAt=="string"&&typeof v.totalInputAmount=="string"&&typeof v.totalInputVtxos=="number"&&typeof v.totalOutputAmount=="string"&&typeof v.totalOutputVtxos=="number"&&typeof v.batches=="object"&&Object.values(v.batches).every(e)}t.isCommitmentTx=r;function s(v){return typeof v=="object"&&typeof v.txid=="string"&&typeof v.vout=="number"}t.isOutpoint=s;function o(v){return Array.isArray(v)&&v.every(s)}t.isOutpointArray=o;function a(v){return typeof v=="object"&&typeof v.txid=="string"&&typeof v.children=="object"&&Object.values(v.children).every(h)&&Object.keys(v.children).every(D=>Number.isInteger(Number(D)))}function c(v){return Array.isArray(v)&&v.every(a)}t.isTxsArray=c;function l(v){return typeof v=="object"&&typeof v.amount=="string"&&typeof v.createdAt=="string"&&typeof v.isSettled=="boolean"&&typeof v.settledBy=="string"&&Object.values(IndexerTxType).includes(v.type)&&(!v.commitmentTxid&&typeof v.virtualTxid=="string"||typeof v.commitmentTxid=="string"&&!v.virtualTxid)}function u(v){return Array.isArray(v)&&v.every(l)}t.isTxHistoryRecordArray=u;function h(v){return typeof v=="string"&&v.length===64}function f(v){return Array.isArray(v)&&v.every(h)}t.isTxidArray=f;function p(v){return typeof v=="object"&&s(v.outpoint)&&typeof v.createdAt=="string"&&typeof v.expiresAt=="string"&&typeof v.amount=="string"&&typeof v.script=="string"&&typeof v.isPreconfirmed=="boolean"&&typeof v.isSwept=="boolean"&&typeof v.isUnrolled=="boolean"&&typeof v.isSpent=="boolean"&&(!v.spentBy||typeof v.spentBy=="string")&&(!v.settledBy||typeof v.settledBy=="string")&&(!v.arkTxid||typeof v.arkTxid=="string")&&Array.isArray(v.commitmentTxids)&&v.commitmentTxids.every(h)}function g(v){return typeof v=="object"&&typeof v.current=="number"&&typeof v.next=="number"&&typeof v.total=="number"}function w(v){return typeof v=="object"&&Array.isArray(v.vtxoTree)&&v.vtxoTree.every(a)&&(!v.page||g(v.page))}t.isVtxoTreeResponse=w;function y(v){return typeof v=="object"&&Array.isArray(v.leaves)&&v.leaves.every(s)&&(!v.page||g(v.page))}t.isVtxoTreeLeavesResponse=y;function b(v){return typeof v=="object"&&Array.isArray(v.connectors)&&v.connectors.every(a)&&(!v.page||g(v.page))}t.isConnectorsResponse=b;function x(v){return typeof v=="object"&&Array.isArray(v.txids)&&v.txids.every(h)&&(!v.page||g(v.page))}t.isForfeitTxsResponse=x;function _(v){return typeof v=="object"&&Array.isArray(v.sweptBy)&&v.sweptBy.every(h)}t.isSweptCommitmentTxResponse=_;function R(v){return typeof v=="object"&&Array.isArray(v.sweptBy)&&v.sweptBy.every(h)}t.isBatchSweepTransactionsResponse=R;function $(v){return typeof v=="object"&&Array.isArray(v.txs)&&v.txs.every(D=>typeof D=="string")&&(!v.page||g(v.page))}t.isVirtualTxsResponse=$;function A(v){return typeof v=="object"&&Array.isArray(v.chain)&&v.chain.every(n)&&(!v.page||g(v.page))}t.isVtxoChainResponse=A;function L(v){return typeof v=="object"&&Array.isArray(v.vtxos)&&v.vtxos.every(p)&&(!v.page||g(v.page))}t.isVtxosResponse=L})(Response$1||(Response$1={}));class TxTree{constructor(e,n=new Map){this.root=e,this.children=n}static create(e){if(e.length===0)throw new Error("empty chunks");const n=new Map;for(const o of e){const a=decodeNode(o),c=hex$1.encode(sha256x2(a.tx.toBytes(!0)).reverse());n.set(c,a)}const r=[];for(const[o]of n){let a=!1;for(const[c,l]of n)if(c!==o&&(a=hasChild(l,o),a))break;if(!a){r.push(o);continue}}if(r.length===0)throw new Error("no root chunk found");if(r.length>1)throw new Error(`multiple root chunks found: ${r.join(", ")}`);const s=buildGraph(r[0],n);if(!s)throw new Error(`chunk not found for root txid: ${r[0]}`);if(s.nbOfNodes()!==e.length)throw new Error(`number of chunks (${e.length}) is not equal to the number of nodes in the graph (${s.nbOfNodes()})`);return s}nbOfNodes(){let e=1;for(const n of this.children.values())e+=n.nbOfNodes();return e}validate(){if(!this.root)throw new Error("unexpected nil root");const e=this.root.outputsLength,n=this.root.inputsLength;if(n!==1)throw new Error(`unexpected number of inputs: ${n}, expected 1`);if(this.children.size>e-1)throw new Error(`unexpected number of children: ${this.children.size}, expected maximum ${e-1}`);for(const[r,s]of this.children){if(r>=e)throw new Error(`output index ${r} is out of bounds (nb of outputs: ${e})`);s.validate();const o=s.root.getInput(0),a=hex$1.encode(sha256x2(this.root.toBytes(!0)).reverse());if(!o.txid||hex$1.encode(o.txid)!==a||o.index!==r)throw new Error(`input of child ${r} is not the output of the parent`);let c=0n;for(let u=0;u<s.root.outputsLength;u++){const h=s.root.getOutput(u);h!=null&&h.amount&&(c+=h.amount)}const l=this.root.getOutput(r);if(!(l!=null&&l.amount))throw new Error(`parent output ${r} has no amount`);if(c!==l.amount)throw new Error(`sum of child's outputs is not equal to the output of the parent: ${c} != ${l.amount}`)}}leaves(){if(this.children.size===0)return[this.root];const e=[];for(const n of this.children.values())e.push(...n.leaves());return e}get txid(){return hex$1.encode(sha256x2(this.root.toBytes(!0)).reverse())}find(e){if(e===this.txid)return this;for(const n of this.children.values()){const r=n.find(e);if(r)return r}return null}update(e,n){if(e===this.txid){n(this.root);return}for(const r of this.children.values())try{r.update(e,n);return}catch{continue}throw new Error(`tx not found: ${e}`)}*[Symbol.iterator](){yield this;for(const e of this.children.values())yield*e}}function hasChild(t,e){return Object.values(t.children).includes(e)}function buildGraph(t,e){const n=e.get(t);if(!n)return null;const r=n.tx,s=new Map;for(const[o,a]of Object.entries(n.children)){const c=parseInt(o),l=buildGraph(a,e);l&&s.set(c,l)}return new TxTree(r,s)}function decodeNode(t){return{tx:Transaction.fromPSBT(base64$1.decode(t.tx)),children:t.children}}class Wallet{constructor(e,n,r,s,o,a,c,l,u,h,f,p){this.identity=e,this.network=n,this.networkName=r,this.onchainProvider=s,this.arkProvider=o,this.indexerProvider=a,this.arkServerPublicKey=c,this.offchainTapscript=l,this.boardingTapscript=u,this.serverUnrollScript=h,this.forfeitOutputScript=f,this.dustAmount=p}static async create(e){const n=e.identity.xOnlyPublicKey();if(!n)throw new Error("Invalid configured public key");const r=new RestArkProvider(e.arkServerUrl),s=new RestIndexerProvider(e.arkServerUrl),o=await r.getInfo(),a=getNetwork(o.network),c=new EsploraProvider(e.esploraUrl||ESPLORA_URL[o.network]),l={value:o.unilateralExitDelay,type:o.unilateralExitDelay<512n?"blocks":"seconds"},u={value:o.boardingExitDelay,type:o.boardingExitDelay<512n?"blocks":"seconds"},h=hex$1.decode(o.signerPubkey).slice(1),f=new DefaultVtxo.Script({pubKey:n,serverPubKey:h,csvTimelock:l}),p=new DefaultVtxo.Script({pubKey:n,serverPubKey:h,csvTimelock:u}),g=f,w=CSVMultisigTapscript.encode({timelock:l,pubkeys:[h]}),y=Address(a).decode(o.forfeitAddress),b=OutScript.encode(y);return new Wallet(e.identity,a,o.network,c,r,s,h,g,p,w,b,o.dust)}get arkAddress(){return this.offchainTapscript.address(this.network.hrp,this.arkServerPublicKey)}async getAddress(){return this.arkAddress.encode()}async getBoardingAddress(){return this.boardingTapscript.onchainAddress(this.network)}async getBalance(){const[e,n]=await Promise.all([this.getBoardingUtxos(),this.getVtxos()]);let r=0,s=0;for(const h of e)h.status.confirmed?r+=h.value:s+=h.value;let o=0,a=0,c=0;o=n.filter(h=>h.virtualStatus.state==="settled").reduce((h,f)=>h+f.value,0),a=n.filter(h=>h.virtualStatus.state==="preconfirmed").reduce((h,f)=>h+f.value,0),c=n.filter(h=>isSpendable(h)&&h.virtualStatus.state==="swept").reduce((h,f)=>h+f.value,0);const l=r+s,u=o+a+c;return{boarding:{confirmed:r,unconfirmed:s,total:l},settled:o,preconfirmed:a,available:o+a,recoverable:c,total:l+u}}async getVtxos(e){const n=await this.getVirtualCoins(e),r=this.offchainTapscript.encode(),s=this.offchainTapscript.forfeit(),o=this.offchainTapscript.exit();return n.map(a=>({...a,forfeitTapLeafScript:s,intentTapLeafScript:o,tapTree:r}))}async getVirtualCoins(e={withRecoverable:!0,withUnrolled:!1}){const n=[hex$1.encode(this.offchainTapscript.pkScript)],s=(await this.indexerProvider.getVtxos({scripts:n,spendableOnly:!0})).vtxos;if(e.withRecoverable){const o=await this.indexerProvider.getVtxos({scripts:n,recoverableOnly:!0});s.push(...o.vtxos)}if(e.withUnrolled){const o=await this.indexerProvider.getVtxos({scripts:n,spentOnly:!0});s.push(...o.vtxos.filter(a=>a.isUnrolled))}return s}async getTransactionHistory(){if(!this.indexerProvider)return[];const e=await this.indexerProvider.getVtxos({scripts:[hex$1.encode(this.offchainTapscript.pkScript)]}),{boardingTxs:n,commitmentsToIgnore:r}=await this.getBoardingTxs(),s=[],o=[];for(const l of e.vtxos)isSpendable(l)?s.push(l):o.push(l);const a=vtxosToTxs(s,o,r),c=[...n,...a];return c.sort((l,u)=>l.createdAt===0?-1:u.createdAt===0?1:u.createdAt-l.createdAt),c}async getBoardingTxs(){const e=await this.getBoardingAddress(),n=await this.onchainProvider.getTransactions(e),r=[],s=new Set;for(const c of n)for(let l=0;l<c.vout.length;l++){const u=c.vout[l];if(u.scriptpubkey_address===e){const f=(await this.onchainProvider.getTxOutspends(c.txid))[l];f!=null&&f.spent&&s.add(f.txid),r.push({txid:c.txid,vout:l,value:Number(u.value),status:{confirmed:c.status.confirmed,block_time:c.status.block_time},isUnrolled:!0,virtualStatus:{state:f!=null&&f.spent?"spent":"settled",commitmentTxIds:f!=null&&f.spent?[f.txid]:void 0},createdAt:c.status.confirmed?new Date(c.status.block_time*1e3):new Date(0)})}}const o=[],a=[];for(const c of r){const l={key:{boardingTxid:c.txid,commitmentTxid:"",arkTxid:""},amount:c.value,type:TxType.TxReceived,settled:c.virtualStatus.state==="spent",createdAt:c.status.block_time?new Date(c.status.block_time*1e3).getTime():0};c.status.block_time?a.push(l):o.push(l)}return{boardingTxs:[...o,...a],commitmentsToIgnore:s}}async getBoardingUtxos(){const e=await this.getBoardingAddress(),n=await this.onchainProvider.getCoins(e),r=this.boardingTapscript.encode(),s=this.boardingTapscript.forfeit(),o=this.boardingTapscript.exit();return n.map(a=>({...a,forfeitTapLeafScript:s,intentTapLeafScript:o,tapTree:r}))}async sendBitcoin(e){if(e.amount<=0)throw new Error("Amount must be positive");if(!isValidArkAddress(e.address))throw new Error("Invalid Ark address "+e.address);const n=await this.getVirtualCoins({withRecoverable:!1}),r=selectVirtualCoins(n,e.amount),s=this.offchainTapscript.forfeit();if(!s)throw new Error("Selected leaf not found");const o=ArkAddress.decode(e.address),c=[{script:BigInt(e.amount)<this.dustAmount?o.subdustPkScript:o.pkScript,amount:BigInt(e.amount)}];if(r.changeAmount>0n){const w=r.changeAmount<this.dustAmount?this.arkAddress.subdustPkScript:this.arkAddress.pkScript;c.push({script:w,amount:BigInt(r.changeAmount)})}const l=this.offchainTapscript.encode();let u=buildOffchainTx(r.inputs.map(w=>({...w,tapLeafScript:s,tapTree:l})),c,this.serverUnrollScript);const h=await this.identity.sign(u.arkTx),{arkTxid:f,signedCheckpointTxs:p}=await this.arkProvider.submitTx(base64$1.encode(h.toPSBT()),u.checkpoints.map(w=>base64$1.encode(w.toPSBT()))),g=await Promise.all(p.map(async w=>{const y=Transaction.fromPSBT(base64$1.decode(w)),b=await this.identity.sign(y);return base64$1.encode(b.toPSBT())}));return await this.arkProvider.finalizeTx(f,g),f}async settle(e,n){if(e!=null&&e.inputs){for(const p of e.inputs)if(typeof p=="string")try{ArkNote.fromString(p)}catch{throw new Error(`Invalid arknote "${p}"`)}}if(!e){let p=0;const g=await this.getBoardingUtxos();p+=g.reduce((b,x)=>b+x.value,0);const w=await this.getVtxos();p+=w.reduce((b,x)=>b+x.value,0);const y=[...g,...w];if(y.length===0)throw new Error("No inputs found");e={inputs:y,outputs:[{address:await this.getAddress(),amount:BigInt(p)}]}}const r=[],s=[];let o=!1;for(const[p,g]of e.outputs.entries()){let w;try{w=ArkAddress.decode(g.address).pkScript,o=!0}catch{const y=Address(this.network).decode(g.address);w=OutScript.encode(y),r.push(p)}s.push({amount:g.amount,script:w})}let a;const c=[];o&&(a=this.identity.signerSession(),c.push(hex$1.encode(a.getPublicKey())));const[l,u]=await Promise.all([this.makeRegisterIntentSignature(e.inputs,s,r,c),this.makeDeleteIntentSignature(e.inputs)]),h=await this.arkProvider.registerIntent(l),f=new AbortController;try{let p;const g=[...c,...e.inputs.map(A=>`${A.txid}:${A.vout}`)],w=this.arkProvider.getEventStream(f.signal,g);let y,b;const x=[],_=[];let R,$;for await(const A of w)switch(n&&n(A),A.type){case SettlementEventType.BatchFailed:if(A.id===y)throw new Error(A.reason);break;case SettlementEventType.BatchStarted:if(p!==void 0)continue;const L=await this.handleBatchStartedEvent(A,h,this.arkServerPublicKey,this.forfeitOutputScript);L.skip||(p=A.type,b=L.sweepTapTreeRoot,y=L.roundId,o||(p=SettlementEventType.TreeNoncesAggregated));break;case SettlementEventType.TreeTx:if(p!==SettlementEventType.BatchStarted&&p!==SettlementEventType.TreeNoncesAggregated)continue;if(A.batchIndex===0)x.push(A.chunk);else if(A.batchIndex===1)_.push(A.chunk);else throw new Error(`Invalid batch index: ${A.batchIndex}`);break;case SettlementEventType.TreeSignature:if(p!==SettlementEventType.TreeNoncesAggregated||!o)continue;if(!R)throw new Error("Vtxo graph not set, something went wrong");if(A.batchIndex===0){const v=hex$1.decode(A.signature);R.update(A.txid,D=>{D.updateInput(0,{tapKeySig:v})})}break;case SettlementEventType.TreeSigningStarted:if(p!==SettlementEventType.BatchStarted)continue;if(o){if(!a)throw new Error("Signing session not set");if(!b)throw new Error("Sweep tap tree root not set");if(x.length===0)throw new Error("unsigned vtxo graph not received");R=TxTree.create(x),await this.handleSettlementSigningEvent(A,b,a,R)}p=A.type;break;case SettlementEventType.TreeNoncesAggregated:if(p!==SettlementEventType.TreeSigningStarted)continue;if(o){if(!a)throw new Error("Signing session not set");await this.handleSettlementSigningNoncesGeneratedEvent(A,a)}p=A.type;break;case SettlementEventType.BatchFinalization:if(p!==SettlementEventType.TreeNoncesAggregated)continue;if(!this.forfeitOutputScript)throw new Error("Forfeit output script not set");_.length>0&&($=TxTree.create(_),validateConnectorsTxGraph(A.commitmentTx,$)),await this.handleSettlementFinalizationEvent(A,e.inputs,this.forfeitOutputScript,$),p=A.type;break;case SettlementEventType.BatchFinalized:if(p!==SettlementEventType.BatchFinalization)continue;return f.abort(),A.commitmentTxid}}catch(p){f.abort();try{await this.arkProvider.deleteIntent(u)}catch{}throw p}throw new Error("Settlement failed")}async notifyIncomingFunds(e){const n=await this.getAddress(),r=await this.getBoardingAddress();let s,o;if(this.onchainProvider&&r&&(s=await this.onchainProvider.watchAddresses([r],c=>{const l=c.map(u=>{const h=u.vout.findIndex(f=>f.scriptpubkey_address===r);return h===-1?(console.warn(`No vout found for address ${r} in transaction ${u.txid}`),null):{txid:u.txid,vout:h,value:Number(u.vout[h].value),status:u.status}}).filter(u=>u!==null);e({type:"utxo",coins:l})})),this.indexerProvider&&n){const c=this.offchainTapscript,l=await this.indexerProvider.subscribeForScripts([hex$1.encode(c.pkScript)]),u=new AbortController,h=this.indexerProvider.getSubscription(l,u.signal);o=async()=>{var f;u.abort(),await((f=this.indexerProvider)==null?void 0:f.unsubscribeForScripts(l))},(async()=>{var f;try{for await(const p of h)((f=p.newVtxos)==null?void 0:f.length)>0&&e({type:"vtxo",vtxos:p.newVtxos})}catch(p){console.error("Subscription error:",p)}})()}return()=>{s==null||s(),o==null||o()}}async handleBatchStartedEvent(e,n,r,s){const o=new TextEncoder().encode(n),a=sha256$3(o),c=hex$1.encode(new Uint8Array(a));let l=!0;for(const f of e.intentIdHashes)if(f===c){if(!this.arkProvider)throw new Error("Ark provider not configured");await this.arkProvider.confirmRegistration(n),l=!1}if(l)return{skip:l};const u=CSVMultisigTapscript.encode({timelock:{value:e.batchExpiry,type:e.batchExpiry>=512n?"seconds":"blocks"},pubkeys:[r]}).script,h=tapLeafHash(u);return{roundId:e.id,sweepTapTreeRoot:h,forfeitOutputScript:s,skip:!1}}async handleSettlementSigningEvent(e,n,r,s){const o=Transaction.fromPSBT(base64$1.decode(e.unsignedCommitmentTx));validateVtxoTxGraph(s,o,n);const a=o.getOutput(0);if(!(a!=null&&a.amount))throw new Error("Shared output not found");r.init(s,n,a.amount),await this.arkProvider.submitTreeNonces(e.id,hex$1.encode(r.getPublicKey()),r.getNonces())}async handleSettlementSigningNoncesGeneratedEvent(e,n){n.setAggregatedNonces(e.treeNonces);const r=n.sign();await this.arkProvider.submitTreeSignatures(e.id,hex$1.encode(n.getPublicKey()),r)}async handleSettlementFinalizationEvent(e,n,r,s){const o=[],a=await this.getVirtualCoins();let c=Transaction.fromPSBT(base64$1.decode(e.commitmentTx)),l=!1,u=0;const h=(s==null?void 0:s.leaves())||[];for(const f of n){const p=a.find(R=>R.txid===f.txid&&R.vout===f.vout);if(!p){l=!0;const R=[];for(let $=0;$<c.inputsLength;$++){const A=c.getInput($);if(!A.txid||A.index===void 0)throw new Error("The server returned incomplete data. No settlement input found in the PSBT");hex$1.encode(A.txid)===f.txid&&A.index===f.vout&&(c.updateInput($,{tapLeafScript:[f.forfeitTapLeafScript]}),R.push($))}c=await this.identity.sign(c,R);continue}if(isRecoverable(p)||isSubdust(p,this.dustAmount))continue;if(h.length===0)throw new Error("connectors not received");if(u>=h.length)throw new Error("not enough connectors received");const g=h[u],w=hex$1.encode(sha256x2(g.toBytes(!0)).reverse()),y=g.getOutput(0);if(!y)throw new Error("connector output not found");const b=y.amount,x=y.script;if(!b||!x)throw new Error("invalid connector output");u++;let _=buildForfeitTx([{txid:f.txid,index:f.vout,witnessUtxo:{amount:BigInt(p.value),script:VtxoScript.decode(f.tapTree).pkScript},sighashType:SigHash.DEFAULT,tapLeafScript:[f.forfeitTapLeafScript]},{txid:w,index:0,witnessUtxo:{amount:b,script:x}}],r);_=await this.identity.sign(_,[0]),o.push(base64$1.encode(_.toPSBT()))}(o.length>0||l)&&await this.arkProvider.submitSignedForfeitTxs(o,l?base64$1.encode(c.toPSBT()):void 0)}async makeRegisterIntentSignature(e,n,r,s){const o=Math.floor(Date.now()/1e3),{inputs:a,inputTapTrees:c,finalizer:l}=this.prepareBIP322Inputs(e),u={type:"register",input_tap_trees:c,onchain_output_indexes:r,valid_at:o,expire_at:o+2*60,cosigners_public_keys:s},h=JSON.stringify(u,null,0);return{signature:await this.makeBIP322Signature(h,a,l,n),message:h}}async makeDeleteIntentSignature(e){const n=Math.floor(Date.now()/1e3),{inputs:r,finalizer:s}=this.prepareBIP322Inputs(e),o={type:"delete",expire_at:n+2*60},a=JSON.stringify(o,null,0);return{signature:await this.makeBIP322Signature(a,r,s),message:a}}prepareBIP322Inputs(e){const n=[],r=[],s=[];for(const o of e){const a=VtxoScript.decode(o.tapTree),c=getSequence(o);n.push({txid:hex$1.decode(o.txid),index:o.vout,witnessUtxo:{amount:BigInt(o.value),script:a.pkScript},sequence:c,tapLeafScript:[o.intentTapLeafScript]}),r.push(hex$1.encode(o.tapTree)),s.push(o.extraWitness||[])}return{inputs:n,inputTapTrees:r,finalizer:finalizeWithExtraWitnesses(s)}}async makeBIP322Signature(e,n,r,s){const o=BIP322.create(e,n,s),a=await this.identity.sign(o);return BIP322.signature(a,r)}}Wallet.MIN_FEE_RATE=1;function finalizeWithExtraWitnesses(t){return function(e){for(let n=0;n<e.inputsLength;n++){try{e.finalizeIdx(n)}catch(o){if(o instanceof Error&&o.message.includes("finalize/taproot: empty witness")){const a=e.getInput(n).tapLeafScript;if(!a||a.length<=0)throw o;const[c,l]=a[0],u=l.slice(0,-1);e.updateInput(n,{finalScriptWitness:[u,TaprootControlBlock.encode(c)]})}}const r=e.getInput(n).finalScriptWitness;if(!r)throw new Error("input not finalized");const s=t[n===0?0:n-1];s&&s.length>0&&e.updateInput(n,{finalScriptWitness:[...s,...r]})}}}function getSequence(t){let e;try{const n=t.intentTapLeafScript[1],r=n.subarray(0,n.length-1),s=CSVMultisigTapscript.decode(r).params;e=bip68.encode(s.timelock.type==="blocks"?{blocks:Number(s.timelock.value)}:{seconds:Number(s.timelock.value)})}catch{}return e}function isValidArkAddress(t){try{return ArkAddress.decode(t),!0}catch{return!1}}function selectVirtualCoins(t,e){const n=[...t].sort((a,c)=>{const l=a.virtualStatus.batchExpiry||Number.MAX_SAFE_INTEGER,u=c.virtualStatus.batchExpiry||Number.MAX_SAFE_INTEGER;return l!==u?l-u:c.value-a.value}),r=[];let s=0;for(const a of n)if(r.push(a),s+=a.value,s>=e)break;if(s===e)return{inputs:r,changeAmount:0n};if(s<e)throw new Error("Insufficient funds");const o=BigInt(s-e);return{inputs:r,changeAmount:o}}var Response;(function(t){t.walletInitialized=E=>({type:"WALLET_INITIALIZED",success:!0,id:E});function e(E,k){return{type:"ERROR",success:!1,message:k,id:E}}t.error=e;function n(E,k){return{type:"SETTLE_EVENT",success:!0,event:k,id:E}}t.settleEvent=n;function r(E,k){return{type:"SETTLE_SUCCESS",success:!0,txid:k,id:E}}t.settleSuccess=r;function s(E){return E.type==="SETTLE_SUCCESS"&&E.success}t.isSettleSuccess=s;function o(E){return E.type==="ADDRESS"&&E.success===!0}t.isAddress=o;function a(E){return E.type==="BOARDING_ADDRESS"&&E.success===!0}t.isBoardingAddress=a;function c(E,k){return{type:"ADDRESS",success:!0,address:k,id:E}}t.address=c;function l(E,k){return{type:"BOARDING_ADDRESS",success:!0,address:k,id:E}}t.boardingAddress=l;function u(E){return E.type==="BALANCE"&&E.success===!0}t.isBalance=u;function h(E,k){return{type:"BALANCE",success:!0,balance:k,id:E}}t.balance=h;function f(E){return E.type==="VTXOS"&&E.success===!0}t.isVtxos=f;function p(E,k){return{type:"VTXOS",success:!0,vtxos:k,id:E}}t.vtxos=p;function g(E){return E.type==="VIRTUAL_COINS"&&E.success===!0}t.isVirtualCoins=g;function w(E,k){return{type:"VIRTUAL_COINS",success:!0,virtualCoins:k,id:E}}t.virtualCoins=w;function y(E){return E.type==="BOARDING_UTXOS"&&E.success===!0}t.isBoardingUtxos=y;function b(E,k){return{type:"BOARDING_UTXOS",success:!0,boardingUtxos:k,id:E}}t.boardingUtxos=b;function x(E){return E.type==="SEND_BITCOIN_SUCCESS"&&E.success===!0}t.isSendBitcoinSuccess=x;function _(E,k){return{type:"SEND_BITCOIN_SUCCESS",success:!0,txid:k,id:E}}t.sendBitcoinSuccess=_;function R(E){return E.type==="TRANSACTION_HISTORY"&&E.success===!0}t.isTransactionHistory=R;function $(E,k){return{type:"TRANSACTION_HISTORY",success:!0,transactions:k,id:E}}t.transactionHistory=$;function A(E){return E.type==="WALLET_STATUS"&&E.success===!0}t.isWalletStatus=A;function L(E,k){return{type:"WALLET_STATUS",success:!0,status:{walletInitialized:k},id:E}}t.walletStatus=L;function v(E){return E.type==="CLEAR_RESPONSE"}t.isClearResponse=v;function D(E,k){return{type:"CLEAR_RESPONSE",success:k,id:E}}t.clearResponse=D;function j(E,k){return{type:"SIGN_SUCCESS",success:!0,tx:k,id:E}}t.signSuccess=j;function z(E){return E.type==="SIGN_SUCCESS"&&E.success===!0}t.isSignSuccess=z})(Response||(Response={}));class TxWeightEstimator{constructor(e,n,r,s,o,a){this.hasWitness=e,this.inputCount=n,this.outputCount=r,this.inputSize=s,this.inputWitnessSize=o,this.outputSize=a}static create(){return new TxWeightEstimator(!1,0,0,0,0,0)}addP2AInput(){return this.inputCount++,this.inputSize+=TxWeightEstimator.INPUT_SIZE,this}addKeySpendInput(e=!0){return this.inputCount++,this.inputWitnessSize+=64+1+(e?0:1),this.inputSize+=TxWeightEstimator.INPUT_SIZE,this.hasWitness=!0,this}addP2PKHInput(){return this.inputCount++,this.inputWitnessSize++,this.inputSize+=TxWeightEstimator.INPUT_SIZE+TxWeightEstimator.P2PKH_SCRIPT_SIG_SIZE,this}addTapscriptInput(e,n,r){const s=1+TxWeightEstimator.BASE_CONTROL_BLOCK_SIZE+1+n+1+r;return this.inputCount++,this.inputWitnessSize+=e+s,this.inputSize+=TxWeightEstimator.INPUT_SIZE,this.hasWitness=!0,this.inputCount++,this}addP2WKHOutput(){return this.outputCount++,this.outputSize+=TxWeightEstimator.OUTPUT_SIZE+TxWeightEstimator.P2WKH_OUTPUT_SIZE,this}addP2TROutput(){return this.outputCount++,this.outputSize+=TxWeightEstimator.OUTPUT_SIZE+TxWeightEstimator.P2TR_OUTPUT_SIZE,this}vsize(){const e=a=>a<253?1:a<65535?3:a<4294967295?5:9,n=e(this.inputCount),r=e(this.outputCount);let o=(TxWeightEstimator.BASE_TX_SIZE+n+this.inputSize+r+this.outputSize)*TxWeightEstimator.WITNESS_SCALE_FACTOR;return this.hasWitness&&(o+=TxWeightEstimator.WITNESS_HEADER_SIZE+this.inputWitnessSize),vsize(o)}}TxWeightEstimator.P2PKH_SCRIPT_SIG_SIZE=1+73+1+33;TxWeightEstimator.INPUT_SIZE=32+4+1+4;TxWeightEstimator.BASE_CONTROL_BLOCK_SIZE=1+32;TxWeightEstimator.OUTPUT_SIZE=8+1;TxWeightEstimator.P2WKH_OUTPUT_SIZE=1+1+20;TxWeightEstimator.BASE_TX_SIZE=8+2;TxWeightEstimator.WITNESS_HEADER_SIZE=2;TxWeightEstimator.WITNESS_SCALE_FACTOR=4;TxWeightEstimator.P2TR_OUTPUT_SIZE=1+1+32;const vsize=t=>{const e=BigInt(Math.ceil(t/TxWeightEstimator.WITNESS_SCALE_FACTOR));return{value:e,fee:n=>n*e}};var Request;(function(t){function e(w){return typeof w=="object"&&w!==null&&"type"in w}t.isBase=e;function n(w){return w.type==="INIT_WALLET"&&"privateKey"in w&&typeof w.privateKey=="string"&&"arkServerUrl"in w&&typeof w.arkServerUrl=="string"&&("arkServerPublicKey"in w?typeof w.arkServerPublicKey=="string"||w.arkServerPublicKey===void 0:!0)}t.isInitWallet=n;function r(w){return w.type==="SETTLE"}t.isSettle=r;function s(w){return w.type==="GET_ADDRESS"}t.isGetAddress=s;function o(w){return w.type==="GET_BOARDING_ADDRESS"}t.isGetBoardingAddress=o;function a(w){return w.type==="GET_BALANCE"}t.isGetBalance=a;function c(w){return w.type==="GET_VTXOS"}t.isGetVtxos=c;function l(w){return w.type==="GET_VIRTUAL_COINS"}t.isGetVirtualCoins=l;function u(w){return w.type==="GET_BOARDING_UTXOS"}t.isGetBoardingUtxos=u;function h(w){return w.type==="SEND_BITCOIN"&&"params"in w&&w.params!==null&&typeof w.params=="object"&&"address"in w.params&&typeof w.params.address=="string"&&"amount"in w.params&&typeof w.params.amount=="number"}t.isSendBitcoin=h;function f(w){return w.type==="GET_TRANSACTION_HISTORY"}t.isGetTransactionHistory=f;function p(w){return w.type==="GET_STATUS"}t.isGetStatus=p;function g(w){return w.type==="SIGN"&&"tx"in w&&typeof w.tx=="string"&&("inputIndexes"in w&&w.inputIndexes!=null?Array.isArray(w.inputIndexes)&&w.inputIndexes.every(y=>typeof y=="number"):!0)}t.isSign=g})(Request||(Request={}));var Unroll;(function(t){let e;(function(s){s[s.UNROLL=0]="UNROLL",s[s.WAIT=1]="WAIT",s[s.DONE=2]="DONE"})(e=t.StepType||(t.StepType={}));class n{constructor(o,a,c,l){this.toUnroll=o,this.bumper=a,this.explorer=c,this.indexer=l}static async create(o,a,c,l){const{chain:u}=await l.getVtxoChain(o);return new n({...o,chain:u},a,c,l)}async next(){let o;const a=this.toUnroll.chain;for(let u=a.length-1;u>=0;u--){const h=a[u];if(!(h.type===ChainTxType.COMMITMENT||h.type===ChainTxType.UNSPECIFIED))try{if(!(await this.explorer.getTxStatus(h.txid)).confirmed)return{type:e.WAIT,txid:h.txid,do:doWait(this.explorer,h.txid)}}catch{o=h;break}}if(!o)return{type:e.DONE,vtxoTxid:this.toUnroll.txid,do:()=>Promise.resolve()};const c=await this.indexer.getVirtualTxs([o.txid]);if(c.txs.length===0)throw new Error(`Tx ${o.txid} not found`);const l=Transaction.fromPSBT(base64$1.decode(c.txs[0]),{allowUnknownInputs:!0});if(o.type===ChainTxType.TREE){const u=l.getInput(0);if(!u)throw new Error("Input not found");const h=u.tapKeySig;if(!h)throw new Error("Tap key sig not found");l.updateInput(0,{finalScriptWitness:[h]})}else l.finalize();return{type:e.UNROLL,tx:l,do:doUnroll(this.bumper,this.explorer,l)}}async*[Symbol.asyncIterator](){let o;do{o!==void 0&&await sleep(1e3);const a=await this.next();await a.do(),yield a,o=a.type}while(o!==e.DONE)}}t.Session=n;async function r(s,o,a){const c=await s.onchainProvider.getChainTip();let l=await s.getVtxos({withUnrolled:!0});if(l=l.filter(b=>o.includes(b.txid)),l.length===0)throw new Error("No vtxos to complete unroll");const u=[];let h=0n;const f=TxWeightEstimator.create();for(const b of l){if(!b.isUnrolled)throw new Error(`Vtxo ${b.txid}:${b.vout} is not fully unrolled, use unroll first`);const x=await s.onchainProvider.getTxStatus(b.txid);if(!x.confirmed)throw new Error(`tx ${b.txid} is not confirmed`);const _=availableExitPath({height:x.blockHeight,time:x.blockTime},c,b);if(!_)throw new Error(`no available exit path found for vtxo ${b.txid}:${b.vout}`);const R=VtxoScript.decode(b.tapTree).findLeaf(hex$1.encode(_.script));if(!R)throw new Error(`spending leaf not found for vtxo ${b.txid}:${b.vout}`);h+=BigInt(b.value),u.push({txid:b.txid,index:b.vout,tapLeafScript:[R],sequence:4294967295-1,witnessUtxo:{amount:BigInt(b.value),script:VtxoScript.decode(b.tapTree).pkScript},sighashType:SigHash.DEFAULT}),f.addTapscriptInput(64,R[1].length,TaprootControlBlock.encode(R[0]).length)}const p=new Transaction({allowUnknownInputs:!0,version:2});for(const b of u)p.addInput(b);f.addP2TROutput();let g=await s.onchainProvider.getFeeRate();(!g||g<Wallet.MIN_FEE_RATE)&&(g=Wallet.MIN_FEE_RATE);const w=f.vsize().fee(BigInt(g));if(w>h)throw new Error("fee amount is greater than the total amount");p.addOutputAddress(a,h-w);const y=await s.identity.sign(p);return y.finalize(),await s.onchainProvider.broadcastTransaction(y.hex),y.id}t.completeUnroll=r})(Unroll||(Unroll={}));function sleep(t){return new Promise(e=>setTimeout(e,t))}function doUnroll(t,e,n){return async()=>{const[r,s]=await t.bumpP2A(n);await e.broadcastTransaction(r,s)}}function doWait(t,e){return()=>new Promise((n,r)=>{const s=setInterval(async()=>{try{(await t.getTxStatus(e)).confirmed&&(clearInterval(s),n())}catch(o){clearInterval(s),r(o)}},5e3)})}function availableExitPath(t,e,n){const r=VtxoScript.decode(n.tapTree).exitPaths();for(const s of r)if(s.params.timelock.type==="blocks"){if(e.height>=t.height+Number(s.params.timelock.value))return s}else if(e.time>=t.time+Number(s.params.timelock.value))return s}class ServerManager{constructor(e){this.notificationManager=e,this.provider=null,this.serverUrl="",this.isConnected=!1,this.arkInfo=null;const n=this.getSavedServerUrl();n&&(this.serverUrl=n)}async connectToServer(e){const n=e||this.serverUrl;if(!n)return this.notificationManager.showError("Please enter a server URL"),!1;try{return this.provider=new RestArkProvider(n),this.arkInfo=await this.provider.getInfo(),this.serverUrl=n,this.isConnected=!0,localStorage.setItem("arkServerUrl",n),this.notificationManager.showSuccess("Connected to Ark server successfully"),!0}catch{return this.notificationManager.showError("Failed to connect to server. Please check the URL and try again."),this.isConnected=!1,!1}}getUnilateralDelay(){return{type:this.arkInfo.unilateralExitDelay<512?"blocks":"seconds",value:this.arkInfo.unilateralExitDelay}}getServerKey(){return this.arkInfo.signerPubkey.slice(2)}getProvider(){return this.provider}getIndexerProvider(){return new RestIndexerProvider(this.serverUrl)}getServerUrl(){return this.serverUrl}setServerUrl(e){this.serverUrl=e}isServerConnected(){return this.isConnected}getSavedServerUrl(){return localStorage.getItem("arkServerUrl")}reset(){this.provider=null,this.isConnected=!1}getNetworkInfo(){return this.arkInfo.network}getAddrPrefix(){return this.getNetworkInfo()=="mainnet"?"ark":"tark"}}class WalletManager{constructor(e,n){this.currentWallet=null,this.notificationManager=e,this.serverManager=n}generateRandomBytes(e){return crypto.getRandomValues(new Uint8Array(e))}async generateWallet(){const e=this.serverManager.getProvider();if(!e)throw new Error("Server not connected");const n=this.generateRandomBytes(32),r=hex$1.encode(n),s=SingleKey.fromPrivateKey(n),o=await Wallet.create({identity:s,arkServerUrl:e.serverUrl}),a=await o.getAddress(),c=await o.getBoardingAddress(),l=hex$1.encode(s.xOnlyPublicKey());return{wallet:o,identity:s,arkAddress:a,boardingAddress:c,pubkey:l,privateKey:r}}async createWallet(){try{const e=await this.generateWallet();this.currentWallet=e,this.notificationManager.showSuccess("Wallet created successfully!")}catch(e){console.error("Failed to create wallet:",e),this.notificationManager.showError("Failed to create wallet")}}async importWallet(e){if(!e.trim()){this.notificationManager.showError("Please enter a private key");return}try{const n=this.serverManager.getProvider();if(!n)throw new Error("Server not connected");const r=SingleKey.fromHex(e.trim()),s=await Wallet.create({identity:r,arkServerUrl:n.serverUrl}),o=await s.getAddress(),a=await s.getBoardingAddress(),c=hex$1.encode(r.xOnlyPublicKey());this.currentWallet={wallet:s,identity:r,arkAddress:o,boardingAddress:a,pubkey:c,privateKey:e.trim()},this.notificationManager.showSuccess("Wallet imported successfully!")}catch(n){console.error("Failed to import wallet:",n),this.notificationManager.showError("Failed to import wallet. Please check your private key.")}}getCurrentWallet(){return this.currentWallet}resetWallet(){this.currentWallet=null}async refreshBalance(){if(!this.currentWallet)throw new Error("No wallet available");try{return await this.currentWallet.wallet.getBalance()}catch(e){throw console.error("Failed to refresh balance:",e),this.notificationManager.showError("Failed to refresh balance"),e}}async settle(){if(!this.currentWallet){this.notificationManager.showError("No wallet available");return}try{this.notificationManager.showInfo("Settling wallet...");const e=await this.currentWallet.wallet.settle();console.log("Settle result:",e),e?this.notificationManager.showSuccess(`Settlement successful! TXID: ${e}`):this.notificationManager.showSuccess("Settlement completed")}catch(e){console.error("Settlement failed:",e),this.notificationManager.showError("Settlement failed")}}async sendTransaction(e,n){if(!this.currentWallet){this.notificationManager.showError("No wallet available");return}if(!e.trim()){this.notificationManager.showError("Please enter valid address");return}try{this.notificationManager.showInfo("Sending transaction...");let r;if(n===void 0?(r=(await this.currentWallet.wallet.getBalance()).total,console.log("Using full balance:",r)):r=n,r<=0){this.notificationManager.showError("Insufficient balance");return}const s=await this.currentWallet.wallet.sendBitcoin({address:e,amount:r});console.log("Send result:",s),this.notificationManager.showSuccess("Transaction sent successfully!")}catch(r){console.error("Transaction failed:",r),this.notificationManager.showError("Transaction failed")}}}class UserManager{constructor(e,n){this.users=new Map,this.friendlyNames=["Alice","Bob","Carol","Dave","Eve","Frank","Grace","Heidi","Ivan","Judy","Mallory","Oscar","Peggy","Quentin","Rupert","Sybil","Trent","Ursula","Victor","Walter","Xavier","Yvonne","Zeke"],this.usedNames=new Set,this.notificationManager=e,this.communicationProvider=n,this.initializeUsers()}async initializeUsers(){this.communicationProvider.subscribeToUsers(e=>{this.updateUsersFromProvider(e)}),await this.loadUsers()}updateUsersFromProvider(e){this.users.clear(),e.forEach(n=>{this.users.set(n.pubkey,n)}),this.buildUsedNamesSet()}async autoRegisterUser(e){if(this.users.has(e.pubkey))return;const r={name:this.assignFriendlyName(),pubkey:e.pubkey,address:e.arkAddress,timestamp:Date.now()};this.users.set(r.pubkey,r),await this.saveUsers(),this.notificationManager.showSuccess(`User registered: ${r.name}`)}async unregisterUser(e){if(e&&this.users.has(e.pubkey)){const n=this.users.get(e.pubkey);this.users.delete(e.pubkey),await this.saveUsers(),this.notificationManager.showInfo(`User unregistered: ${n==null?void 0:n.name}`)}}getUsers(){return Array.from(this.users.values()).sort((e,n)=>n.timestamp-e.timestamp)}async refreshUsers(){await this.loadUsers()}getUserById(e){return this.users.get(e)||null}getCurrentUserRole(e,n){if(!n)return null;const r=n.pubkey;return e.buyer.pubkey===r?"buyer":e.seller.pubkey===r?"seller":e.arbitrator.pubkey===r?"arbitrator":null}async loadUsers(){try{const e=await this.communicationProvider.getUsers();this.users.clear(),e.forEach(n=>{this.users.set(n.pubkey,n)}),this.buildUsedNamesSet()}catch(e){console.error("Failed to load users from communication provider:",e)}}async saveUsers(){try{const e=Array.from(this.users.values());for(const n of e)await this.communicationProvider.publishUser(n)}catch(e){console.error("Failed to save users to communication provider:",e)}}assignFriendlyName(){for(const n of this.friendlyNames)if(!this.usedNames.has(n))return this.usedNames.add(n),n;let e=1;for(;;){const n=`${this.friendlyNames[0]} ${e}`;if(!this.usedNames.has(n))return this.usedNames.add(n),n;e++}}buildUsedNamesSet(){this.usedNames.clear();for(const e of this.users.values())this.usedNames.add(e.name)}}const scriptRel="modulepreload",assetsURL=function(t){return"/ark-escrow-demo/"+t},seen={},__vitePreload=function(e,n,r){if(!n||n.length===0)return e();const s=document.getElementsByTagName("link");return Promise.all(n.map(o=>{if(o=assetsURL(o),o in seen)return;seen[o]=!0;const a=o.endsWith(".css"),c=a?'[rel="stylesheet"]':"";if(!!r)for(let h=s.length-1;h>=0;h--){const f=s[h];if(f.href===o&&(!a||f.rel==="stylesheet"))return}else if(document.querySelector(`link[href="${o}"]${c}`))return;const u=document.createElement("link");if(u.rel=a?"stylesheet":scriptRel,a||(u.as="script",u.crossOrigin=""),u.href=o,document.head.appendChild(u),a)return new Promise((h,f)=>{u.addEventListener("load",h),u.addEventListener("error",()=>f(new Error(`Unable to preload CSS for ${o}`)))})})).then(()=>e()).catch(o=>{const a=new Event("vite:preloadError",{cancelable:!0});if(a.payload=o,window.dispatchEvent(a),!a.defaultPrevented)throw o})};var VEscrow;(t=>{function e(r){const{buyer:s,seller:o,arbitrator:a,server:c}=r,l=[{name:"buyer",key:s},{name:"seller",key:o},{name:"arbitrator",key:a},{name:"server",key:c}];for(const{name:h,key:f}of l)if(f.length!==32)throw new Error(`Invalid ${h} public key length: expected 32, got ${f.length}`);if(new Set([hex$1.encode(s),hex$1.encode(o),hex$1.encode(a),hex$1.encode(c)]).size!==4)throw new Error("All parties must have unique public keys")}class n extends VtxoScript{constructor(s){e(s);const{buyer:o,seller:a,arbitrator:c,server:l,unilateralDelay:u}=s,h=MultisigTapscript.encode({pubkeys:[a,c,l]}).script,f=MultisigTapscript.encode({pubkeys:[o,c,l]}).script,p=MultisigTapscript.encode({pubkeys:[o,a,l]}).script,g=CSVMultisigTapscript.encode({pubkeys:[a,c],timelock:u}).script,w=CSVMultisigTapscript.encode({pubkeys:[o,c],timelock:u}).script,y=CSVMultisigTapscript.encode({pubkeys:[o,a],timelock:u}).script;super([h,f,p,g,w,y]),this.options=s,this.releaseScript=hex$1.encode(h),this.refundScript=hex$1.encode(f),this.directScript=hex$1.encode(p),this.unilateralReleaseScript=hex$1.encode(g),this.unilateralRefundScript=hex$1.encode(w),this.unilateralDirectScript=hex$1.encode(y)}release(){return this.findLeaf(this.releaseScript)}refund(){return this.findLeaf(this.refundScript)}direct(){return this.findLeaf(this.directScript)}unilateralRelease(){return this.findLeaf(this.unilateralReleaseScript)}unilateralRefund(){return this.findLeaf(this.unilateralRefundScript)}unilateralDirect(){return this.findLeaf(this.unilateralDirectScript)}getSpendingPaths(){return[{name:"release",type:"collaborative",description:"Release funds to seller (goods delivered)",script:this.releaseScript,signers:["seller","arbitrator","server"]},{name:"refund",type:"collaborative",description:"Refund funds to buyer (dispute resolved)",script:this.refundScript,signers:["buyer","arbitrator","server"]},{name:"direct",type:"collaborative",description:"Direct settlement between parties",script:this.directScript,signers:["buyer","seller","server"]},{name:"unilateralRelease",type:"unilateral",description:"Release funds after timelock",script:this.unilateralReleaseScript,signers:["seller","arbitrator"]},{name:"unilateralRefund",type:"unilateral",description:"Refund funds after timelock",script:this.unilateralRefundScript,signers:["buyer","arbitrator"]},{name:"unilateralDirect",type:"unilateral",description:"Direct settlement after timelock",script:this.unilateralDirectScript,signers:["buyer","seller"]}]}}t.Script=n})(VEscrow||(VEscrow={}));class ContractManager{constructor(e,n,r,s,o){this.contracts=new Map,this.notificationManager=e,this.userManager=n,this.serverManager=r,this.walletManager=s,this.communicationProvider=o,this.initializeContracts()}async initializeContracts(){this.communicationProvider.subscribeToContracts(e=>{this.updateContractsFromProvider(e)}),await this.loadContracts()}async loadContracts(){try{const e=await this.communicationProvider.getContracts();this.contracts.clear(),e.forEach(n=>{this.contracts.set(n.arkAddress,n)})}catch(e){console.error("Failed to load contracts from communication provider:",e)}}updateContractsFromProvider(e){this.contracts.clear(),e.forEach(n=>{this.contracts.set(n.arkAddress,n)})}restoreScript(e){return new VEscrow.Script({unilateralDelay:this.serverManager.getUnilateralDelay(),buyer:hex$1.decode(e.buyer.pubkey),seller:hex$1.decode(e.seller.pubkey),arbitrator:hex$1.decode(e.arbitrator.pubkey),server:hex$1.decode(this.serverManager.getServerKey())})}async createEscrowContract(e,n,r,s,o,a){if(!o){this.notificationManager.showError("No wallet available");return}if(!e||!n||!r){this.notificationManager.showError("Please select all parties");return}const c=[e,n,r];if(new Set(c).size!==c.length){this.notificationManager.showError("All parties must be different users");return}try{const l=this.userManager.getUserById(e),u=this.userManager.getUserById(n),h=this.userManager.getUserById(r),f=this.serverManager.getServerKey(),p=this.serverManager.getAddrPrefix();if(!l||!u||!h){this.notificationManager.showError("One or more selected users not found");return}const g={buyer:l,seller:u,arbitrator:h,description:s.trim(),timestamp:Date.now(),arkAddress:""},y=this.restoreScript(g).address(p,hex$1.decode(f));g.arkAddress=y.encode(),this.contracts.set(g.arkAddress,g),await this.communicationProvider.publishContract(g),this.notificationManager.showSuccess("Escrow contract created successfully!")}catch(l){console.error("Failed to create contract:",l),this.notificationManager.showError("Failed to create contract")}}getContracts(){return Array.from(this.contracts.values())}async refreshContracts(){await this.loadContracts()}getContractsForUser(e){return this.getContracts().filter(r=>r.buyer.pubkey===e||r.seller.pubkey===e||r.arbitrator.pubkey===e)}async getEscrowState(e){const r=this.restoreScript(e).address(this.serverManager.getAddrPrefix(),hex$1.decode(this.serverManager.getServerKey()));if(!r)return{status:"created",balance:0,vtxoExists:!1};try{const s=this.serverManager.getIndexerProvider();if(!s)throw new Error("No provider available");const o=hex$1.encode(r.pkScript),a=await s.getVtxos({scripts:[o]}),c=a.vtxos.length>0,l=a.vtxos.reduce((f,p)=>f+(p.spentBy?0:p.value),0),u=c&&a.vtxos.every(f=>f.spentBy);let h;return c?u?h="executed":h="funded":h="created",{status:h,balance:l,vtxoExists:c}}catch(s){return console.error("Failed to get escrow state:",s),{status:"created",balance:0,vtxoExists:!1}}}getAvailableActions(e,n){const r=[];if(!n)return r;if(e.status==="created"){switch(n){case"seller":r.push("Fund");break}return r}switch(n){case"buyer":r.push("Refund","Direct Settle");break;case"seller":r.push("Release","Direct Settle");break;case"arbitrator":r.push("Release","Refund");break}return r}async executeContractAction(e,n,r){try{const o=this.restoreScript(e).address(this.serverManager.getAddrPrefix(),hex$1.decode(this.serverManager.getServerKey())),a=hex$1.encode(o.pkScript),l=await this.serverManager.getIndexerProvider().getVtxos({scripts:[a]});if((n==null?void 0:n.toLowerCase())==="fund")if(l.vtxos.length>0){this.notificationManager.showError("Funds already exist in escrow contract");return}else{const x=o.encode();await this.walletManager.sendTransaction(x);return}if(l.vtxos.length===0){this.notificationManager.showError("No funds found in escrow contract");return}const u=l.vtxos[0];console.log("Found VTXO:",u.txid,"with amount:",u.value);const h=this.getRequiredSignersForAction(n,e,r);if(h.length===0){this.notificationManager.showError(`You are not authorized to perform ${n}`);return}const{arkTx:f,checkpoints:p}=await this.createEscrowTransaction(e,n,u);console.log(`Initiator ${this.getUserNameByPubkey(r.pubkey,e)} signing transaction and checkpoints...`);const g=await r.identity.sign(f),w=await Promise.all(p.map(async x=>{const _=await r.identity.sign(x,[0]);return Array.from(_.toPSBT())}));console.log("Initiator signatures added to transaction and checkpoints");const y={action:n,initiator:r.pubkey,timestamp:Date.now(),status:"pending_cosign",partialTx:{vtxo:{txid:u.txid,vout:u.vout,value:u.value},arkTx:Array.from(g.toPSBT()),checkpoints:w,requiredSigners:h.filter(x=>x!==r.pubkey),initiatorSigned:!0,approvals:[r.pubkey],rejections:[]}};this.updateContractPendingTransaction(o.encode(),y);const b=y.partialTx.requiredSigners.map(x=>this.getUserNameByPubkey(x,e)).join(", ");this.notificationManager.showSuccess(`Partial transaction created for ${n}. ${b?`Waiting for cosignature from: ${b}.`:"Ready to execute!"}`)}catch(s){console.error(`Failed to execute ${n}:`,s),this.notificationManager.showError(`Failed to create transaction for ${n}: ${s.message||"Unknown error"}`)}}getUserRole(e,n){return n===e.buyer.pubkey?"buyer":n===e.seller.pubkey?"seller":n===e.arbitrator.pubkey?"arbitrator":null}getRequiredSignersForAction(e,n,r){const s=this.getUserRole(n,r.pubkey);switch(e.toLowerCase()){case"fund":return s==="buyer"?[n.buyer.pubkey]:[];case"release":return s==="seller"||s==="arbitrator"?[n.seller.pubkey,n.arbitrator.pubkey]:[];case"refund":return s==="buyer"||s==="arbitrator"?[n.buyer.pubkey,n.arbitrator.pubkey]:[];case"direct settle":return s==="buyer"||s==="seller"?[n.buyer.pubkey,n.seller.pubkey]:[];default:return[]}}getUserNameByPubkey(e,n){return e===n.buyer.pubkey?n.buyer.name:e===n.seller.pubkey?n.seller.name:e===n.arbitrator.pubkey?n.arbitrator.name:"Unknown User"}async signTransactionsForUser(e,n){var o,a,c;if(!((o=e.pendingTransaction)!=null&&o.partialTx))throw new Error("No pending transaction to sign");const{partialTx:r}=e.pendingTransaction,s=await this.getWalletForSigner(n.pubkey,e);if(!s)throw new Error(`Wallet ${this.getUserNameByPubkey(n.pubkey,e)} is not authorized to sign this transaction`);try{console.log("Signing transactions for user:",this.getUserNameByPubkey(n.pubkey,e)),console.log("arkTx type:",typeof r.arkTx,"length:",(a=r.arkTx)==null?void 0:a.length),console.log("checkpoints count:",(c=r.checkpoints)==null?void 0:c.length);const l=Array.isArray(r.arkTx)?new Uint8Array(r.arkTx):r.arkTx instanceof Uint8Array?r.arkTx:new Uint8Array(r.arkTx);console.log("Before signing - arkTx data length:",l.length);let u=Transaction.fromPSBT(l,{allowUnknown:!0});console.log("Transaction loaded from PSBT, signing with:",this.getUserNameByPubkey(n.pubkey,e)),u=await s.identity.sign(u);const h=u.toPSBT();console.log("After signing - PSBT data length:",h.length),r.arkTx=Array.from(h);const f=await Promise.all(r.checkpoints.map(async p=>{const g=Array.isArray(p)?new Uint8Array(p):p instanceof Uint8Array?p:new Uint8Array(p);let w=Transaction.fromPSBT(g,{allowUnknown:!0});return w=await s.identity.sign(w,[0]),Array.from(w.toPSBT())}));r.checkpoints=f,console.log(`Successfully signed transactions for ${this.getUserNameByPubkey(n.pubkey,e)}`)}catch(l){throw console.error("Failed to sign transactions:",l),console.error("Error details:",{name:l.name,message:l.message,stack:l.stack}),new Error(`Failed to sign transactions: ${l.message}`)}}async getWalletForSigner(e,n){const r=this.walletManager.getCurrentWallet();return r&&r.pubkey===e?r:(console.warn(`Cannot access wallet for signer ${this.getUserNameByPubkey(e,n)} (${e})`),null)}getSpendingPathForAction(e,n){switch(n.toLowerCase()){case"fund":return null;case"release":return e.release();case"refund":return e.refund();case"direct settle":return e.direct();default:return null}}async createEscrowTransaction(e,n,r){const s=this.restoreScript(e),o=this.getSpendingPathForAction(s,n);if(!o&&n.toLowerCase()!=="fund")throw new Error(`Invalid action: ${n}`);const a=this.serverManager.getServerKey(),c=this.serverManager.getUnilateralDelay(),l=CSVMultisigTapscript.encode({pubkeys:[hex$1.decode(a)],timelock:c}),u={txid:r.txid,vout:r.vout,value:r.value,script:s.pkScript,tapTree:s.encode(),tapLeafScript:o},h=this.createOutputsForAction(n,e,r.value);console.log("Building offchain tx with input:",u.txid,"outputs:",h.length),console.log("Input details:",{txid:u.txid,vout:u.vout,value:u.value,hasScript:!!u.script,hasTapTree:!!u.tapTree,hasTapLeafScript:!!u.tapLeafScript}),console.log("Outputs:",h),console.log("ServerUnrollScript type:",typeof l);try{const f=buildOffchainTx([u],h,l);if(console.log("buildOffchainTx result:",f),!f||typeof f!="object")throw new Error("buildOffchainTx returned invalid result");const{arkTx:p,checkpoints:g}=f;if(!p||!g)throw new Error("buildOffchainTx missing arkTx or checkpoints");return{arkTx:p,checkpoints:g}}catch(f){throw console.error("buildOffchainTx failed:",f),new Error(`Failed to build offchain transaction: ${f.message}`)}}createOutputsForAction(e,n,r){switch(e.toLowerCase()){case"release":return[{amount:BigInt(r),script:this.addressToScript(n.seller.address)}];case"refund":return[{amount:BigInt(r),script:this.addressToScript(n.buyer.address)}];case"direct settle":const s=Math.floor(r/2);return[{amount:BigInt(s),script:this.addressToScript(n.buyer.address)},{amount:BigInt(r-s),script:this.addressToScript(n.seller.address)}];default:throw new Error(`Unknown action: ${e}`)}}addressToScript(e){try{return ArkAddress.decode(e).pkScript}catch(n){if(console.error("Failed to convert address to script:",n),typeof e=="string"&&e.length%2===0)try{return hex$1.decode(e)}catch(r){console.error("Failed to hex decode address:",r)}throw new Error(`Cannot convert address to script: ${e}`)}}async approvePendingTransaction(e,n){var s;if(!e.pendingTransaction||!e.pendingTransaction.partialTx){this.notificationManager.showError("No pending transaction to approve");return}const{partialTx:r}=e.pendingTransaction;if(!r.requiredSigners.includes(n.pubkey)){this.notificationManager.showError("You are not required to sign this transaction");return}if(r.approvals.includes(n.pubkey)){this.notificationManager.showError("You have already approved this transaction");return}try{const o=e.pendingTransaction.action;this.notificationManager.showInfo(`Signing ${o} transaction...`),await this.signTransactionsForUser(e,n),r.approvals.push(n.pubkey);const a=[...r.requiredSigners,e.pendingTransaction.initiator],c=a.every(l=>r.approvals.includes(l));if(console.log("Approval check:",{action:e.pendingTransaction.action,requiredSigners:r.requiredSigners.map(l=>`${this.getUserNameByPubkey(l,e)} (${l.slice(0,8)}...)`),initiator:`${this.getUserNameByPubkey(e.pendingTransaction.initiator,e)} (${e.pendingTransaction.initiator.slice(0,8)}...)`,allRequiredSigners:a.map(l=>`${this.getUserNameByPubkey(l,e)} (${l.slice(0,8)}...)`),currentApprovals:r.approvals.map(l=>`${this.getUserNameByPubkey(l,e)} (${l.slice(0,8)}...)`),currentUser:`${this.getUserNameByPubkey(n.pubkey,e)} (${n.pubkey.slice(0,8)}...)`,allApproved:c}),console.log("Contract roles:",{buyer:`${e.buyer.name} (${e.buyer.pubkey.slice(0,8)}...)`,seller:`${e.seller.name} (${e.seller.pubkey.slice(0,8)}...)`,arbitrator:`${e.arbitrator.name} (${e.arbitrator.pubkey.slice(0,8)}...)`}),c)await this.executeMultiSigTransaction(e);else{const u=a.filter(h=>!r.approvals.includes(h)).map(h=>this.getUserNameByPubkey(h,e));this.notificationManager.showSuccess(`Transaction signed and approved. Waiting for signatures from: ${u.join(", ")}.`),await this.updateContractPendingTransaction(e.arkAddress,e.pendingTransaction)}}catch(o){console.error("Failed to approve transaction:",o);const a=((s=e.pendingTransaction)==null?void 0:s.action)||"transaction";this.notificationManager.showError(`Failed to approve ${a}: ${o.message||"Unknown error"}`)}}async executeMultiSigTransaction(e){var s;if(!((s=e.pendingTransaction)!=null&&s.partialTx))throw new Error("No pending transaction to execute");const{partialTx:n}=e.pendingTransaction,r=e.pendingTransaction.action;try{this.notificationManager.showInfo(`All signatures collected. Executing ${r}...`);const o=this.serverManager.getProvider();if(!o)throw new Error("Not connected to Ark server");const{Transaction:a}=await __vitePreload(()=>import("./index-f5cc105b.js"),[]),{base64:c}=await __vitePreload(()=>Promise.resolve().then(()=>index),void 0),l=Array.isArray(n.arkTx)?new Uint8Array(n.arkTx):n.arkTx,u=a.fromPSBT(l,{allowUnknown:!0});console.log("Submitting fully-signed transaction to Ark network...");const h=n.checkpoints.map(g=>Array.isArray(g)?new Uint8Array(g):g),{arkTxid:f}=await o.submitTx(c.encode(u.toPSBT()),h.map(g=>c.encode(g)));console.log(`Successfully submitted ${r}! Transaction ID:`,f),this.notificationManager.showSuccess(`${r} transaction submitted! ID: ${f}`),console.log("Using pre-signed checkpoints for finalization...");const p=h.map(g=>c.encode(g));await o.finalizeTx(f,p),console.log(`Successfully finalized ${r}!`),this.notificationManager.showSuccess(`${r} transaction finalized successfully!`),e.pendingTransaction=void 0,await this.updateContractPendingTransaction(e.arkAddress,void 0)}catch(o){console.error("Failed to execute multi-sig transaction:",o),this.notificationManager.showError(`Failed to execute ${r}: ${o.message||"Unknown error"}`)}}async rejectPendingTransaction(e,n){if(!e.pendingTransaction||!e.pendingTransaction.partialTx){this.notificationManager.showError("No pending transaction to reject");return}const{partialTx:r}=e.pendingTransaction;if(!r.requiredSigners.includes(n.pubkey)){this.notificationManager.showError("You are not authorized to reject this transaction");return}r.rejections.includes(n.pubkey)||r.rejections.push(n.pubkey),e.pendingTransaction.status="rejected",this.notificationManager.showSuccess(`Transaction rejected by ${this.getUserNameByPubkey(n.pubkey,e)}`),setTimeout(()=>{e.pendingTransaction=void 0,this.updateContractPendingTransaction(e.arkAddress,void 0),this.notificationManager.showInfo("Rejected transaction cleared")},3e3),this.updateContractPendingTransaction(e.arkAddress,e.pendingTransaction)}async updateContractPendingTransaction(e,n){try{const r=this.contracts.get(e);r&&(r.pendingTransaction=n,this.contracts.set(e,r),await this.communicationProvider.updateContract(r),n&&await this.communicationProvider.notifyPendingTransaction(e,n))}catch(r){console.error("Failed to update contract pending transaction:",r)}}}class UIManager{constructor(e,n,r,s,o){this.elements=e,this.walletManager=n,this.userManager=r,this.contractManager=s,this.serverManager=o}hideMainUI(){this.elements.walletInfo.style.display="none",this.hideWalletDependentSections()}showMainUI(){this.elements.walletInfo.style.display="block",this.walletManager.getCurrentWallet()?this.showWalletDependentSections():this.hideWalletDependentSections()}hideWalletDependentSections(){const e=this.findSectionByHeadingText("Transactions");e&&(e.style.display="none");const n=this.findSectionByHeadingText("Escrow Contracts");n&&(n.style.display="none"),this.elements.usersList.parentElement.style.display="none"}showWalletDependentSections(){const e=this.findSectionByHeadingText("Transactions");e&&(e.style.display="block");const n=this.findSectionByHeadingText("Escrow Contracts");n&&(n.style.display="block"),this.elements.usersList.parentElement.style.display="block"}findSectionByHeadingText(e){var r;const n=document.querySelectorAll("section h2");for(const s of n)if((r=s.textContent)!=null&&r.includes(e))return s.closest("section");return null}updateWalletDependentUI(){this.walletManager.getCurrentWallet()?this.showWalletDependentSections():this.hideWalletDependentSections()}showImportForm(){this.elements.importForm.style.display="block",this.elements.privateKey.focus()}hideImportForm(){this.elements.importForm.style.display="none",this.elements.privateKey.value=""}showSendForm(){this.elements.sendForm.style.display="block",this.elements.sendAddress.focus()}hideSendForm(){this.elements.sendForm.style.display="none",this.elements.sendAddress.value="",this.elements.sendAmount.value=""}updateWalletUI(){const e=this.walletManager.getCurrentWallet();e?(this.elements.createWallet.style.display="none",this.elements.importWallet.style.display="none",this.elements.walletAddress.textContent=e.arkAddress,this.elements.walletPubkey.textContent=e.pubkey,this.elements.walletPrivkey.textContent="",this.elements.walletPrivkey.dataset.privkey=e.privateKey,this.elements.walletPrivkey.dataset.hidden="true",this.elements.walletInfo.classList.remove("hidden"),this.elements.walletInfo.style.display="block",this.userManager.autoRegisterUser(e),this.updateUsersUI(),this.updateContractsUI(),this.updateBalanceUI()):(this.elements.createWallet.style.display="inline-block",this.elements.importWallet.style.display="inline-block",this.elements.walletInfo.style.display="none")}async updateBalanceUI(e){if(!e)try{e=await this.walletManager.refreshBalance()}catch(n){console.error("Error fetching balance:",n);return}if(e){const n=e.available||e.settled||e.preconfirmed||0;let r=0;e.boarding&&e.boarding.amount?r=e.boarding.amount:e.boarding&&e.boarding.value&&(r=e.boarding.value);const s=n+r;this.elements.walletBalance.textContent=`${s} sats`;const o=[];e.coins&&e.coins.length>0&&o.push(...e.coins),e.boarding&&(Array.isArray(e.boarding)?o.push(...e.boarding):typeof e.boarding=="object"&&o.push({...e.boarding,value:r,isBoarding:!0})),this.updateCoinsDisplay(o)}else this.elements.walletBalance.textContent="Unknown",this.elements.walletCoins.textContent="No coins available"}updateCoinsDisplay(e){}async refreshCoinsDisplay(){if(!this.walletManager.getCurrentWallet()){console.log("refreshCoinsDisplay: No wallet available");return}try{console.log("refreshCoinsDisplay: Fetching balance...");const n=await this.walletManager.refreshBalance();console.log("refreshCoinsDisplay: Balance received:",n),n&&n.coins&&n.coins.length>0?(console.log("refreshCoinsDisplay: Coins found:",n.coins),this.updateCoinsDisplay(n.coins)):(console.log("refreshCoinsDisplay: No coins in balance object"),this.elements.walletCoins.textContent="No coins available")}catch(n){console.error("Error refreshing coins:",n),this.elements.walletCoins.textContent="Error loading coins"}}updateUsersUI(){this.userManager.refreshUsers();const e=this.userManager.getUsers(),n=this.walletManager.getCurrentWallet();if(this.elements.usersList.innerHTML="",e.length===0){this.elements.usersList.innerHTML='<p class="no-users">No users connected</p>',this.updateContractSelects([]);return}e.forEach(r=>{const s=document.createElement("div");s.className="user-item";const o=n&&r.pubkey===n.pubkey;o&&s.classList.add("current-user"),s.innerHTML=`
                <div class="user-info">
                    <div class="user-name">${r.name} ${o?"(You)":""}</div>
                    <div class="user-details">
                        <span class="user-pubkey">${r.pubkey.slice(0,16)}...</span>
                        <span class="user-address">${r.address.slice(0,16)}...</span>
                    </div>
                </div>
            `,this.elements.usersList.appendChild(s)}),this.updateContractSelects(e),e.length>0&&this.showToast(`Found ${e.length} connected users`)}updateContractSelects(e){[this.elements.buyerSelect,this.elements.sellerSelect,this.elements.arbitratorSelect].forEach(r=>{const s=r.value;r.innerHTML='<option value="">Select user...</option>',e.forEach(o=>{const a=document.createElement("option");a.value=o.pubkey,a.textContent=o.name,r.appendChild(a)}),s&&(r.value=s)})}getUserNameByPubkey(e){const r=this.userManager.getUsers().find(s=>s.pubkey===e);return r?r.name:"Unknown User"}async updateContractsUI(){const e=this.walletManager.getCurrentWallet();if(!e){this.elements.contractsList.innerHTML='<p class="no-contracts">Please create or import a wallet to view contracts</p>';return}const n=this.contractManager.getContractsForUser(e.pubkey);if(this.elements.contractsList.innerHTML="",n.length===0){this.elements.contractsList.innerHTML='<p class="no-contracts">No contracts found where you are involved</p>';return}for(const[r,s]of n.entries()){const o=document.createElement("div");o.className="contract-item";const a=this.userManager.getCurrentUserRole(s,e),c=await this.contractManager.getEscrowState(s),l=this.contractManager.getAvailableActions(c,a),u=l.length>0?l.map(f=>`<button class="action-btn" onclick="window.arkApp.executeContractAction(${r}, '${f}')">${f}</button>`).join(" "):'<p class="no-actions">No actions available</p>';let h="";if(s.pendingTransaction&&s.pendingTransaction.partialTx){const{pendingTransaction:f}=s,p=f.partialTx;if(!p)return;const g=this.getUserNameByPubkey(f.initiator),w=this.walletManager.getCurrentWallet(),y=w&&p.requiredSigners.includes(w.pubkey)&&!p.approvals.includes(w.pubkey)&&!p.rejections.includes(w.pubkey)&&f.status==="pending_cosign",b=p.approvals.length,x=p.requiredSigners.length+1;h=`
                    <div class="pending-tx ${f.status}">
                        <p><strong>Pending ${f.action}</strong> (initiated by ${g})</p>
                        <p>Approvals: ${b}/${x}</p>
                        ${y?`
                            <div class="pending-actions">
                                <button class="btn btn-success" onclick="window.arkApp.approvePendingTransaction(${r})"> Approve</button>
                                <button class="btn btn-danger" onclick="window.arkApp.rejectPendingTransaction(${r})"> Reject</button>
                            </div>
                        `:""}
                        ${f.status==="approved"?'<p class="status-approved"> Approved - Executing...</p>':""}
                        ${f.status==="rejected"?'<p class="status-rejected"> Rejected</p>':""}
                    </div>
                `}o.innerHTML=`
                <div class="contract-header">
                    <h4>Contract #${r+1}</h4>
                    <span class="contract-status ${c.status}">${c.status}</span>
                </div>
                <div class="contract-details">
                    <p><strong>Description:</strong> ${s.description}</p>
                    <p><strong>Ark Address:</strong> <code>${s.arkAddress||"Not available"}</code></p>
                    ${c.balance&&c.balance>0?`<p><strong>Balance:</strong> ${c.balance} sats</p>`:""}
                    <p><strong>Buyer:</strong> ${s.buyer.name}</p>
                    <p><strong>Seller:</strong> ${s.seller.name}</p>
                    <p><strong>Arbitrator:</strong> ${s.arbitrator.name}</p>
                    ${a?`<p><strong>Your Role:</strong> ${a}</p>`:""}
                    ${h}
                </div>
                <div class="contract-actions">
                    ${u}
                </div>
            `,this.elements.contractsList.appendChild(o)}}clearContractForm(){this.elements.buyerSelect.value="",this.elements.sellerSelect.value="",this.elements.arbitratorSelect.value="",this.elements.contractDescription.value=""}updateServerUI(e){const n=document.getElementById("serverStatus"),r=document.getElementById("arkServerUrl"),s=document.getElementById("connectServer");if(e){const o=this.serverManager.getNetworkInfo()||"unknown";n.innerHTML=`
                <span class="badge badge-success">Connected</span>
                <span class="badge badge-info">${o}</span>
            `,r.disabled=!0,s.textContent="Disconnect",s.classList.remove("btn-primary"),s.classList.add("btn-secondary")}else n.innerHTML="",r.disabled=!1,s.textContent="Connect",s.classList.remove("btn-secondary"),s.classList.add("btn-primary")}async copyAddress(){const e=this.walletManager.getCurrentWallet();e&&await navigator.clipboard.writeText(e.arkAddress)}copyPrivkey(){const e=this.walletManager.getCurrentWallet();e&&e.privateKey&&(this.elements.walletPrivkey.dataset.hidden==="true"&&this.togglePrivkeyVisibility(),navigator.clipboard.writeText(e.privateKey).then(()=>{this.showToast("Private key copied to clipboard!")}).catch(n=>{console.error("Failed to copy private key:",n),this.showToast("Failed to copy private key","error")}))}togglePrivkeyVisibility(){const e=this.elements.walletPrivkey,n=this.walletManager.getCurrentWallet();!n||!n.privateKey||(e.dataset.hidden==="true"?(e.textContent=n.privateKey,e.dataset.hidden="false",this.elements.hidePrivkey.textContent="Hide"):(e.textContent="",e.dataset.hidden="true",this.elements.hidePrivkey.textContent="Show"))}showToast(e,n="success"){const r=document.createElement("div");r.className=`toast toast-${n}`,r.textContent=e,document.body.appendChild(r),setTimeout(()=>{r.classList.add("show")},10),setTimeout(()=>{r.classList.remove("show"),setTimeout(()=>{document.body.removeChild(r)},300)},3e3)}}class LocalStorageCommunication{constructor(){this.userCallbacks=[],this.contractCallbacks=[],this.pendingTxCallbacks=[]}async initialize(){this.storageListener=e=>{e.key==="arkUsers"?(console.log("Users updated in another tab, syncing..."),this.notifyUserCallbacks()):e.key==="arkContracts"?(console.log("Contracts updated in another tab, syncing..."),this.notifyContractCallbacks()):e.key==="ark-partial-transactions"&&(console.log("Partial transactions updated in another tab, syncing..."),this.notifyContractCallbacks())},window.addEventListener("storage",this.storageListener),console.log("LocalStorage communication provider initialized")}cleanup(){this.storageListener&&window.removeEventListener("storage",this.storageListener),this.userCallbacks=[],this.contractCallbacks=[],this.pendingTxCallbacks=[],console.log("LocalStorage communication provider cleaned up")}async publishUser(e){try{const n=await this.getUsers(),r=n.findIndex(s=>s.pubkey===e.pubkey);r>=0?n[r]=e:n.push(e),localStorage.setItem("ark-escrow-users",JSON.stringify(n)),localStorage.setItem("arkUsers",Date.now().toString()),this.notifyUserCallbacks()}catch(n){throw console.error("Failed to publish user:",n),n}}subscribeToUsers(e){this.userCallbacks.push(e),this.getUsers().then(n=>e(n)).catch(console.error)}async getUsers(){try{const e=localStorage.getItem("ark-escrow-users");return e?JSON.parse(e):[]}catch(e){return console.error("Failed to load users from localStorage:",e),[]}}async publishContract(e){try{const n=await this.getContracts(),r=n.findIndex(s=>s.arkAddress===e.arkAddress);r>=0?n[r]=e:n.push(e),localStorage.setItem("arkContracts",JSON.stringify(n)),this.notifyContractCallbacks()}catch(n){throw console.error("Failed to publish contract:",n),n}}subscribeToContracts(e){this.contractCallbacks.push(e),this.getContracts().then(n=>e(n)).catch(console.error)}async getContracts(){try{const e=localStorage.getItem("arkContracts");return e?JSON.parse(e):[]}catch(e){return console.error("Failed to load contracts from localStorage:",e),[]}}async updateContract(e){await this.publishContract(e)}async notifyPendingTransaction(e,n){this.notifyContractCallbacks(),this.pendingTxCallbacks.forEach(r=>{try{r(e,n)}catch(s){console.error("Error in pending transaction callback:",s)}})}subscribeToPendingTransactions(e){this.pendingTxCallbacks.push(e)}async notifyUserCallbacks(){try{const e=await this.getUsers();this.userCallbacks.forEach(n=>{try{n(e)}catch(r){console.error("Error in user callback:",r)}})}catch(e){console.error("Failed to notify user callbacks:",e)}}async notifyContractCallbacks(){try{const e=await this.getContracts();this.contractCallbacks.forEach(n=>{try{n(e)}catch(r){console.error("Error in contract callback:",r)}})}catch(e){console.error("Failed to notify contract callbacks:",e)}}}var lib$1={},types={};Object.defineProperty(types,"__esModule",{value:!0});var ee={},taskCollection$1={},taskCollection={},utils$1={};Object.defineProperty(utils$1,"__esModule",{value:!0});utils$1._fast_remove_single=void 0;function _fast_remove_single(t,e){e!==-1&&(e===0?t.shift():e===t.length-1?t.length=t.length-1:t.splice(e,1))}utils$1._fast_remove_single=_fast_remove_single;var bakeCollection={};(function(exports){Object.defineProperty(exports,"__esModule",{value:!0}),exports.bakeCollectionVariadic=exports.bakeCollectionAwait=exports.bakeCollection=exports.BAKED_EMPTY_FUNC=void 0,exports.BAKED_EMPTY_FUNC=function(){};var FORLOOP_FALLBACK=1500;function generateArgsDefCode(t){var e="";if(t===0)return e;for(var n=0;n<t-1;++n)e+="arg"+String(n)+", ";return e+="arg"+String(t-1),e}function generateBodyPartsCode(t,e){for(var n="",r="",s=0;s<e;++s)n+="var f".concat(s," = collection[").concat(s,`];
`),r+="f".concat(s,"(").concat(t,`)
`);return{funcDefCode:n,funcCallCode:r}}function generateBodyPartsVariadicCode(t){for(var e="",n="",r=0;r<t;++r)e+="var f".concat(r," = collection[").concat(r,`];
`),n+="f".concat(r,`.apply(undefined, arguments)
`);return{funcDefCode:e,funcCallCode:n}}function bakeCollection(collection,fixedArgsNum){if(collection.length===0)return exports.BAKED_EMPTY_FUNC;if(collection.length===1)return collection[0];var funcFactoryCode;if(collection.length<FORLOOP_FALLBACK){var argsDefCode=generateArgsDefCode(fixedArgsNum),_a=generateBodyPartsCode(argsDefCode,collection.length),funcDefCode=_a.funcDefCode,funcCallCode=_a.funcCallCode;funcFactoryCode=`(function(collection) {
            `.concat(funcDefCode,`
            collection = undefined;
            return (function(`).concat(argsDefCode,`) {
                `).concat(funcCallCode,`
            });
        })`)}else{var argsDefCode=generateArgsDefCode(fixedArgsNum);collection.length%10===0?funcFactoryCode=`(function(collection) {
                return (function(`.concat(argsDefCode,`) {
                    for (var i = 0; i < collection.length; i += 10) {
                        collection[i](`).concat(argsDefCode,`);
                        collection[i+1](`).concat(argsDefCode,`);
                        collection[i+2](`).concat(argsDefCode,`);
                        collection[i+3](`).concat(argsDefCode,`);
                        collection[i+4](`).concat(argsDefCode,`);
                        collection[i+5](`).concat(argsDefCode,`);
                        collection[i+6](`).concat(argsDefCode,`);
                        collection[i+7](`).concat(argsDefCode,`);
                        collection[i+8](`).concat(argsDefCode,`);
                        collection[i+9](`).concat(argsDefCode,`);
                    }
                });
            })`):collection.length%4===0?funcFactoryCode=`(function(collection) {
                return (function(`.concat(argsDefCode,`) {
                    for (var i = 0; i < collection.length; i += 4) {
                        collection[i](`).concat(argsDefCode,`);
                        collection[i+1](`).concat(argsDefCode,`);
                        collection[i+2](`).concat(argsDefCode,`);
                        collection[i+3](`).concat(argsDefCode,`);
                    }
                });
            })`):collection.length%3===0?funcFactoryCode=`(function(collection) {
                return (function(`.concat(argsDefCode,`) {
                    for (var i = 0; i < collection.length; i += 3) {
                        collection[i](`).concat(argsDefCode,`);
                        collection[i+1](`).concat(argsDefCode,`);
                        collection[i+2](`).concat(argsDefCode,`);
                    }
                });
            })`):funcFactoryCode=`(function(collection) {
                return (function(`.concat(argsDefCode,`) {
                    for (var i = 0; i < collection.length; ++i) {
                        collection[i](`).concat(argsDefCode,`);
                    }
                });
            })`)}{var funcFactory=eval(funcFactoryCode);return funcFactory(collection)}}exports.bakeCollection=bakeCollection;function bakeCollectionAwait(collection,fixedArgsNum){if(collection.length===0)return exports.BAKED_EMPTY_FUNC;if(collection.length===1)return collection[0];var funcFactoryCode;if(collection.length<FORLOOP_FALLBACK){var argsDefCode=generateArgsDefCode(fixedArgsNum),_a=generateBodyPartsCode(argsDefCode,collection.length),funcDefCode=_a.funcDefCode,funcCallCode=_a.funcCallCode;funcFactoryCode=`(function(collection) {
            `.concat(funcDefCode,`
            collection = undefined;
            return (function(`).concat(argsDefCode,`) {
                return Promise.all([ `).concat(funcCallCode,` ]);
            });
        })`)}else{var argsDefCode=generateArgsDefCode(fixedArgsNum);funcFactoryCode=`(function(collection) {
            return (function(`.concat(argsDefCode,`) {
                var promises = Array(collection.length);
                for (var i = 0; i < collection.length; ++i) {
                    promises[i] = collection[i](`).concat(argsDefCode,`);
                }
                return Promise.all(promises);
            });
        })`)}{var funcFactory=eval(funcFactoryCode);return funcFactory(collection)}}exports.bakeCollectionAwait=bakeCollectionAwait;function bakeCollectionVariadic(collection){if(collection.length===0)return exports.BAKED_EMPTY_FUNC;if(collection.length===1)return collection[0];var funcFactoryCode;if(collection.length<FORLOOP_FALLBACK){var _a=generateBodyPartsVariadicCode(collection.length),funcDefCode=_a.funcDefCode,funcCallCode=_a.funcCallCode;funcFactoryCode=`(function(collection) {
            `.concat(funcDefCode,`
            collection = undefined;
            return (function() {
                `).concat(funcCallCode,`
            });
        })`)}else funcFactoryCode=`(function(collection) {
            return (function() {
                for (var i = 0; i < collection.length; ++i) {
                    collection[i].apply(undefined, arguments);
                }
            });
        })`;{var funcFactory=eval(funcFactoryCode);return funcFactory(collection)}}exports.bakeCollectionVariadic=bakeCollectionVariadic})(bakeCollection);var __spreadArray$1=commonjsGlobal&&commonjsGlobal.__spreadArray||function(t,e,n){if(n||arguments.length===2)for(var r=0,s=e.length,o;r<s;r++)(o||!(r in e))&&(o||(o=Array.prototype.slice.call(e,0,r)),o[r]=e[r]);return t.concat(o||Array.prototype.slice.call(e))};Object.defineProperty(taskCollection,"__esModule",{value:!0});taskCollection.TaskCollection=void 0;var utils_1$1=utils$1,bake_collection_1=bakeCollection;function push_norebuild(t,e){var n=this.length;if(n>1)if(e){var r;(r=this._tasks).push.apply(r,arguments),this.length+=arguments.length}else this._tasks.push(t),this.length++;else if(e){if(n===1){var s=Array(1+arguments.length);s.push(s),s.push.apply(s,arguments),this._tasks=s}else{var s=Array(arguments.length);s.push.apply(s,arguments),this._tasks=s}this.length+=arguments.length}else n===1?this._tasks=[this._tasks,t]:this._tasks=t,this.length++}function push_rebuild(t,e){var n=this.length;if(n>1)if(e){var r;(r=this._tasks).push.apply(r,arguments),this.length+=arguments.length}else this._tasks.push(t),this.length++;else if(e){if(n===1){var s=Array(1+arguments.length);s.push(s),s.push.apply(s,arguments),this._tasks=s}else{var s=Array(arguments.length);s.push.apply(s,arguments),this._tasks=s}this.length+=arguments.length}else n===1?this._tasks=[this._tasks,t]:this._tasks=t,this.length++;this.firstEmitBuildStrategy?this.call=rebuild_on_first_call:this.rebuild()}function removeLast_norebuild(t){this.length!==0&&(this.length===1?this._tasks===t&&(this.length=0):((0,utils_1$1._fast_remove_single)(this._tasks,this._tasks.lastIndexOf(t)),this._tasks.length===1?(this._tasks=this._tasks[0],this.length=1):this.length=this._tasks.length))}function removeLast_rebuild(t){if(this.length!==0){if(this.length===1)if(this._tasks===t&&(this.length=0),this.firstEmitBuildStrategy){this.call=bake_collection_1.BAKED_EMPTY_FUNC;return}else{this.rebuild();return}else(0,utils_1$1._fast_remove_single)(this._tasks,this._tasks.lastIndexOf(t)),this._tasks.length===1?(this._tasks=this._tasks[0],this.length=1):this.length=this._tasks.length;this.firstEmitBuildStrategy?this.call=rebuild_on_first_call:this.rebuild()}}function insert_norebuild(t){for(var e,n=[],r=1;r<arguments.length;r++)n[r-1]=arguments[r];this.length===0?(this._tasks=n,this.length=1):this.length===1?(n.unshift(this._tasks),this._tasks=n,this.length=this._tasks.length):((e=this._tasks).splice.apply(e,__spreadArray$1([t,0],n,!1)),this.length=this._tasks.length)}function insert_rebuild(t){for(var e,n=[],r=1;r<arguments.length;r++)n[r-1]=arguments[r];this.length===0?(this._tasks=n,this.length=1):this.length===1?(n.unshift(this._tasks),this._tasks=n,this.length=this._tasks.length):((e=this._tasks).splice.apply(e,__spreadArray$1([t,0],n,!1)),this.length=this._tasks.length),this.firstEmitBuildStrategy?this.call=rebuild_on_first_call:this.rebuild()}function rebuild_noawait(){this.length===0?this.call=bake_collection_1.BAKED_EMPTY_FUNC:this.length===1?this.call=this._tasks:this.call=(0,bake_collection_1.bakeCollection)(this._tasks,this.argsNum)}function rebuild_await(){this.length===0?this.call=bake_collection_1.BAKED_EMPTY_FUNC:this.length===1?this.call=this._tasks:this.call=(0,bake_collection_1.bakeCollectionAwait)(this._tasks,this.argsNum)}function rebuild_on_first_call(){this.rebuild(),this.call.apply(void 0,arguments)}var TaskCollection=function(){function t(e,n,r,s){n===void 0&&(n=!0),r===void 0&&(r=null),s===void 0&&(s=!1),this.awaitTasks=s,this.call=bake_collection_1.BAKED_EMPTY_FUNC,this.argsNum=e,this.firstEmitBuildStrategy=!0,s?this.rebuild=rebuild_await.bind(this):this.rebuild=rebuild_noawait.bind(this),this.setAutoRebuild(n),r?typeof r=="function"?(this._tasks=r,this.length=1):(this._tasks=r,this.length=r.length):(this._tasks=null,this.length=0),n&&this.rebuild()}return t}();taskCollection.TaskCollection=TaskCollection;function fastClear(){this._tasks=null,this.length=0,this.call=bake_collection_1.BAKED_EMPTY_FUNC}function clear(){this._tasks=null,this.length=0,this.call=bake_collection_1.BAKED_EMPTY_FUNC}function growArgsNum(t){this.argsNum<t&&(this.argsNum=t,this.firstEmitBuildStrategy?this.call=rebuild_on_first_call:this.rebuild())}function setAutoRebuild(t){t?(this.push=push_rebuild.bind(this),this.insert=insert_rebuild.bind(this),this.removeLast=removeLast_rebuild.bind(this)):(this.push=push_norebuild.bind(this),this.insert=insert_norebuild.bind(this),this.removeLast=removeLast_norebuild.bind(this))}function tasksAsArray(){return this.length===0?[]:this.length===1?[this._tasks]:this._tasks}function setTasks(t){t.length===0?(this.length=0,this.call=bake_collection_1.BAKED_EMPTY_FUNC):t.length===1?(this.length=1,this.call=t[0],this._tasks=t[0]):(this.length=t.length,this._tasks=t,this.firstEmitBuildStrategy?this.call=rebuild_on_first_call:this.rebuild())}TaskCollection.prototype.fastClear=fastClear;TaskCollection.prototype.clear=clear;TaskCollection.prototype.growArgsNum=growArgsNum;TaskCollection.prototype.setAutoRebuild=setAutoRebuild;TaskCollection.prototype.tasksAsArray=tasksAsArray;TaskCollection.prototype.setTasks=setTasks;(function(t){var e=commonjsGlobal&&commonjsGlobal.__createBinding||(Object.create?function(r,s,o,a){a===void 0&&(a=o);var c=Object.getOwnPropertyDescriptor(s,o);(!c||("get"in c?!s.__esModule:c.writable||c.configurable))&&(c={enumerable:!0,get:function(){return s[o]}}),Object.defineProperty(r,a,c)}:function(r,s,o,a){a===void 0&&(a=o),r[a]=s[o]}),n=commonjsGlobal&&commonjsGlobal.__exportStar||function(r,s){for(var o in r)o!=="default"&&!Object.prototype.hasOwnProperty.call(s,o)&&e(s,r,o)};Object.defineProperty(t,"__esModule",{value:!0}),n(taskCollection,t)})(taskCollection$1);var utils={};Object.defineProperty(utils,"__esModule",{value:!0});utils.nullObj=void 0;function nullObj(){var t={};return t.__proto__=null,t}utils.nullObj=nullObj;var __spreadArray=commonjsGlobal&&commonjsGlobal.__spreadArray||function(t,e,n){if(n||arguments.length===2)for(var r=0,s=e.length,o;r<s;r++)(o||!(r in e))&&(o||(o=Array.prototype.slice.call(e,0,r)),o[r]=e[r]);return t.concat(o||Array.prototype.slice.call(e))};Object.defineProperty(ee,"__esModule",{value:!0});ee.EventEmitter=void 0;var task_collection_1=taskCollection$1,utils_1=utils$1,utils_2=utils;function emit(t,e,n,r,s,o){var a=this.events[t];if(a){if(a.length===0)return!1;if(a.argsNum<6)a.call(e,n,r,s,o);else{for(var c=new Array(a.argsNum),l=0,u=c.length;l<u;++l)c[l]=arguments[l+1];a.call.apply(void 0,c)}return!0}return!1}function emitHasOnce(t,e,n,r,s,o){var a=this.events[t],c;if(a!==void 0){if(a.length===0)return!1;if(a.argsNum<6)a.call(e,n,r,s,o);else{c=new Array(a.argsNum);for(var l=0,u=c.length;l<u;++l)c[l]=arguments[l+1];a.call.apply(void 0,c)}}var h=this.onceEvents[t];if(h){if(typeof h=="function")if(this.onceEvents[t]=void 0,arguments.length<6)h(e,n,r,s,o);else{if(c===void 0){c=new Array(arguments.length-1);for(var l=0,u=c.length;l<u;++l)c[l]=arguments[l+1]}h.apply(void 0,c)}else{var f=h;if(this.onceEvents[t]=void 0,arguments.length<6)for(var l=0;l<f.length;++l)f[l](e,n,r,s,o);else{if(c===void 0){c=new Array(arguments.length-1);for(var l=0,u=c.length;l<u;++l)c[l]=arguments[l+1]}for(var l=0;l<f.length;++l)f[l].apply(void 0,c)}}return!0}return a!==void 0}var EventEmitter=function(){function t(){this.events=(0,utils_2.nullObj)(),this.onceEvents=(0,utils_2.nullObj)(),this._symbolKeys=new Set,this.maxListeners=1/0}return Object.defineProperty(t.prototype,"_eventsCount",{get:function(){return this.eventNames().length},enumerable:!1,configurable:!0}),t}();ee.EventEmitter=EventEmitter;function once(t,e){switch(this.emit===emit&&(this.emit=emitHasOnce),typeof this.onceEvents[t]){case"undefined":this.onceEvents[t]=e,typeof t=="symbol"&&this._symbolKeys.add(t);break;case"function":this.onceEvents[t]=[this.onceEvents[t],e];break;case"object":this.onceEvents[t].push(e)}return this}function addListener(t,e,n){if(n===void 0&&(n=e.length),typeof e!="function")throw new TypeError("The listener must be a function");var r=this.events[t];return r?(r.push(e),r.growArgsNum(n),this.maxListeners!==1/0&&this.maxListeners<=r.length&&console.warn('Maximum event listeners for "'.concat(String(t),'" event!'))):(this.events[t]=new task_collection_1.TaskCollection(n,!0,e,!1),typeof t=="symbol"&&this._symbolKeys.add(t)),this}function removeListener(t,e){var n=this.events[t];n&&n.removeLast(e);var r=this.onceEvents[t];return r&&(typeof r=="function"?this.onceEvents[t]=void 0:typeof r=="object"&&(r.length===1&&r[0]===e?this.onceEvents[t]=void 0:(0,utils_1._fast_remove_single)(r,r.lastIndexOf(e)))),this}function addListenerBound(t,e,n,r){n===void 0&&(n=this),r===void 0&&(r=e.length),this.boundFuncs||(this.boundFuncs=new Map);var s=e.bind(n);return this.boundFuncs.set(e,s),this.addListener(t,s,r)}function removeListenerBound(t,e){var n,r,s=(n=this.boundFuncs)===null||n===void 0?void 0:n.get(e);return(r=this.boundFuncs)===null||r===void 0||r.delete(e),this.removeListener(t,s)}function hasListeners(t){return this.events[t]&&!!this.events[t].length}function prependListener(t,e,n){if(n===void 0&&(n=e.length),typeof e!="function")throw new TypeError("The listener must be a function");var r=this.events[t];return!r||!(r instanceof task_collection_1.TaskCollection)?(r=this.events[t]=new task_collection_1.TaskCollection(n,!0,e,!1),typeof t=="symbol"&&this._symbolKeys.add(t)):(r.insert(0,e),r.growArgsNum(n),this.maxListeners!==1/0&&this.maxListeners<=r.length&&console.warn('Maximum event listeners for "'.concat(String(t),'" event!'))),this}function prependOnceListener(t,e){this.emit===emit&&(this.emit=emitHasOnce);var n=this.onceEvents[t];return n?typeof n!="object"?(this.onceEvents[t]=[e,n],typeof t=="symbol"&&this._symbolKeys.add(t)):(n.unshift(e),this.maxListeners!==1/0&&this.maxListeners<=n.length&&console.warn('Maximum event listeners for "'.concat(String(t),'" once event!'))):(this.onceEvents[t]=[e],typeof t=="symbol"&&this._symbolKeys.add(t)),this}function removeAllListeners(t){return t===void 0?(this.events=(0,utils_2.nullObj)(),this.onceEvents=(0,utils_2.nullObj)(),this._symbolKeys=new Set):(this.events[t]=void 0,this.onceEvents[t]=void 0,typeof t=="symbol"&&this._symbolKeys.delete(t)),this}function setMaxListeners(t){return this.maxListeners=t,this}function getMaxListeners(){return this.maxListeners}function listeners(t){return this.emit===emit?this.events[t]?this.events[t].tasksAsArray().slice():[]:this.events[t]&&this.onceEvents[t]?__spreadArray(__spreadArray([],this.events[t].tasksAsArray(),!0),typeof this.onceEvents[t]=="function"?[this.onceEvents[t]]:this.onceEvents[t],!0):this.events[t]?this.events[t].tasksAsArray():this.onceEvents[t]?typeof this.onceEvents[t]=="function"?[this.onceEvents[t]]:this.onceEvents[t]:[]}function eventNames(){var t=this;if(this.emit===emit){var e=Object.keys(this.events);return __spreadArray(__spreadArray([],e,!0),Array.from(this._symbolKeys),!0).filter(function(r){return r in t.events&&t.events[r]&&t.events[r].length})}else{var e=Object.keys(this.events).filter(function(s){return t.events[s]&&t.events[s].length}),n=Object.keys(this.onceEvents).filter(function(s){return t.onceEvents[s]&&t.onceEvents[s].length});return __spreadArray(__spreadArray(__spreadArray([],e,!0),n,!0),Array.from(this._symbolKeys).filter(function(s){return s in t.events&&t.events[s]&&t.events[s].length||s in t.onceEvents&&t.onceEvents[s]&&t.onceEvents[s].length}),!0)}}function listenerCount(t){return this.emit===emit?this.events[t]&&this.events[t].length||0:(this.events[t]&&this.events[t].length||0)+(this.onceEvents[t]&&this.onceEvents[t].length||0)}EventEmitter.prototype.emit=emit;EventEmitter.prototype.on=addListener;EventEmitter.prototype.once=once;EventEmitter.prototype.addListener=addListener;EventEmitter.prototype.removeListener=removeListener;EventEmitter.prototype.addListenerBound=addListenerBound;EventEmitter.prototype.removeListenerBound=removeListenerBound;EventEmitter.prototype.hasListeners=hasListeners;EventEmitter.prototype.prependListener=prependListener;EventEmitter.prototype.prependOnceListener=prependOnceListener;EventEmitter.prototype.off=removeListener;EventEmitter.prototype.removeAllListeners=removeAllListeners;EventEmitter.prototype.setMaxListeners=setMaxListeners;EventEmitter.prototype.getMaxListeners=getMaxListeners;EventEmitter.prototype.listeners=listeners;EventEmitter.prototype.eventNames=eventNames;EventEmitter.prototype.listenerCount=listenerCount;(function(t){var e=commonjsGlobal&&commonjsGlobal.__createBinding||(Object.create?function(r,s,o,a){a===void 0&&(a=o);var c=Object.getOwnPropertyDescriptor(s,o);(!c||("get"in c?!s.__esModule:c.writable||c.configurable))&&(c={enumerable:!0,get:function(){return s[o]}}),Object.defineProperty(r,a,c)}:function(r,s,o,a){a===void 0&&(a=o),r[a]=s[o]}),n=commonjsGlobal&&commonjsGlobal.__exportStar||function(r,s){for(var o in r)o!=="default"&&!Object.prototype.hasOwnProperty.call(s,o)&&e(s,r,o)};Object.defineProperty(t,"__esModule",{value:!0}),n(types,t),n(ee,t)})(lib$1);var browser={exports:{}},ms,hasRequiredMs;function requireMs(){if(hasRequiredMs)return ms;hasRequiredMs=1;var t=1e3,e=t*60,n=e*60,r=n*24,s=r*7,o=r*365.25;ms=function(h,f){f=f||{};var p=typeof h;if(p==="string"&&h.length>0)return a(h);if(p==="number"&&isFinite(h))return f.long?l(h):c(h);throw new Error("val is not a non-empty string or a valid number. val="+JSON.stringify(h))};function a(h){if(h=String(h),!(h.length>100)){var f=/^(-?(?:\d+)?\.?\d+) *(milliseconds?|msecs?|ms|seconds?|secs?|s|minutes?|mins?|m|hours?|hrs?|h|days?|d|weeks?|w|years?|yrs?|y)?$/i.exec(h);if(f){var p=parseFloat(f[1]),g=(f[2]||"ms").toLowerCase();switch(g){case"years":case"year":case"yrs":case"yr":case"y":return p*o;case"weeks":case"week":case"w":return p*s;case"days":case"day":case"d":return p*r;case"hours":case"hour":case"hrs":case"hr":case"h":return p*n;case"minutes":case"minute":case"mins":case"min":case"m":return p*e;case"seconds":case"second":case"secs":case"sec":case"s":return p*t;case"milliseconds":case"millisecond":case"msecs":case"msec":case"ms":return p;default:return}}}}function c(h){var f=Math.abs(h);return f>=r?Math.round(h/r)+"d":f>=n?Math.round(h/n)+"h":f>=e?Math.round(h/e)+"m":f>=t?Math.round(h/t)+"s":h+"ms"}function l(h){var f=Math.abs(h);return f>=r?u(h,f,r,"day"):f>=n?u(h,f,n,"hour"):f>=e?u(h,f,e,"minute"):f>=t?u(h,f,t,"second"):h+" ms"}function u(h,f,p,g){var w=f>=p*1.5;return Math.round(h/p)+" "+g+(w?"s":"")}return ms}function setup(t){n.debug=n,n.default=n,n.coerce=l,n.disable=a,n.enable=s,n.enabled=c,n.humanize=requireMs(),n.destroy=u,Object.keys(t).forEach(h=>{n[h]=t[h]}),n.names=[],n.skips=[],n.formatters={};function e(h){let f=0;for(let p=0;p<h.length;p++)f=(f<<5)-f+h.charCodeAt(p),f|=0;return n.colors[Math.abs(f)%n.colors.length]}n.selectColor=e;function n(h){let f,p=null,g,w;function y(...b){if(!y.enabled)return;const x=y,_=Number(new Date),R=_-(f||_);x.diff=R,x.prev=f,x.curr=_,f=_,b[0]=n.coerce(b[0]),typeof b[0]!="string"&&b.unshift("%O");let $=0;b[0]=b[0].replace(/%([a-zA-Z%])/g,(L,v)=>{if(L==="%%")return"%";$++;const D=n.formatters[v];if(typeof D=="function"){const j=b[$];L=D.call(x,j),b.splice($,1),$--}return L}),n.formatArgs.call(x,b),(x.log||n.log).apply(x,b)}return y.namespace=h,y.useColors=n.useColors(),y.color=n.selectColor(h),y.extend=r,y.destroy=n.destroy,Object.defineProperty(y,"enabled",{enumerable:!0,configurable:!1,get:()=>p!==null?p:(g!==n.namespaces&&(g=n.namespaces,w=n.enabled(h)),w),set:b=>{p=b}}),typeof n.init=="function"&&n.init(y),y}function r(h,f){const p=n(this.namespace+(typeof f>"u"?":":f)+h);return p.log=this.log,p}function s(h){n.save(h),n.namespaces=h,n.names=[],n.skips=[];const f=(typeof h=="string"?h:"").trim().replace(/\s+/g,",").split(",").filter(Boolean);for(const p of f)p[0]==="-"?n.skips.push(p.slice(1)):n.names.push(p)}function o(h,f){let p=0,g=0,w=-1,y=0;for(;p<h.length;)if(g<f.length&&(f[g]===h[p]||f[g]==="*"))f[g]==="*"?(w=g,y=p,g++):(p++,g++);else if(w!==-1)g=w+1,y++,p=y;else return!1;for(;g<f.length&&f[g]==="*";)g++;return g===f.length}function a(){const h=[...n.names,...n.skips.map(f=>"-"+f)].join(",");return n.enable(""),h}function c(h){for(const f of n.skips)if(o(h,f))return!1;for(const f of n.names)if(o(h,f))return!0;return!1}function l(h){return h instanceof Error?h.stack||h.message:h}function u(){console.warn("Instance method `debug.destroy()` is deprecated and no longer does anything. It will be removed in the next major version of `debug`.")}return n.enable(n.load()),n}var common=setup;(function(t,e){e.formatArgs=r,e.save=s,e.load=o,e.useColors=n,e.storage=a(),e.destroy=(()=>{let l=!1;return()=>{l||(l=!0,console.warn("Instance method `debug.destroy()` is deprecated and no longer does anything. It will be removed in the next major version of `debug`."))}})(),e.colors=["#0000CC","#0000FF","#0033CC","#0033FF","#0066CC","#0066FF","#0099CC","#0099FF","#00CC00","#00CC33","#00CC66","#00CC99","#00CCCC","#00CCFF","#3300CC","#3300FF","#3333CC","#3333FF","#3366CC","#3366FF","#3399CC","#3399FF","#33CC00","#33CC33","#33CC66","#33CC99","#33CCCC","#33CCFF","#6600CC","#6600FF","#6633CC","#6633FF","#66CC00","#66CC33","#9900CC","#9900FF","#9933CC","#9933FF","#99CC00","#99CC33","#CC0000","#CC0033","#CC0066","#CC0099","#CC00CC","#CC00FF","#CC3300","#CC3333","#CC3366","#CC3399","#CC33CC","#CC33FF","#CC6600","#CC6633","#CC9900","#CC9933","#CCCC00","#CCCC33","#FF0000","#FF0033","#FF0066","#FF0099","#FF00CC","#FF00FF","#FF3300","#FF3333","#FF3366","#FF3399","#FF33CC","#FF33FF","#FF6600","#FF6633","#FF9900","#FF9933","#FFCC00","#FFCC33"];function n(){if(typeof window<"u"&&window.process&&(window.process.type==="renderer"||window.process.__nwjs))return!0;if(typeof navigator<"u"&&navigator.userAgent&&navigator.userAgent.toLowerCase().match(/(edge|trident)\/(\d+)/))return!1;let l;return typeof document<"u"&&document.documentElement&&document.documentElement.style&&document.documentElement.style.WebkitAppearance||typeof window<"u"&&window.console&&(window.console.firebug||window.console.exception&&window.console.table)||typeof navigator<"u"&&navigator.userAgent&&(l=navigator.userAgent.toLowerCase().match(/firefox\/(\d+)/))&&parseInt(l[1],10)>=31||typeof navigator<"u"&&navigator.userAgent&&navigator.userAgent.toLowerCase().match(/applewebkit\/(\d+)/)}function r(l){if(l[0]=(this.useColors?"%c":"")+this.namespace+(this.useColors?" %c":" ")+l[0]+(this.useColors?"%c ":" ")+"+"+t.exports.humanize(this.diff),!this.useColors)return;const u="color: "+this.color;l.splice(1,0,u,"color: inherit");let h=0,f=0;l[0].replace(/%[a-zA-Z%]/g,p=>{p!=="%%"&&(h++,p==="%c"&&(f=h))}),l.splice(f,0,u)}e.log=console.debug||console.log||(()=>{});function s(l){try{l?e.storage.setItem("debug",l):e.storage.removeItem("debug")}catch{}}function o(){let l;try{l=e.storage.getItem("debug")||e.storage.getItem("DEBUG")}catch{}return!l&&typeof process<"u"&&"env"in process&&(l={}.DEBUG),l}function a(){try{return localStorage}catch{}}t.exports=common(e);const{formatters:c}=t.exports;c.j=function(l){try{return JSON.stringify(l)}catch(u){return"[UnexpectedJSONParseError]: "+u.message}}})(browser,browser.exports);var browserExports=browser.exports;const createDebug5=getDefaultExportFromCjs(browserExports);function number$2(t){if(!Number.isSafeInteger(t)||t<0)throw new Error(`Wrong positive integer: ${t}`)}function bytes$2(t,...e){if(!(t instanceof Uint8Array))throw new Error("Expected Uint8Array");if(e.length>0&&!e.includes(t.length))throw new Error(`Expected Uint8Array of length ${e}, not of length=${t.length}`)}function hash$1(t){if(typeof t!="function"||typeof t.create!="function")throw new Error("Hash should be wrapped by utils.wrapConstructor");number$2(t.outputLen),number$2(t.blockLen)}function exists$1(t,e=!0){if(t.destroyed)throw new Error("Hash instance has been destroyed");if(e&&t.finished)throw new Error("Hash#digest() has already been called")}function output$1(t,e){bytes$2(t);const n=e.outputLen;if(t.length<n)throw new Error(`digestInto() expects output buffer of length at least ${n}`)}const crypto$2=typeof globalThis=="object"&&"crypto"in globalThis?globalThis.crypto:void 0;/*! noble-hashes - MIT License (c) 2022 Paul Miller (paulmillr.com) */const u8a$2=t=>t instanceof Uint8Array,createView$1=t=>new DataView(t.buffer,t.byteOffset,t.byteLength),rotr$1=(t,e)=>t<<32-e|t>>>e,isLE$2=new Uint8Array(new Uint32Array([287454020]).buffer)[0]===68;if(!isLE$2)throw new Error("Non little-endian hardware is not supported");function utf8ToBytes$2(t){if(typeof t!="string")throw new Error(`utf8ToBytes expected string, got ${typeof t}`);return new Uint8Array(new TextEncoder().encode(t))}function toBytes$1(t){if(typeof t=="string"&&(t=utf8ToBytes$2(t)),!u8a$2(t))throw new Error(`expected Uint8Array, got ${typeof t}`);return t}function concatBytes$2(...t){const e=new Uint8Array(t.reduce((r,s)=>r+s.length,0));let n=0;return t.forEach(r=>{if(!u8a$2(r))throw new Error("Uint8Array expected");e.set(r,n),n+=r.length}),e}let Hash$1=class{clone(){return this._cloneInto()}};function wrapConstructor$1(t){const e=r=>t().update(toBytes$1(r)).digest(),n=t();return e.outputLen=n.outputLen,e.blockLen=n.blockLen,e.create=()=>t(),e}function randomBytes$1(t=32){if(crypto$2&&typeof crypto$2.getRandomValues=="function")return crypto$2.getRandomValues(new Uint8Array(t));throw new Error("crypto.getRandomValues must be defined")}function setBigUint64$1(t,e,n,r){if(typeof t.setBigUint64=="function")return t.setBigUint64(e,n,r);const s=BigInt(32),o=BigInt(4294967295),a=Number(n>>s&o),c=Number(n&o),l=r?4:0,u=r?0:4;t.setUint32(e+l,a,r),t.setUint32(e+u,c,r)}let SHA2$1=class extends Hash$1{constructor(e,n,r,s){super(),this.blockLen=e,this.outputLen=n,this.padOffset=r,this.isLE=s,this.finished=!1,this.length=0,this.pos=0,this.destroyed=!1,this.buffer=new Uint8Array(e),this.view=createView$1(this.buffer)}update(e){exists$1(this);const{view:n,buffer:r,blockLen:s}=this;e=toBytes$1(e);const o=e.length;for(let a=0;a<o;){const c=Math.min(s-this.pos,o-a);if(c===s){const l=createView$1(e);for(;s<=o-a;a+=s)this.process(l,a);continue}r.set(e.subarray(a,a+c),this.pos),this.pos+=c,a+=c,this.pos===s&&(this.process(n,0),this.pos=0)}return this.length+=e.length,this.roundClean(),this}digestInto(e){exists$1(this),output$1(e,this),this.finished=!0;const{buffer:n,view:r,blockLen:s,isLE:o}=this;let{pos:a}=this;n[a++]=128,this.buffer.subarray(a).fill(0),this.padOffset>s-a&&(this.process(r,0),a=0);for(let f=a;f<s;f++)n[f]=0;setBigUint64$1(r,s-8,BigInt(this.length*8),o),this.process(r,0);const c=createView$1(e),l=this.outputLen;if(l%4)throw new Error("_sha2: outputLen should be aligned to 32bit");const u=l/4,h=this.get();if(u>h.length)throw new Error("_sha2: outputLen bigger than state");for(let f=0;f<u;f++)c.setUint32(4*f,h[f],o)}digest(){const{buffer:e,outputLen:n}=this;this.digestInto(e);const r=e.slice(0,n);return this.destroy(),r}_cloneInto(e){e||(e=new this.constructor),e.set(...this.get());const{blockLen:n,buffer:r,length:s,finished:o,destroyed:a,pos:c}=this;return e.length=s,e.pos=c,e.finished=o,e.destroyed=a,s%n&&e.buffer.set(r),e}};const Chi$1=(t,e,n)=>t&e^~t&n,Maj$1=(t,e,n)=>t&e^t&n^e&n,SHA256_K$1=new Uint32Array([1116352408,1899447441,3049323471,3921009573,961987163,1508970993,2453635748,2870763221,3624381080,310598401,607225278,1426881987,1925078388,2162078206,2614888103,3248222580,3835390401,4022224774,264347078,604807628,770255983,1249150122,1555081692,1996064986,2554220882,2821834349,2952996808,3210313671,3336571891,3584528711,113926993,338241895,666307205,773529912,1294757372,1396182291,1695183700,1986661051,2177026350,2456956037,2730485921,2820302411,3259730800,3345764771,3516065817,3600352804,4094571909,275423344,430227734,506948616,659060556,883997877,958139571,1322822218,1537002063,1747873779,1955562222,2024104815,2227730452,2361852424,2428436474,2756734187,3204031479,3329325298]),IV$1=new Uint32Array([1779033703,3144134277,1013904242,2773480762,1359893119,2600822924,528734635,1541459225]),SHA256_W$1=new Uint32Array(64);let SHA256$1=class extends SHA2$1{constructor(){super(64,32,8,!1),this.A=IV$1[0]|0,this.B=IV$1[1]|0,this.C=IV$1[2]|0,this.D=IV$1[3]|0,this.E=IV$1[4]|0,this.F=IV$1[5]|0,this.G=IV$1[6]|0,this.H=IV$1[7]|0}get(){const{A:e,B:n,C:r,D:s,E:o,F:a,G:c,H:l}=this;return[e,n,r,s,o,a,c,l]}set(e,n,r,s,o,a,c,l){this.A=e|0,this.B=n|0,this.C=r|0,this.D=s|0,this.E=o|0,this.F=a|0,this.G=c|0,this.H=l|0}process(e,n){for(let f=0;f<16;f++,n+=4)SHA256_W$1[f]=e.getUint32(n,!1);for(let f=16;f<64;f++){const p=SHA256_W$1[f-15],g=SHA256_W$1[f-2],w=rotr$1(p,7)^rotr$1(p,18)^p>>>3,y=rotr$1(g,17)^rotr$1(g,19)^g>>>10;SHA256_W$1[f]=y+SHA256_W$1[f-7]+w+SHA256_W$1[f-16]|0}let{A:r,B:s,C:o,D:a,E:c,F:l,G:u,H:h}=this;for(let f=0;f<64;f++){const p=rotr$1(c,6)^rotr$1(c,11)^rotr$1(c,25),g=h+p+Chi$1(c,l,u)+SHA256_K$1[f]+SHA256_W$1[f]|0,y=(rotr$1(r,2)^rotr$1(r,13)^rotr$1(r,22))+Maj$1(r,s,o)|0;h=u,u=l,l=c,c=a+g|0,a=o,o=s,s=r,r=g+y|0}r=r+this.A|0,s=s+this.B|0,o=o+this.C|0,a=a+this.D|0,c=c+this.E|0,l=l+this.F|0,u=u+this.G|0,h=h+this.H|0,this.set(r,s,o,a,c,l,u,h)}roundClean(){SHA256_W$1.fill(0)}destroy(){this.set(0,0,0,0,0,0,0,0),this.buffer.fill(0)}};const sha256$2=wrapConstructor$1(()=>new SHA256$1);/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */const _0n$4=BigInt(0),_1n$4=BigInt(1),_2n$2=BigInt(2),u8a$1=t=>t instanceof Uint8Array,hexes$1=Array.from({length:256},(t,e)=>e.toString(16).padStart(2,"0"));function bytesToHex$1(t){if(!u8a$1(t))throw new Error("Uint8Array expected");let e="";for(let n=0;n<t.length;n++)e+=hexes$1[t[n]];return e}function numberToHexUnpadded(t){const e=t.toString(16);return e.length&1?`0${e}`:e}function hexToNumber(t){if(typeof t!="string")throw new Error("hex string expected, got "+typeof t);return BigInt(t===""?"0":`0x${t}`)}function hexToBytes$1(t){if(typeof t!="string")throw new Error("hex string expected, got "+typeof t);const e=t.length;if(e%2)throw new Error("padded hex string expected, got unpadded hex of length "+e);const n=new Uint8Array(e/2);for(let r=0;r<n.length;r++){const s=r*2,o=t.slice(s,s+2),a=Number.parseInt(o,16);if(Number.isNaN(a)||a<0)throw new Error("Invalid byte sequence");n[r]=a}return n}function bytesToNumberBE(t){return hexToNumber(bytesToHex$1(t))}function bytesToNumberLE(t){if(!u8a$1(t))throw new Error("Uint8Array expected");return hexToNumber(bytesToHex$1(Uint8Array.from(t).reverse()))}function numberToBytesBE(t,e){return hexToBytes$1(t.toString(16).padStart(e*2,"0"))}function numberToBytesLE(t,e){return numberToBytesBE(t,e).reverse()}function numberToVarBytesBE(t){return hexToBytes$1(numberToHexUnpadded(t))}function ensureBytes(t,e,n){let r;if(typeof e=="string")try{r=hexToBytes$1(e)}catch(o){throw new Error(`${t} must be valid hex string, got "${e}". Cause: ${o}`)}else if(u8a$1(e))r=Uint8Array.from(e);else throw new Error(`${t} must be hex string or Uint8Array`);const s=r.length;if(typeof n=="number"&&s!==n)throw new Error(`${t} expected ${n} bytes, got ${s}`);return r}function concatBytes$1(...t){const e=new Uint8Array(t.reduce((r,s)=>r+s.length,0));let n=0;return t.forEach(r=>{if(!u8a$1(r))throw new Error("Uint8Array expected");e.set(r,n),n+=r.length}),e}function equalBytes$1(t,e){if(t.length!==e.length)return!1;for(let n=0;n<t.length;n++)if(t[n]!==e[n])return!1;return!0}function utf8ToBytes$1(t){if(typeof t!="string")throw new Error(`utf8ToBytes expected string, got ${typeof t}`);return new Uint8Array(new TextEncoder().encode(t))}function bitLen(t){let e;for(e=0;t>_0n$4;t>>=_1n$4,e+=1);return e}function bitGet(t,e){return t>>BigInt(e)&_1n$4}const bitSet=(t,e,n)=>t|(n?_1n$4:_0n$4)<<BigInt(e),bitMask=t=>(_2n$2<<BigInt(t-1))-_1n$4,u8n=t=>new Uint8Array(t),u8fr=t=>Uint8Array.from(t);function createHmacDrbg(t,e,n){if(typeof t!="number"||t<2)throw new Error("hashLen must be a number");if(typeof e!="number"||e<2)throw new Error("qByteLen must be a number");if(typeof n!="function")throw new Error("hmacFn must be a function");let r=u8n(t),s=u8n(t),o=0;const a=()=>{r.fill(1),s.fill(0),o=0},c=(...f)=>n(s,r,...f),l=(f=u8n())=>{s=c(u8fr([0]),f),r=c(),f.length!==0&&(s=c(u8fr([1]),f),r=c())},u=()=>{if(o++>=1e3)throw new Error("drbg: tried 1000 values");let f=0;const p=[];for(;f<e;){r=c();const g=r.slice();p.push(g),f+=r.length}return concatBytes$1(...p)};return(f,p)=>{a(),l(f);let g;for(;!(g=p(u()));)l();return a(),g}}const validatorFns={bigint:t=>typeof t=="bigint",function:t=>typeof t=="function",boolean:t=>typeof t=="boolean",string:t=>typeof t=="string",stringOrUint8Array:t=>typeof t=="string"||t instanceof Uint8Array,isSafeInteger:t=>Number.isSafeInteger(t),array:t=>Array.isArray(t),field:(t,e)=>e.Fp.isValid(t),hash:t=>typeof t=="function"&&Number.isSafeInteger(t.outputLen)};function validateObject(t,e,n={}){const r=(s,o,a)=>{const c=validatorFns[o];if(typeof c!="function")throw new Error(`Invalid validator "${o}", expected function`);const l=t[s];if(!(a&&l===void 0)&&!c(l,t))throw new Error(`Invalid param ${String(s)}=${l} (${typeof l}), expected ${o}`)};for(const[s,o]of Object.entries(e))r(s,o,!1);for(const[s,o]of Object.entries(n))r(s,o,!0);return t}const ut=Object.freeze(Object.defineProperty({__proto__:null,bitGet,bitLen,bitMask,bitSet,bytesToHex:bytesToHex$1,bytesToNumberBE,bytesToNumberLE,concatBytes:concatBytes$1,createHmacDrbg,ensureBytes,equalBytes:equalBytes$1,hexToBytes:hexToBytes$1,hexToNumber,numberToBytesBE,numberToBytesLE,numberToHexUnpadded,numberToVarBytesBE,utf8ToBytes:utf8ToBytes$1,validateObject},Symbol.toStringTag,{value:"Module"}));/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */const _0n$3=BigInt(0),_1n$3=BigInt(1),_2n$1=BigInt(2),_3n$1=BigInt(3),_4n=BigInt(4),_5n=BigInt(5),_8n=BigInt(8);BigInt(9);BigInt(16);function mod(t,e){const n=t%e;return n>=_0n$3?n:e+n}function pow(t,e,n){if(n<=_0n$3||e<_0n$3)throw new Error("Expected power/modulo > 0");if(n===_1n$3)return _0n$3;let r=_1n$3;for(;e>_0n$3;)e&_1n$3&&(r=r*t%n),t=t*t%n,e>>=_1n$3;return r}function pow2(t,e,n){let r=t;for(;e-- >_0n$3;)r*=r,r%=n;return r}function invert(t,e){if(t===_0n$3||e<=_0n$3)throw new Error(`invert: expected positive integers, got n=${t} mod=${e}`);let n=mod(t,e),r=e,s=_0n$3,o=_1n$3;for(;n!==_0n$3;){const c=r/n,l=r%n,u=s-o*c;r=n,n=l,s=o,o=u}if(r!==_1n$3)throw new Error("invert: does not exist");return mod(s,e)}function tonelliShanks(t){const e=(t-_1n$3)/_2n$1;let n,r,s;for(n=t-_1n$3,r=0;n%_2n$1===_0n$3;n/=_2n$1,r++);for(s=_2n$1;s<t&&pow(s,e,t)!==t-_1n$3;s++);if(r===1){const a=(t+_1n$3)/_4n;return function(l,u){const h=l.pow(u,a);if(!l.eql(l.sqr(h),u))throw new Error("Cannot find square root");return h}}const o=(n+_1n$3)/_2n$1;return function(c,l){if(c.pow(l,e)===c.neg(c.ONE))throw new Error("Cannot find square root");let u=r,h=c.pow(c.mul(c.ONE,s),n),f=c.pow(l,o),p=c.pow(l,n);for(;!c.eql(p,c.ONE);){if(c.eql(p,c.ZERO))return c.ZERO;let g=1;for(let y=c.sqr(p);g<u&&!c.eql(y,c.ONE);g++)y=c.sqr(y);const w=c.pow(h,_1n$3<<BigInt(u-g-1));h=c.sqr(w),f=c.mul(f,w),p=c.mul(p,h),u=g}return f}}function FpSqrt(t){if(t%_4n===_3n$1){const e=(t+_1n$3)/_4n;return function(r,s){const o=r.pow(s,e);if(!r.eql(r.sqr(o),s))throw new Error("Cannot find square root");return o}}if(t%_8n===_5n){const e=(t-_5n)/_8n;return function(r,s){const o=r.mul(s,_2n$1),a=r.pow(o,e),c=r.mul(s,a),l=r.mul(r.mul(c,_2n$1),a),u=r.mul(c,r.sub(l,r.ONE));if(!r.eql(r.sqr(u),s))throw new Error("Cannot find square root");return u}}return tonelliShanks(t)}const FIELD_FIELDS=["create","isValid","is0","neg","inv","sqrt","sqr","eql","add","sub","mul","pow","div","addN","subN","mulN","sqrN"];function validateField(t){const e={ORDER:"bigint",MASK:"bigint",BYTES:"isSafeInteger",BITS:"isSafeInteger"},n=FIELD_FIELDS.reduce((r,s)=>(r[s]="function",r),e);return validateObject(t,n)}function FpPow(t,e,n){if(n<_0n$3)throw new Error("Expected power > 0");if(n===_0n$3)return t.ONE;if(n===_1n$3)return e;let r=t.ONE,s=e;for(;n>_0n$3;)n&_1n$3&&(r=t.mul(r,s)),s=t.sqr(s),n>>=_1n$3;return r}function FpInvertBatch(t,e){const n=new Array(e.length),r=e.reduce((o,a,c)=>t.is0(a)?o:(n[c]=o,t.mul(o,a)),t.ONE),s=t.inv(r);return e.reduceRight((o,a,c)=>t.is0(a)?o:(n[c]=t.mul(o,n[c]),t.mul(o,a)),s),n}function nLength(t,e){const n=e!==void 0?e:t.toString(2).length,r=Math.ceil(n/8);return{nBitLength:n,nByteLength:r}}function Field(t,e,n=!1,r={}){if(t<=_0n$3)throw new Error(`Expected Field ORDER > 0, got ${t}`);const{nBitLength:s,nByteLength:o}=nLength(t,e);if(o>2048)throw new Error("Field lengths over 2048 bytes are not supported");const a=FpSqrt(t),c=Object.freeze({ORDER:t,BITS:s,BYTES:o,MASK:bitMask(s),ZERO:_0n$3,ONE:_1n$3,create:l=>mod(l,t),isValid:l=>{if(typeof l!="bigint")throw new Error(`Invalid field element: expected bigint, got ${typeof l}`);return _0n$3<=l&&l<t},is0:l=>l===_0n$3,isOdd:l=>(l&_1n$3)===_1n$3,neg:l=>mod(-l,t),eql:(l,u)=>l===u,sqr:l=>mod(l*l,t),add:(l,u)=>mod(l+u,t),sub:(l,u)=>mod(l-u,t),mul:(l,u)=>mod(l*u,t),pow:(l,u)=>FpPow(c,l,u),div:(l,u)=>mod(l*invert(u,t),t),sqrN:l=>l*l,addN:(l,u)=>l+u,subN:(l,u)=>l-u,mulN:(l,u)=>l*u,inv:l=>invert(l,t),sqrt:r.sqrt||(l=>a(c,l)),invertBatch:l=>FpInvertBatch(c,l),cmov:(l,u,h)=>h?u:l,toBytes:l=>n?numberToBytesLE(l,o):numberToBytesBE(l,o),fromBytes:l=>{if(l.length!==o)throw new Error(`Fp.fromBytes: expected ${o}, got ${l.length}`);return n?bytesToNumberLE(l):bytesToNumberBE(l)}});return Object.freeze(c)}function getFieldBytesLength(t){if(typeof t!="bigint")throw new Error("field order must be bigint");const e=t.toString(2).length;return Math.ceil(e/8)}function getMinHashLength(t){const e=getFieldBytesLength(t);return e+Math.ceil(e/2)}function mapHashToField(t,e,n=!1){const r=t.length,s=getFieldBytesLength(e),o=getMinHashLength(e);if(r<16||r<o||r>1024)throw new Error(`expected ${o}-1024 bytes of input, got ${r}`);const a=n?bytesToNumberBE(t):bytesToNumberLE(t),c=mod(a,e-_1n$3)+_1n$3;return n?numberToBytesLE(c,s):numberToBytesBE(c,s)}/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */const _0n$2=BigInt(0),_1n$2=BigInt(1);function wNAF(t,e){const n=(s,o)=>{const a=o.negate();return s?a:o},r=s=>{const o=Math.ceil(e/s)+1,a=2**(s-1);return{windows:o,windowSize:a}};return{constTimeNegate:n,unsafeLadder(s,o){let a=t.ZERO,c=s;for(;o>_0n$2;)o&_1n$2&&(a=a.add(c)),c=c.double(),o>>=_1n$2;return a},precomputeWindow(s,o){const{windows:a,windowSize:c}=r(o),l=[];let u=s,h=u;for(let f=0;f<a;f++){h=u,l.push(h);for(let p=1;p<c;p++)h=h.add(u),l.push(h);u=h.double()}return l},wNAF(s,o,a){const{windows:c,windowSize:l}=r(s);let u=t.ZERO,h=t.BASE;const f=BigInt(2**s-1),p=2**s,g=BigInt(s);for(let w=0;w<c;w++){const y=w*l;let b=Number(a&f);a>>=g,b>l&&(b-=p,a+=_1n$2);const x=y,_=y+Math.abs(b)-1,R=w%2!==0,$=b<0;b===0?h=h.add(n(R,o[x])):u=u.add(n($,o[_]))}return{p:u,f:h}},wNAFCached(s,o,a,c){const l=s._WINDOW_SIZE||1;let u=o.get(s);return u||(u=this.precomputeWindow(s,l),l!==1&&o.set(s,c(u))),this.wNAF(l,u,a)}}}function validateBasic(t){return validateField(t.Fp),validateObject(t,{n:"bigint",h:"bigint",Gx:"field",Gy:"field"},{nBitLength:"isSafeInteger",nByteLength:"isSafeInteger"}),Object.freeze({...nLength(t.n,t.nBitLength),...t,p:t.Fp.ORDER})}/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */function validatePointOpts(t){const e=validateBasic(t);validateObject(e,{a:"field",b:"field"},{allowedPrivateKeyLengths:"array",wrapPrivateKey:"boolean",isTorsionFree:"function",clearCofactor:"function",allowInfinityPoint:"boolean",fromBytes:"function",toBytes:"function"});const{endo:n,Fp:r,a:s}=e;if(n){if(!r.eql(s,r.ZERO))throw new Error("Endomorphism can only be defined for Koblitz curves that have a=0");if(typeof n!="object"||typeof n.beta!="bigint"||typeof n.splitScalar!="function")throw new Error("Expected endomorphism with beta: bigint and splitScalar: function")}return Object.freeze({...e})}const{bytesToNumberBE:b2n,hexToBytes:h2b}=ut,DER={Err:class extends Error{constructor(e=""){super(e)}},_parseInt(t){const{Err:e}=DER;if(t.length<2||t[0]!==2)throw new e("Invalid signature integer tag");const n=t[1],r=t.subarray(2,n+2);if(!n||r.length!==n)throw new e("Invalid signature integer: wrong length");if(r[0]&128)throw new e("Invalid signature integer: negative");if(r[0]===0&&!(r[1]&128))throw new e("Invalid signature integer: unnecessary leading zero");return{d:b2n(r),l:t.subarray(n+2)}},toSig(t){const{Err:e}=DER,n=typeof t=="string"?h2b(t):t;if(!(n instanceof Uint8Array))throw new Error("ui8a expected");let r=n.length;if(r<2||n[0]!=48)throw new e("Invalid signature tag");if(n[1]!==r-2)throw new e("Invalid signature: incorrect length");const{d:s,l:o}=DER._parseInt(n.subarray(2)),{d:a,l:c}=DER._parseInt(o);if(c.length)throw new e("Invalid signature: left bytes after parsing");return{r:s,s:a}},hexFromSig(t){const e=u=>Number.parseInt(u[0],16)&8?"00"+u:u,n=u=>{const h=u.toString(16);return h.length&1?`0${h}`:h},r=e(n(t.s)),s=e(n(t.r)),o=r.length/2,a=s.length/2,c=n(o),l=n(a);return`30${n(a+o+4)}02${l}${s}02${c}${r}`}},_0n$1=BigInt(0),_1n$1=BigInt(1);BigInt(2);const _3n=BigInt(3);BigInt(4);function weierstrassPoints(t){const e=validatePointOpts(t),{Fp:n}=e,r=e.toBytes||((w,y,b)=>{const x=y.toAffine();return concatBytes$1(Uint8Array.from([4]),n.toBytes(x.x),n.toBytes(x.y))}),s=e.fromBytes||(w=>{const y=w.subarray(1),b=n.fromBytes(y.subarray(0,n.BYTES)),x=n.fromBytes(y.subarray(n.BYTES,2*n.BYTES));return{x:b,y:x}});function o(w){const{a:y,b}=e,x=n.sqr(w),_=n.mul(x,w);return n.add(n.add(_,n.mul(w,y)),b)}if(!n.eql(n.sqr(e.Gy),o(e.Gx)))throw new Error("bad generator point: equation left != right");function a(w){return typeof w=="bigint"&&_0n$1<w&&w<e.n}function c(w){if(!a(w))throw new Error("Expected valid bigint: 0 < bigint < curve.n")}function l(w){const{allowedPrivateKeyLengths:y,nByteLength:b,wrapPrivateKey:x,n:_}=e;if(y&&typeof w!="bigint"){if(w instanceof Uint8Array&&(w=bytesToHex$1(w)),typeof w!="string"||!y.includes(w.length))throw new Error("Invalid key");w=w.padStart(b*2,"0")}let R;try{R=typeof w=="bigint"?w:bytesToNumberBE(ensureBytes("private key",w,b))}catch{throw new Error(`private key must be ${b} bytes, hex or bigint, not ${typeof w}`)}return x&&(R=mod(R,_)),c(R),R}const u=new Map;function h(w){if(!(w instanceof f))throw new Error("ProjectivePoint expected")}class f{constructor(y,b,x){if(this.px=y,this.py=b,this.pz=x,y==null||!n.isValid(y))throw new Error("x required");if(b==null||!n.isValid(b))throw new Error("y required");if(x==null||!n.isValid(x))throw new Error("z required")}static fromAffine(y){const{x:b,y:x}=y||{};if(!y||!n.isValid(b)||!n.isValid(x))throw new Error("invalid affine point");if(y instanceof f)throw new Error("projective point not allowed");const _=R=>n.eql(R,n.ZERO);return _(b)&&_(x)?f.ZERO:new f(b,x,n.ONE)}get x(){return this.toAffine().x}get y(){return this.toAffine().y}static normalizeZ(y){const b=n.invertBatch(y.map(x=>x.pz));return y.map((x,_)=>x.toAffine(b[_])).map(f.fromAffine)}static fromHex(y){const b=f.fromAffine(s(ensureBytes("pointHex",y)));return b.assertValidity(),b}static fromPrivateKey(y){return f.BASE.multiply(l(y))}_setWindowSize(y){this._WINDOW_SIZE=y,u.delete(this)}assertValidity(){if(this.is0()){if(e.allowInfinityPoint&&!n.is0(this.py))return;throw new Error("bad point: ZERO")}const{x:y,y:b}=this.toAffine();if(!n.isValid(y)||!n.isValid(b))throw new Error("bad point: x or y not FE");const x=n.sqr(b),_=o(y);if(!n.eql(x,_))throw new Error("bad point: equation left != right");if(!this.isTorsionFree())throw new Error("bad point: not in prime-order subgroup")}hasEvenY(){const{y}=this.toAffine();if(n.isOdd)return!n.isOdd(y);throw new Error("Field doesn't support isOdd")}equals(y){h(y);const{px:b,py:x,pz:_}=this,{px:R,py:$,pz:A}=y,L=n.eql(n.mul(b,A),n.mul(R,_)),v=n.eql(n.mul(x,A),n.mul($,_));return L&&v}negate(){return new f(this.px,n.neg(this.py),this.pz)}double(){const{a:y,b}=e,x=n.mul(b,_3n),{px:_,py:R,pz:$}=this;let A=n.ZERO,L=n.ZERO,v=n.ZERO,D=n.mul(_,_),j=n.mul(R,R),z=n.mul($,$),E=n.mul(_,R);return E=n.add(E,E),v=n.mul(_,$),v=n.add(v,v),A=n.mul(y,v),L=n.mul(x,z),L=n.add(A,L),A=n.sub(j,L),L=n.add(j,L),L=n.mul(A,L),A=n.mul(E,A),v=n.mul(x,v),z=n.mul(y,z),E=n.sub(D,z),E=n.mul(y,E),E=n.add(E,v),v=n.add(D,D),D=n.add(v,D),D=n.add(D,z),D=n.mul(D,E),L=n.add(L,D),z=n.mul(R,$),z=n.add(z,z),D=n.mul(z,E),A=n.sub(A,D),v=n.mul(z,j),v=n.add(v,v),v=n.add(v,v),new f(A,L,v)}add(y){h(y);const{px:b,py:x,pz:_}=this,{px:R,py:$,pz:A}=y;let L=n.ZERO,v=n.ZERO,D=n.ZERO;const j=e.a,z=n.mul(e.b,_3n);let E=n.mul(b,R),k=n.mul(x,$),B=n.mul(_,A),H=n.add(b,x),S=n.add(R,$);H=n.mul(H,S),S=n.add(E,k),H=n.sub(H,S),S=n.add(b,_);let T=n.add(R,A);return S=n.mul(S,T),T=n.add(E,B),S=n.sub(S,T),T=n.add(x,_),L=n.add($,A),T=n.mul(T,L),L=n.add(k,B),T=n.sub(T,L),D=n.mul(j,S),L=n.mul(z,B),D=n.add(L,D),L=n.sub(k,D),D=n.add(k,D),v=n.mul(L,D),k=n.add(E,E),k=n.add(k,E),B=n.mul(j,B),S=n.mul(z,S),k=n.add(k,B),B=n.sub(E,B),B=n.mul(j,B),S=n.add(S,B),E=n.mul(k,S),v=n.add(v,E),E=n.mul(T,S),L=n.mul(H,L),L=n.sub(L,E),E=n.mul(H,k),D=n.mul(T,D),D=n.add(D,E),new f(L,v,D)}subtract(y){return this.add(y.negate())}is0(){return this.equals(f.ZERO)}wNAF(y){return g.wNAFCached(this,u,y,b=>{const x=n.invertBatch(b.map(_=>_.pz));return b.map((_,R)=>_.toAffine(x[R])).map(f.fromAffine)})}multiplyUnsafe(y){const b=f.ZERO;if(y===_0n$1)return b;if(c(y),y===_1n$1)return this;const{endo:x}=e;if(!x)return g.unsafeLadder(this,y);let{k1neg:_,k1:R,k2neg:$,k2:A}=x.splitScalar(y),L=b,v=b,D=this;for(;R>_0n$1||A>_0n$1;)R&_1n$1&&(L=L.add(D)),A&_1n$1&&(v=v.add(D)),D=D.double(),R>>=_1n$1,A>>=_1n$1;return _&&(L=L.negate()),$&&(v=v.negate()),v=new f(n.mul(v.px,x.beta),v.py,v.pz),L.add(v)}multiply(y){c(y);let b=y,x,_;const{endo:R}=e;if(R){const{k1neg:$,k1:A,k2neg:L,k2:v}=R.splitScalar(b);let{p:D,f:j}=this.wNAF(A),{p:z,f:E}=this.wNAF(v);D=g.constTimeNegate($,D),z=g.constTimeNegate(L,z),z=new f(n.mul(z.px,R.beta),z.py,z.pz),x=D.add(z),_=j.add(E)}else{const{p:$,f:A}=this.wNAF(b);x=$,_=A}return f.normalizeZ([x,_])[0]}multiplyAndAddUnsafe(y,b,x){const _=f.BASE,R=(A,L)=>L===_0n$1||L===_1n$1||!A.equals(_)?A.multiplyUnsafe(L):A.multiply(L),$=R(this,b).add(R(y,x));return $.is0()?void 0:$}toAffine(y){const{px:b,py:x,pz:_}=this,R=this.is0();y==null&&(y=R?n.ONE:n.inv(_));const $=n.mul(b,y),A=n.mul(x,y),L=n.mul(_,y);if(R)return{x:n.ZERO,y:n.ZERO};if(!n.eql(L,n.ONE))throw new Error("invZ was invalid");return{x:$,y:A}}isTorsionFree(){const{h:y,isTorsionFree:b}=e;if(y===_1n$1)return!0;if(b)return b(f,this);throw new Error("isTorsionFree() has not been declared for the elliptic curve")}clearCofactor(){const{h:y,clearCofactor:b}=e;return y===_1n$1?this:b?b(f,this):this.multiplyUnsafe(e.h)}toRawBytes(y=!0){return this.assertValidity(),r(f,this,y)}toHex(y=!0){return bytesToHex$1(this.toRawBytes(y))}}f.BASE=new f(e.Gx,e.Gy,n.ONE),f.ZERO=new f(n.ZERO,n.ONE,n.ZERO);const p=e.nBitLength,g=wNAF(f,e.endo?Math.ceil(p/2):p);return{CURVE:e,ProjectivePoint:f,normPrivateKeyToScalar:l,weierstrassEquation:o,isWithinCurveOrder:a}}function validateOpts(t){const e=validateBasic(t);return validateObject(e,{hash:"hash",hmac:"function",randomBytes:"function"},{bits2int:"function",bits2int_modN:"function",lowS:"boolean"}),Object.freeze({lowS:!0,...e})}function weierstrass(t){const e=validateOpts(t),{Fp:n,n:r}=e,s=n.BYTES+1,o=2*n.BYTES+1;function a(S){return _0n$1<S&&S<n.ORDER}function c(S){return mod(S,r)}function l(S){return invert(S,r)}const{ProjectivePoint:u,normPrivateKeyToScalar:h,weierstrassEquation:f,isWithinCurveOrder:p}=weierstrassPoints({...e,toBytes(S,T,U){const K=T.toAffine(),O=n.toBytes(K.x),V=concatBytes$1;return U?V(Uint8Array.from([T.hasEvenY()?2:3]),O):V(Uint8Array.from([4]),O,n.toBytes(K.y))},fromBytes(S){const T=S.length,U=S[0],K=S.subarray(1);if(T===s&&(U===2||U===3)){const O=bytesToNumberBE(K);if(!a(O))throw new Error("Point is not on curve");const V=f(O);let F=n.sqrt(V);const q=(F&_1n$1)===_1n$1;return(U&1)===1!==q&&(F=n.neg(F)),{x:O,y:F}}else if(T===o&&U===4){const O=n.fromBytes(K.subarray(0,n.BYTES)),V=n.fromBytes(K.subarray(n.BYTES,2*n.BYTES));return{x:O,y:V}}else throw new Error(`Point of length ${T} was invalid. Expected ${s} compressed bytes or ${o} uncompressed bytes`)}}),g=S=>bytesToHex$1(numberToBytesBE(S,e.nByteLength));function w(S){const T=r>>_1n$1;return S>T}function y(S){return w(S)?c(-S):S}const b=(S,T,U)=>bytesToNumberBE(S.slice(T,U));class x{constructor(T,U,K){this.r=T,this.s=U,this.recovery=K,this.assertValidity()}static fromCompact(T){const U=e.nByteLength;return T=ensureBytes("compactSignature",T,U*2),new x(b(T,0,U),b(T,U,2*U))}static fromDER(T){const{r:U,s:K}=DER.toSig(ensureBytes("DER",T));return new x(U,K)}assertValidity(){if(!p(this.r))throw new Error("r must be 0 < r < CURVE.n");if(!p(this.s))throw new Error("s must be 0 < s < CURVE.n")}addRecoveryBit(T){return new x(this.r,this.s,T)}recoverPublicKey(T){const{r:U,s:K,recovery:O}=this,V=v(ensureBytes("msgHash",T));if(O==null||![0,1,2,3].includes(O))throw new Error("recovery id invalid");const F=O===2||O===3?U+e.n:U;if(F>=n.ORDER)throw new Error("recovery id 2 or 3 invalid");const q=O&1?"03":"02",Y=u.fromHex(q+g(F)),Z=l(F),X=c(-V*Z),te=c(K*Z),J=u.BASE.multiplyAndAddUnsafe(Y,X,te);if(!J)throw new Error("point at infinify");return J.assertValidity(),J}hasHighS(){return w(this.s)}normalizeS(){return this.hasHighS()?new x(this.r,c(-this.s),this.recovery):this}toDERRawBytes(){return hexToBytes$1(this.toDERHex())}toDERHex(){return DER.hexFromSig({r:this.r,s:this.s})}toCompactRawBytes(){return hexToBytes$1(this.toCompactHex())}toCompactHex(){return g(this.r)+g(this.s)}}const _={isValidPrivateKey(S){try{return h(S),!0}catch{return!1}},normPrivateKeyToScalar:h,randomPrivateKey:()=>{const S=getMinHashLength(e.n);return mapHashToField(e.randomBytes(S),e.n)},precompute(S=8,T=u.BASE){return T._setWindowSize(S),T.multiply(BigInt(3)),T}};function R(S,T=!0){return u.fromPrivateKey(S).toRawBytes(T)}function $(S){const T=S instanceof Uint8Array,U=typeof S=="string",K=(T||U)&&S.length;return T?K===s||K===o:U?K===2*s||K===2*o:S instanceof u}function A(S,T,U=!0){if($(S))throw new Error("first arg must be private key");if(!$(T))throw new Error("second arg must be public key");return u.fromHex(T).multiply(h(S)).toRawBytes(U)}const L=e.bits2int||function(S){const T=bytesToNumberBE(S),U=S.length*8-e.nBitLength;return U>0?T>>BigInt(U):T},v=e.bits2int_modN||function(S){return c(L(S))},D=bitMask(e.nBitLength);function j(S){if(typeof S!="bigint")throw new Error("bigint expected");if(!(_0n$1<=S&&S<D))throw new Error(`bigint expected < 2^${e.nBitLength}`);return numberToBytesBE(S,e.nByteLength)}function z(S,T,U=E){if(["recovered","canonical"].some(ne=>ne in U))throw new Error("sign() legacy options not supported");const{hash:K,randomBytes:O}=e;let{lowS:V,prehash:F,extraEntropy:q}=U;V==null&&(V=!0),S=ensureBytes("msgHash",S),F&&(S=ensureBytes("prehashed msgHash",K(S)));const Y=v(S),Z=h(T),X=[j(Z),j(Y)];if(q!=null){const ne=q===!0?O(n.BYTES):q;X.push(ensureBytes("extraEntropy",ne))}const te=concatBytes$1(...X),J=Y;function oe(ne){const re=L(ne);if(!p(re))return;const Be=l(re),ie=u.BASE.multiply(re).toAffine(),Q=c(ie.x);if(Q===_0n$1)return;const se=c(Be*c(J+Q*Z));if(se===_0n$1)return;let le=(ie.x===Q?0:2)|Number(ie.y&_1n$1),ce=se;return V&&w(se)&&(ce=y(se),le^=1),new x(Q,ce,le)}return{seed:te,k2sig:oe}}const E={lowS:e.lowS,prehash:!1},k={lowS:e.lowS,prehash:!1};function B(S,T,U=E){const{seed:K,k2sig:O}=z(S,T,U),V=e;return createHmacDrbg(V.hash.outputLen,V.nByteLength,V.hmac)(K,O)}u.BASE._setWindowSize(8);function H(S,T,U,K=k){var ie;const O=S;if(T=ensureBytes("msgHash",T),U=ensureBytes("publicKey",U),"strict"in K)throw new Error("options.strict was renamed to lowS");const{lowS:V,prehash:F}=K;let q,Y;try{if(typeof O=="string"||O instanceof Uint8Array)try{q=x.fromDER(O)}catch(Q){if(!(Q instanceof DER.Err))throw Q;q=x.fromCompact(O)}else if(typeof O=="object"&&typeof O.r=="bigint"&&typeof O.s=="bigint"){const{r:Q,s:se}=O;q=new x(Q,se)}else throw new Error("PARSE");Y=u.fromHex(U)}catch(Q){if(Q.message==="PARSE")throw new Error("signature must be Signature instance, Uint8Array or hex string");return!1}if(V&&q.hasHighS())return!1;F&&(T=e.hash(T));const{r:Z,s:X}=q,te=v(T),J=l(X),oe=c(te*J),ne=c(Z*J),re=(ie=u.BASE.multiplyAndAddUnsafe(Y,oe,ne))==null?void 0:ie.toAffine();return re?c(re.x)===Z:!1}return{CURVE:e,getPublicKey:R,getSharedSecret:A,sign:B,verify:H,ProjectivePoint:u,Signature:x,utils:_}}let HMAC$1=class extends Hash$1{constructor(e,n){super(),this.finished=!1,this.destroyed=!1,hash$1(e);const r=toBytes$1(n);if(this.iHash=e.create(),typeof this.iHash.update!="function")throw new Error("Expected instance of class which extends utils.Hash");this.blockLen=this.iHash.blockLen,this.outputLen=this.iHash.outputLen;const s=this.blockLen,o=new Uint8Array(s);o.set(r.length>s?e.create().update(r).digest():r);for(let a=0;a<o.length;a++)o[a]^=54;this.iHash.update(o),this.oHash=e.create();for(let a=0;a<o.length;a++)o[a]^=106;this.oHash.update(o),o.fill(0)}update(e){return exists$1(this),this.iHash.update(e),this}digestInto(e){exists$1(this),bytes$2(e,this.outputLen),this.finished=!0,this.iHash.digestInto(e),this.oHash.update(e),this.oHash.digestInto(e),this.destroy()}digest(){const e=new Uint8Array(this.oHash.outputLen);return this.digestInto(e),e}_cloneInto(e){e||(e=Object.create(Object.getPrototypeOf(this),{}));const{oHash:n,iHash:r,finished:s,destroyed:o,blockLen:a,outputLen:c}=this;return e=e,e.finished=s,e.destroyed=o,e.blockLen=a,e.outputLen=c,e.oHash=n._cloneInto(e.oHash),e.iHash=r._cloneInto(e.iHash),e}destroy(){this.destroyed=!0,this.oHash.destroy(),this.iHash.destroy()}};const hmac$1=(t,e,n)=>new HMAC$1(t,e).update(n).digest();hmac$1.create=(t,e)=>new HMAC$1(t,e);/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */function getHash(t){return{hash:t,hmac:(e,...n)=>hmac$1(t,e,concatBytes$2(...n)),randomBytes:randomBytes$1}}function createCurve(t,e){const n=r=>weierstrass({...t,...getHash(r)});return Object.freeze({...n(e),create:n})}/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */const secp256k1P=BigInt("0xfffffffffffffffffffffffffffffffffffffffffffffffffffffffefffffc2f"),secp256k1N=BigInt("0xfffffffffffffffffffffffffffffffebaaedce6af48a03bbfd25e8cd0364141"),_1n=BigInt(1),_2n=BigInt(2),divNearest=(t,e)=>(t+e/_2n)/e;function sqrtMod(t){const e=secp256k1P,n=BigInt(3),r=BigInt(6),s=BigInt(11),o=BigInt(22),a=BigInt(23),c=BigInt(44),l=BigInt(88),u=t*t*t%e,h=u*u*t%e,f=pow2(h,n,e)*h%e,p=pow2(f,n,e)*h%e,g=pow2(p,_2n,e)*u%e,w=pow2(g,s,e)*g%e,y=pow2(w,o,e)*w%e,b=pow2(y,c,e)*y%e,x=pow2(b,l,e)*b%e,_=pow2(x,c,e)*y%e,R=pow2(_,n,e)*h%e,$=pow2(R,a,e)*w%e,A=pow2($,r,e)*u%e,L=pow2(A,_2n,e);if(!Fp.eql(Fp.sqr(L),t))throw new Error("Cannot find square root");return L}const Fp=Field(secp256k1P,void 0,void 0,{sqrt:sqrtMod}),secp256k1=createCurve({a:BigInt(0),b:BigInt(7),Fp,n:secp256k1N,Gx:BigInt("55066263022277343669578718895168534326250603453777594175500187360389116729240"),Gy:BigInt("32670510020758816978083085130507043184471273380659243275938904335757337482424"),h:BigInt(1),lowS:!0,endo:{beta:BigInt("0x7ae96a2b657c07106e64479eac3434e99cf0497512f58995c1396c28719501ee"),splitScalar:t=>{const e=secp256k1N,n=BigInt("0x3086d221a7d46bcde86c90e49284eb15"),r=-_1n*BigInt("0xe4437ed6010e88286f547fa90abfe4c3"),s=BigInt("0x114ca50f7a8e2f3f657c1108d9d44cfd8"),o=n,a=BigInt("0x100000000000000000000000000000000"),c=divNearest(o*t,e),l=divNearest(-r*t,e);let u=mod(t-c*n-l*s,e),h=mod(-c*r-l*o,e);const f=u>a,p=h>a;if(f&&(u=e-u),p&&(h=e-h),u>a||h>a)throw new Error("splitScalar: Endomorphism failed, k="+t);return{k1neg:f,k1:u,k2neg:p,k2:h}}}},sha256$2),_0n=BigInt(0),fe=t=>typeof t=="bigint"&&_0n<t&&t<secp256k1P,ge=t=>typeof t=="bigint"&&_0n<t&&t<secp256k1N,TAGGED_HASH_PREFIXES={};function taggedHash(t,...e){let n=TAGGED_HASH_PREFIXES[t];if(n===void 0){const r=sha256$2(Uint8Array.from(t,s=>s.charCodeAt(0)));n=concatBytes$1(r,r),TAGGED_HASH_PREFIXES[t]=n}return sha256$2(concatBytes$1(n,...e))}const pointToBytes=t=>t.toRawBytes(!0).slice(1),numTo32b=t=>numberToBytesBE(t,32),modP=t=>mod(t,secp256k1P),modN=t=>mod(t,secp256k1N),Point=secp256k1.ProjectivePoint,GmulAdd=(t,e,n)=>Point.BASE.multiplyAndAddUnsafe(t,e,n);function schnorrGetExtPubKey(t){let e=secp256k1.utils.normPrivateKeyToScalar(t),n=Point.fromPrivateKey(e);return{scalar:n.hasEvenY()?e:modN(-e),bytes:pointToBytes(n)}}function lift_x(t){if(!fe(t))throw new Error("bad x: need 0 < x < p");const e=modP(t*t),n=modP(e*t+BigInt(7));let r=sqrtMod(n);r%_2n!==_0n&&(r=modP(-r));const s=new Point(t,r,_1n);return s.assertValidity(),s}function challenge(...t){return modN(bytesToNumberBE(taggedHash("BIP0340/challenge",...t)))}function schnorrGetPublicKey(t){return schnorrGetExtPubKey(t).bytes}function schnorrSign(t,e,n=randomBytes$1(32)){const r=ensureBytes("message",t),{bytes:s,scalar:o}=schnorrGetExtPubKey(e),a=ensureBytes("auxRand",n,32),c=numTo32b(o^bytesToNumberBE(taggedHash("BIP0340/aux",a))),l=taggedHash("BIP0340/nonce",c,s,r),u=modN(bytesToNumberBE(l));if(u===_0n)throw new Error("sign failed: k is zero");const{bytes:h,scalar:f}=schnorrGetExtPubKey(u),p=challenge(h,s,r),g=new Uint8Array(64);if(g.set(h,0),g.set(numTo32b(modN(f+p*o)),32),!schnorrVerify(g,r,s))throw new Error("sign: Invalid signature produced");return g}function schnorrVerify(t,e,n){const r=ensureBytes("signature",t,64),s=ensureBytes("message",e),o=ensureBytes("publicKey",n,32);try{const a=lift_x(bytesToNumberBE(o)),c=bytesToNumberBE(r.subarray(0,32));if(!fe(c))return!1;const l=bytesToNumberBE(r.subarray(32,64));if(!ge(l))return!1;const u=challenge(numTo32b(c),pointToBytes(a),s),h=GmulAdd(a,l,modN(-u));return!(!h||!h.hasEvenY()||h.toAffine().x!==c)}catch{return!1}}const schnorr=(()=>({getPublicKey:schnorrGetPublicKey,sign:schnorrSign,verify:schnorrVerify,utils:{randomPrivateKey:secp256k1.utils.randomPrivateKey,lift_x,pointToBytes,numberToBytesBE,bytesToNumberBE,taggedHash,mod}}))(),crypto$1=typeof globalThis=="object"&&"crypto"in globalThis?globalThis.crypto:void 0;/*! noble-hashes - MIT License (c) 2022 Paul Miller (paulmillr.com) */const u8a=t=>t instanceof Uint8Array,createView=t=>new DataView(t.buffer,t.byteOffset,t.byteLength),rotr=(t,e)=>t<<32-e|t>>>e,isLE$1=new Uint8Array(new Uint32Array([287454020]).buffer)[0]===68;if(!isLE$1)throw new Error("Non little-endian hardware is not supported");const hexes=Array.from({length:256},(t,e)=>e.toString(16).padStart(2,"0"));function bytesToHex(t){if(!u8a(t))throw new Error("Uint8Array expected");let e="";for(let n=0;n<t.length;n++)e+=hexes[t[n]];return e}function hexToBytes(t){if(typeof t!="string")throw new Error("hex string expected, got "+typeof t);const e=t.length;if(e%2)throw new Error("padded hex string expected, got unpadded hex of length "+e);const n=new Uint8Array(e/2);for(let r=0;r<n.length;r++){const s=r*2,o=t.slice(s,s+2),a=Number.parseInt(o,16);if(Number.isNaN(a)||a<0)throw new Error("Invalid byte sequence");n[r]=a}return n}function utf8ToBytes(t){if(typeof t!="string")throw new Error(`utf8ToBytes expected string, got ${typeof t}`);return new Uint8Array(new TextEncoder().encode(t))}function toBytes(t){if(typeof t=="string"&&(t=utf8ToBytes(t)),!u8a(t))throw new Error(`expected Uint8Array, got ${typeof t}`);return t}function concatBytes(...t){const e=new Uint8Array(t.reduce((r,s)=>r+s.length,0));let n=0;return t.forEach(r=>{if(!u8a(r))throw new Error("Uint8Array expected");e.set(r,n),n+=r.length}),e}class Hash{clone(){return this._cloneInto()}}function wrapConstructor(t){const e=r=>t().update(toBytes(r)).digest(),n=t();return e.outputLen=n.outputLen,e.blockLen=n.blockLen,e.create=()=>t(),e}function randomBytes(t=32){if(crypto$1&&typeof crypto$1.getRandomValues=="function")return crypto$1.getRandomValues(new Uint8Array(t));throw new Error("crypto.getRandomValues must be defined")}function number$1(t){if(!Number.isSafeInteger(t)||t<0)throw new Error(`Wrong positive integer: ${t}`)}function bool$1(t){if(typeof t!="boolean")throw new Error(`Expected boolean, not ${t}`)}function bytes$1(t,...e){if(!(t instanceof Uint8Array))throw new Error("Expected Uint8Array");if(e.length>0&&!e.includes(t.length))throw new Error(`Expected Uint8Array of length ${e}, not of length=${t.length}`)}function hash(t){if(typeof t!="function"||typeof t.create!="function")throw new Error("Hash should be wrapped by utils.wrapConstructor");number$1(t.outputLen),number$1(t.blockLen)}function exists(t,e=!0){if(t.destroyed)throw new Error("Hash instance has been destroyed");if(e&&t.finished)throw new Error("Hash#digest() has already been called")}function output(t,e){bytes$1(t);const n=e.outputLen;if(t.length<n)throw new Error(`digestInto() expects output buffer of length at least ${n}`)}const assert={number:number$1,bool:bool$1,bytes:bytes$1,hash,exists,output};function setBigUint64(t,e,n,r){if(typeof t.setBigUint64=="function")return t.setBigUint64(e,n,r);const s=BigInt(32),o=BigInt(4294967295),a=Number(n>>s&o),c=Number(n&o),l=r?4:0,u=r?0:4;t.setUint32(e+l,a,r),t.setUint32(e+u,c,r)}class SHA2 extends Hash{constructor(e,n,r,s){super(),this.blockLen=e,this.outputLen=n,this.padOffset=r,this.isLE=s,this.finished=!1,this.length=0,this.pos=0,this.destroyed=!1,this.buffer=new Uint8Array(e),this.view=createView(this.buffer)}update(e){assert.exists(this);const{view:n,buffer:r,blockLen:s}=this;e=toBytes(e);const o=e.length;for(let a=0;a<o;){const c=Math.min(s-this.pos,o-a);if(c===s){const l=createView(e);for(;s<=o-a;a+=s)this.process(l,a);continue}r.set(e.subarray(a,a+c),this.pos),this.pos+=c,a+=c,this.pos===s&&(this.process(n,0),this.pos=0)}return this.length+=e.length,this.roundClean(),this}digestInto(e){assert.exists(this),assert.output(e,this),this.finished=!0;const{buffer:n,view:r,blockLen:s,isLE:o}=this;let{pos:a}=this;n[a++]=128,this.buffer.subarray(a).fill(0),this.padOffset>s-a&&(this.process(r,0),a=0);for(let f=a;f<s;f++)n[f]=0;setBigUint64(r,s-8,BigInt(this.length*8),o),this.process(r,0);const c=createView(e),l=this.outputLen;if(l%4)throw new Error("_sha2: outputLen should be aligned to 32bit");const u=l/4,h=this.get();if(u>h.length)throw new Error("_sha2: outputLen bigger than state");for(let f=0;f<u;f++)c.setUint32(4*f,h[f],o)}digest(){const{buffer:e,outputLen:n}=this;this.digestInto(e);const r=e.slice(0,n);return this.destroy(),r}_cloneInto(e){e||(e=new this.constructor),e.set(...this.get());const{blockLen:n,buffer:r,length:s,finished:o,destroyed:a,pos:c}=this;return e.length=s,e.pos=c,e.finished=o,e.destroyed=a,s%n&&e.buffer.set(r),e}}const Chi=(t,e,n)=>t&e^~t&n,Maj=(t,e,n)=>t&e^t&n^e&n,SHA256_K=new Uint32Array([1116352408,1899447441,3049323471,3921009573,961987163,1508970993,2453635748,2870763221,3624381080,310598401,607225278,1426881987,1925078388,2162078206,2614888103,3248222580,3835390401,4022224774,264347078,604807628,770255983,1249150122,1555081692,1996064986,2554220882,2821834349,2952996808,3210313671,3336571891,3584528711,113926993,338241895,666307205,773529912,1294757372,1396182291,1695183700,1986661051,2177026350,2456956037,2730485921,2820302411,3259730800,3345764771,3516065817,3600352804,4094571909,275423344,430227734,506948616,659060556,883997877,958139571,1322822218,1537002063,1747873779,1955562222,2024104815,2227730452,2361852424,2428436474,2756734187,3204031479,3329325298]),IV=new Uint32Array([1779033703,3144134277,1013904242,2773480762,1359893119,2600822924,528734635,1541459225]),SHA256_W=new Uint32Array(64);class SHA256 extends SHA2{constructor(){super(64,32,8,!1),this.A=IV[0]|0,this.B=IV[1]|0,this.C=IV[2]|0,this.D=IV[3]|0,this.E=IV[4]|0,this.F=IV[5]|0,this.G=IV[6]|0,this.H=IV[7]|0}get(){const{A:e,B:n,C:r,D:s,E:o,F:a,G:c,H:l}=this;return[e,n,r,s,o,a,c,l]}set(e,n,r,s,o,a,c,l){this.A=e|0,this.B=n|0,this.C=r|0,this.D=s|0,this.E=o|0,this.F=a|0,this.G=c|0,this.H=l|0}process(e,n){for(let f=0;f<16;f++,n+=4)SHA256_W[f]=e.getUint32(n,!1);for(let f=16;f<64;f++){const p=SHA256_W[f-15],g=SHA256_W[f-2],w=rotr(p,7)^rotr(p,18)^p>>>3,y=rotr(g,17)^rotr(g,19)^g>>>10;SHA256_W[f]=y+SHA256_W[f-7]+w+SHA256_W[f-16]|0}let{A:r,B:s,C:o,D:a,E:c,F:l,G:u,H:h}=this;for(let f=0;f<64;f++){const p=rotr(c,6)^rotr(c,11)^rotr(c,25),g=h+p+Chi(c,l,u)+SHA256_K[f]+SHA256_W[f]|0,y=(rotr(r,2)^rotr(r,13)^rotr(r,22))+Maj(r,s,o)|0;h=u,u=l,l=c,c=a+g|0,a=o,o=s,s=r,r=g+y|0}r=r+this.A|0,s=s+this.B|0,o=o+this.C|0,a=a+this.D|0,c=c+this.E|0,l=l+this.F|0,u=u+this.G|0,h=h+this.H|0,this.set(r,s,o,a,c,l,u,h)}roundClean(){SHA256_W.fill(0)}destroy(){this.set(0,0,0,0,0,0,0,0),this.buffer.fill(0)}}class SHA224 extends SHA256{constructor(){super(),this.A=-1056596264,this.B=914150663,this.C=812702999,this.D=-150054599,this.E=-4191439,this.F=1750603025,this.G=1694076839,this.H=-1090891868,this.outputLen=28}}const sha256$1=wrapConstructor(()=>new SHA256);wrapConstructor(()=>new SHA224);/*! scure-base - MIT License (c) 2022 Paul Miller (paulmillr.com) */function assertNumber(t){if(!Number.isSafeInteger(t))throw new Error(`Wrong integer: ${t}`)}function chain(...t){const e=(s,o)=>a=>s(o(a)),n=Array.from(t).reverse().reduce((s,o)=>s?e(s,o.encode):o.encode,void 0),r=t.reduce((s,o)=>s?e(s,o.decode):o.decode,void 0);return{encode:n,decode:r}}function alphabet(t){return{encode:e=>{if(!Array.isArray(e)||e.length&&typeof e[0]!="number")throw new Error("alphabet.encode input should be an array of numbers");return e.map(n=>{if(assertNumber(n),n<0||n>=t.length)throw new Error(`Digit index outside alphabet: ${n} (alphabet: ${t.length})`);return t[n]})},decode:e=>{if(!Array.isArray(e)||e.length&&typeof e[0]!="string")throw new Error("alphabet.decode input should be array of strings");return e.map(n=>{if(typeof n!="string")throw new Error(`alphabet.decode: not string element=${n}`);const r=t.indexOf(n);if(r===-1)throw new Error(`Unknown letter: "${n}". Allowed: ${t}`);return r})}}}function join(t=""){if(typeof t!="string")throw new Error("join separator should be string");return{encode:e=>{if(!Array.isArray(e)||e.length&&typeof e[0]!="string")throw new Error("join.encode input should be array of strings");for(let n of e)if(typeof n!="string")throw new Error(`join.encode: non-string input=${n}`);return e.join(t)},decode:e=>{if(typeof e!="string")throw new Error("join.decode input should be string");return e.split(t)}}}function padding(t,e="="){if(assertNumber(t),typeof e!="string")throw new Error("padding chr should be string");return{encode(n){if(!Array.isArray(n)||n.length&&typeof n[0]!="string")throw new Error("padding.encode input should be array of strings");for(let r of n)if(typeof r!="string")throw new Error(`padding.encode: non-string input=${r}`);for(;n.length*t%8;)n.push(e);return n},decode(n){if(!Array.isArray(n)||n.length&&typeof n[0]!="string")throw new Error("padding.encode input should be array of strings");for(let s of n)if(typeof s!="string")throw new Error(`padding.decode: non-string input=${s}`);let r=n.length;if(r*t%8)throw new Error("Invalid padding: string should have whole number of bytes");for(;r>0&&n[r-1]===e;r--)if(!((r-1)*t%8))throw new Error("Invalid padding: string has too much padding");return n.slice(0,r)}}}function normalize$1(t){if(typeof t!="function")throw new Error("normalize fn should be function");return{encode:e=>e,decode:e=>t(e)}}function convertRadix(t,e,n){if(e<2)throw new Error(`convertRadix: wrong from=${e}, base cannot be less than 2`);if(n<2)throw new Error(`convertRadix: wrong to=${n}, base cannot be less than 2`);if(!Array.isArray(t))throw new Error("convertRadix: data should be array");if(!t.length)return[];let r=0;const s=[],o=Array.from(t);for(o.forEach(a=>{if(assertNumber(a),a<0||a>=e)throw new Error(`Wrong integer: ${a}`)});;){let a=0,c=!0;for(let l=r;l<o.length;l++){const u=o[l],h=e*a+u;if(!Number.isSafeInteger(h)||e*a/e!==a||h-u!==e*a)throw new Error("convertRadix: carry overflow");if(a=h%n,o[l]=Math.floor(h/n),!Number.isSafeInteger(o[l])||o[l]*n+a!==h)throw new Error("convertRadix: carry overflow");if(c)o[l]?c=!1:r=l;else continue}if(s.push(a),c)break}for(let a=0;a<t.length-1&&t[a]===0;a++)s.push(0);return s.reverse()}const gcd=(t,e)=>e?gcd(e,t%e):t,radix2carry=(t,e)=>t+(e-gcd(t,e));function convertRadix2(t,e,n,r){if(!Array.isArray(t))throw new Error("convertRadix2: data should be array");if(e<=0||e>32)throw new Error(`convertRadix2: wrong from=${e}`);if(n<=0||n>32)throw new Error(`convertRadix2: wrong to=${n}`);if(radix2carry(e,n)>32)throw new Error(`convertRadix2: carry overflow from=${e} to=${n} carryBits=${radix2carry(e,n)}`);let s=0,o=0;const a=2**n-1,c=[];for(const l of t){if(assertNumber(l),l>=2**e)throw new Error(`convertRadix2: invalid data word=${l} from=${e}`);if(s=s<<e|l,o+e>32)throw new Error(`convertRadix2: carry overflow pos=${o} from=${e}`);for(o+=e;o>=n;o-=n)c.push((s>>o-n&a)>>>0);s&=2**o-1}if(s=s<<n-o&a,!r&&o>=e)throw new Error("Excess padding");if(!r&&s)throw new Error(`Non-zero padding: ${s}`);return r&&o>0&&c.push(s>>>0),c}function radix(t){return assertNumber(t),{encode:e=>{if(!(e instanceof Uint8Array))throw new Error("radix.encode input should be Uint8Array");return convertRadix(Array.from(e),2**8,t)},decode:e=>{if(!Array.isArray(e)||e.length&&typeof e[0]!="number")throw new Error("radix.decode input should be array of strings");return Uint8Array.from(convertRadix(e,t,2**8))}}}function radix2(t,e=!1){if(assertNumber(t),t<=0||t>32)throw new Error("radix2: bits should be in (0..32]");if(radix2carry(8,t)>32||radix2carry(t,8)>32)throw new Error("radix2: carry overflow");return{encode:n=>{if(!(n instanceof Uint8Array))throw new Error("radix2.encode input should be Uint8Array");return convertRadix2(Array.from(n),8,t,!e)},decode:n=>{if(!Array.isArray(n)||n.length&&typeof n[0]!="number")throw new Error("radix2.decode input should be array of strings");return Uint8Array.from(convertRadix2(n,t,8,e))}}}function unsafeWrapper(t){if(typeof t!="function")throw new Error("unsafeWrapper fn should be function");return function(...e){try{return t.apply(null,e)}catch{}}}const base16=chain(radix2(4),alphabet("0123456789ABCDEF"),join("")),base32=chain(radix2(5),alphabet("ABCDEFGHIJKLMNOPQRSTUVWXYZ234567"),padding(5),join(""));chain(radix2(5),alphabet("0123456789ABCDEFGHIJKLMNOPQRSTUV"),padding(5),join(""));chain(radix2(5),alphabet("0123456789ABCDEFGHJKMNPQRSTVWXYZ"),join(""),normalize$1(t=>t.toUpperCase().replace(/O/g,"0").replace(/[IL]/g,"1")));const base64=chain(radix2(6),alphabet("ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/"),padding(6),join("")),base64url=chain(radix2(6),alphabet("ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-_"),padding(6),join("")),genBase58=t=>chain(radix(58),alphabet(t),join("")),base58=genBase58("123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz");genBase58("123456789abcdefghijkmnopqrstuvwxyzABCDEFGHJKLMNPQRSTUVWXYZ");genBase58("rpshnaf39wBUDNEGHJKLM4PQRST7VWXYZ2bcdeCg65jkm8oFqi1tuvAxyz");const XMR_BLOCK_LEN=[0,2,3,5,6,7,9,10,11],base58xmr={encode(t){let e="";for(let n=0;n<t.length;n+=8){const r=t.subarray(n,n+8);e+=base58.encode(r).padStart(XMR_BLOCK_LEN[r.length],"1")}return e},decode(t){let e=[];for(let n=0;n<t.length;n+=11){const r=t.slice(n,n+11),s=XMR_BLOCK_LEN.indexOf(r.length),o=base58.decode(r);for(let a=0;a<o.length-s;a++)if(o[a]!==0)throw new Error("base58xmr: wrong padding");e=e.concat(Array.from(o.slice(o.length-s)))}return Uint8Array.from(e)}},BECH_ALPHABET=chain(alphabet("qpzry9x8gf2tvdw0s3jn54khce6mua7l"),join("")),POLYMOD_GENERATORS=[996825010,642813549,513874426,1027748829,705979059];function bech32Polymod(t){const e=t>>25;let n=(t&33554431)<<5;for(let r=0;r<POLYMOD_GENERATORS.length;r++)(e>>r&1)===1&&(n^=POLYMOD_GENERATORS[r]);return n}function bechChecksum(t,e,n=1){const r=t.length;let s=1;for(let o=0;o<r;o++){const a=t.charCodeAt(o);if(a<33||a>126)throw new Error(`Invalid prefix (${t})`);s=bech32Polymod(s)^a>>5}s=bech32Polymod(s);for(let o=0;o<r;o++)s=bech32Polymod(s)^t.charCodeAt(o)&31;for(let o of e)s=bech32Polymod(s)^o;for(let o=0;o<6;o++)s=bech32Polymod(s);return s^=n,BECH_ALPHABET.encode(convertRadix2([s%2**30],30,5,!1))}function genBech32(t){const e=t==="bech32"?1:734539939,n=radix2(5),r=n.decode,s=n.encode,o=unsafeWrapper(r);function a(h,f,p=90){if(typeof h!="string")throw new Error(`bech32.encode prefix should be string, not ${typeof h}`);if(!Array.isArray(f)||f.length&&typeof f[0]!="number")throw new Error(`bech32.encode words should be array of numbers, not ${typeof f}`);const g=h.length+7+f.length;if(p!==!1&&g>p)throw new TypeError(`Length ${g} exceeds limit ${p}`);return h=h.toLowerCase(),`${h}1${BECH_ALPHABET.encode(f)}${bechChecksum(h,f,e)}`}function c(h,f=90){if(typeof h!="string")throw new Error(`bech32.decode input should be string, not ${typeof h}`);if(h.length<8||f!==!1&&h.length>f)throw new TypeError(`Wrong string length: ${h.length} (${h}). Expected (8..${f})`);const p=h.toLowerCase();if(h!==p&&h!==h.toUpperCase())throw new Error("String must be lowercase or uppercase");h=p;const g=h.lastIndexOf("1");if(g===0||g===-1)throw new Error('Letter "1" must be present between prefix and data only');const w=h.slice(0,g),y=h.slice(g+1);if(y.length<6)throw new Error("Data must be at least 6 characters long");const b=BECH_ALPHABET.decode(y).slice(0,-6),x=bechChecksum(w,b,e);if(!y.endsWith(x))throw new Error(`Invalid checksum in ${h}: expected "${x}"`);return{prefix:w,words:b}}const l=unsafeWrapper(c);function u(h){const{prefix:f,words:p}=c(h,!1);return{prefix:f,words:p,bytes:r(p)}}return{encode:a,decode:c,decodeToBytes:u,decodeUnsafe:l,fromWords:r,fromWordsUnsafe:o,toWords:s}}const bech32=genBech32("bech32");genBech32("bech32m");const utf8={encode:t=>new TextDecoder().decode(t),decode:t=>new TextEncoder().encode(t)},hex=chain(radix2(4),alphabet("0123456789abcdef"),join(""),normalize$1(t=>{if(typeof t!="string"||t.length%2)throw new TypeError(`hex.decode: expected string, got ${typeof t} with length ${t.length}`);return t.toLowerCase()})),CODERS={utf8,hex,base16,base32,base64,base64url,base58,base58xmr};`${Object.keys(CODERS).join(", ")}`;function number(t){if(!Number.isSafeInteger(t)||t<0)throw new Error(`positive integer expected, not ${t}`)}function bool(t){if(typeof t!="boolean")throw new Error(`boolean expected, not ${t}`)}function isBytes(t){return t instanceof Uint8Array||t!=null&&typeof t=="object"&&t.constructor.name==="Uint8Array"}function bytes(t,...e){if(!isBytes(t))throw new Error("Uint8Array expected");if(e.length>0&&!e.includes(t.length))throw new Error(`Uint8Array expected of length ${e}, not of length=${t.length}`)}/*! noble-ciphers - MIT License (c) 2023 Paul Miller (paulmillr.com) */const u32=t=>new Uint32Array(t.buffer,t.byteOffset,Math.floor(t.byteLength/4)),isLE=new Uint8Array(new Uint32Array([287454020]).buffer)[0]===68;if(!isLE)throw new Error("Non little-endian hardware is not supported");function checkOpts(t,e){if(e==null||typeof e!="object")throw new Error("options must be defined");return Object.assign(t,e)}function equalBytes(t,e){if(t.length!==e.length)return!1;let n=0;for(let r=0;r<t.length;r++)n|=t[r]^e[r];return n===0}const wrapCipher=(t,e)=>(Object.assign(e,t),e),BLOCK_SIZE=16,POLY=283;function mul2(t){return t<<1^POLY&-(t>>7)}function mul(t,e){let n=0;for(;e>0;e>>=1)n^=t&-(e&1),t=mul2(t);return n}const sbox=(()=>{let t=new Uint8Array(256);for(let n=0,r=1;n<256;n++,r^=mul2(r))t[n]=r;const e=new Uint8Array(256);e[0]=99;for(let n=0;n<255;n++){let r=t[255-n];r|=r<<8,e[t[n]]=(r^r>>4^r>>5^r>>6^r>>7^99)&255}return e})(),invSbox=sbox.map((t,e)=>sbox.indexOf(e)),rotr32_8=t=>t<<24|t>>>8,rotl32_8=t=>t<<8|t>>>24;function genTtable(t,e){if(t.length!==256)throw new Error("Wrong sbox length");const n=new Uint32Array(256).map((u,h)=>e(t[h])),r=n.map(rotl32_8),s=r.map(rotl32_8),o=s.map(rotl32_8),a=new Uint32Array(256*256),c=new Uint32Array(256*256),l=new Uint16Array(256*256);for(let u=0;u<256;u++)for(let h=0;h<256;h++){const f=u*256+h;a[f]=n[u]^r[h],c[f]=s[u]^o[h],l[f]=t[u]<<8|t[h]}return{sbox:t,sbox2:l,T0:n,T1:r,T2:s,T3:o,T01:a,T23:c}}const tableEncoding=genTtable(sbox,t=>mul(t,3)<<24|t<<16|t<<8|mul(t,2)),tableDecoding=genTtable(invSbox,t=>mul(t,11)<<24|mul(t,13)<<16|mul(t,9)<<8|mul(t,14)),xPowers=(()=>{const t=new Uint8Array(16);for(let e=0,n=1;e<16;e++,n=mul2(n))t[e]=n;return t})();function expandKeyLE(t){bytes(t);const e=t.length;if(![16,24,32].includes(e))throw new Error(`aes: wrong key size: should be 16, 24 or 32, got: ${e}`);const{sbox2:n}=tableEncoding,r=u32(t),s=r.length,o=c=>applySbox(n,c,c,c,c),a=new Uint32Array(e+28);a.set(r);for(let c=s;c<a.length;c++){let l=a[c-1];c%s===0?l=o(rotr32_8(l))^xPowers[c/s-1]:s>6&&c%s===4&&(l=o(l)),a[c]=a[c-s]^l}return a}function expandKeyDecLE(t){const e=expandKeyLE(t),n=e.slice(),r=e.length,{sbox2:s}=tableEncoding,{T0:o,T1:a,T2:c,T3:l}=tableDecoding;for(let u=0;u<r;u+=4)for(let h=0;h<4;h++)n[u+h]=e[r-u-4+h];e.fill(0);for(let u=4;u<r-4;u++){const h=n[u],f=applySbox(s,h,h,h,h);n[u]=o[f&255]^a[f>>>8&255]^c[f>>>16&255]^l[f>>>24]}return n}function apply0123(t,e,n,r,s,o){return t[n<<8&65280|r>>>8&255]^e[s>>>8&65280|o>>>24&255]}function applySbox(t,e,n,r,s){return t[e&255|n&65280]|t[r>>>16&255|s>>>16&65280]<<16}function encrypt$2(t,e,n,r,s){const{sbox2:o,T01:a,T23:c}=tableEncoding;let l=0;e^=t[l++],n^=t[l++],r^=t[l++],s^=t[l++];const u=t.length/4-2;for(let w=0;w<u;w++){const y=t[l++]^apply0123(a,c,e,n,r,s),b=t[l++]^apply0123(a,c,n,r,s,e),x=t[l++]^apply0123(a,c,r,s,e,n),_=t[l++]^apply0123(a,c,s,e,n,r);e=y,n=b,r=x,s=_}const h=t[l++]^applySbox(o,e,n,r,s),f=t[l++]^applySbox(o,n,r,s,e),p=t[l++]^applySbox(o,r,s,e,n),g=t[l++]^applySbox(o,s,e,n,r);return{s0:h,s1:f,s2:p,s3:g}}function decrypt$2(t,e,n,r,s){const{sbox2:o,T01:a,T23:c}=tableDecoding;let l=0;e^=t[l++],n^=t[l++],r^=t[l++],s^=t[l++];const u=t.length/4-2;for(let w=0;w<u;w++){const y=t[l++]^apply0123(a,c,e,s,r,n),b=t[l++]^apply0123(a,c,n,e,s,r),x=t[l++]^apply0123(a,c,r,n,e,s),_=t[l++]^apply0123(a,c,s,r,n,e);e=y,n=b,r=x,s=_}const h=t[l++]^applySbox(o,e,s,r,n),f=t[l++]^applySbox(o,n,e,s,r),p=t[l++]^applySbox(o,r,n,e,s),g=t[l++]^applySbox(o,s,r,n,e);return{s0:h,s1:f,s2:p,s3:g}}function getDst(t,e){if(!e)return new Uint8Array(t);if(bytes(e),e.length<t)throw new Error(`aes: wrong destination length, expected at least ${t}, got: ${e.length}`);return e}function validateBlockDecrypt(t){if(bytes(t),t.length%BLOCK_SIZE!==0)throw new Error(`aes/(cbc-ecb).decrypt ciphertext should consist of blocks with size ${BLOCK_SIZE}`)}function validateBlockEncrypt(t,e,n){let r=t.length;const s=r%BLOCK_SIZE;if(!e&&s!==0)throw new Error("aec/(cbc-ecb): unpadded plaintext with disabled padding");const o=u32(t);if(e){let l=BLOCK_SIZE-s;l||(l=BLOCK_SIZE),r=r+l}const a=getDst(r,n),c=u32(a);return{b:o,o:c,out:a}}function validatePCKS(t,e){if(!e)return t;const n=t.length;if(!n)throw new Error("aes/pcks5: empty ciphertext not allowed");const r=t[n-1];if(r<=0||r>16)throw new Error(`aes/pcks5: wrong padding byte: ${r}`);const s=t.subarray(0,-r);for(let o=0;o<r;o++)if(t[n-o-1]!==r)throw new Error("aes/pcks5: wrong padding");return s}function padPCKS(t){const e=new Uint8Array(16),n=u32(e);e.set(t);const r=BLOCK_SIZE-t.length;for(let s=BLOCK_SIZE-r;s<BLOCK_SIZE;s++)e[s]=r;return n}const cbc=wrapCipher({blockSize:16,nonceLength:16},function t(e,n,r={}){bytes(e),bytes(n,16);const s=!r.disablePadding;return{encrypt:(o,a)=>{const c=expandKeyLE(e),{b:l,o:u,out:h}=validateBlockEncrypt(o,s,a),f=u32(n);let p=f[0],g=f[1],w=f[2],y=f[3],b=0;for(;b+4<=l.length;)p^=l[b+0],g^=l[b+1],w^=l[b+2],y^=l[b+3],{s0:p,s1:g,s2:w,s3:y}=encrypt$2(c,p,g,w,y),u[b++]=p,u[b++]=g,u[b++]=w,u[b++]=y;if(s){const x=padPCKS(o.subarray(b*4));p^=x[0],g^=x[1],w^=x[2],y^=x[3],{s0:p,s1:g,s2:w,s3:y}=encrypt$2(c,p,g,w,y),u[b++]=p,u[b++]=g,u[b++]=w,u[b++]=y}return c.fill(0),h},decrypt:(o,a)=>{validateBlockDecrypt(o);const c=expandKeyDecLE(e),l=u32(n),u=getDst(o.length,a),h=u32(o),f=u32(u);let p=l[0],g=l[1],w=l[2],y=l[3];for(let b=0;b+4<=h.length;){const x=p,_=g,R=w,$=y;p=h[b+0],g=h[b+1],w=h[b+2],y=h[b+3];const{s0:A,s1:L,s2:v,s3:D}=decrypt$2(c,p,g,w,y);f[b++]=A^x,f[b++]=L^_,f[b++]=v^R,f[b++]=D^$}return c.fill(0),validatePCKS(u,s)}}}),_utf8ToBytes=t=>Uint8Array.from(t.split("").map(e=>e.charCodeAt(0))),sigma16=_utf8ToBytes("expand 16-byte k"),sigma32=_utf8ToBytes("expand 32-byte k"),sigma16_32=u32(sigma16),sigma32_32=u32(sigma32);sigma32_32.slice();function rotl(t,e){return t<<e|t>>>32-e}function isAligned32(t){return t.byteOffset%4===0}const BLOCK_LEN=64,BLOCK_LEN32=16,MAX_COUNTER=2**32-1,U32_EMPTY=new Uint32Array;function runCipher(t,e,n,r,s,o,a,c){const l=s.length,u=new Uint8Array(BLOCK_LEN),h=u32(u),f=isAligned32(s)&&isAligned32(o),p=f?u32(s):U32_EMPTY,g=f?u32(o):U32_EMPTY;for(let w=0;w<l;a++){if(t(e,n,r,h,a,c),a>=MAX_COUNTER)throw new Error("arx: counter overflow");const y=Math.min(BLOCK_LEN,l-w);if(f&&y===BLOCK_LEN){const b=w/4;if(w%4!==0)throw new Error("arx: invalid block position");for(let x=0,_;x<BLOCK_LEN32;x++)_=b+x,g[_]=p[_]^h[x];w+=BLOCK_LEN;continue}for(let b=0,x;b<y;b++)x=w+b,o[x]=s[x]^u[b];w+=y}}function createCipher(t,e){const{allowShortKeys:n,extendNonceFn:r,counterLength:s,counterRight:o,rounds:a}=checkOpts({allowShortKeys:!1,counterLength:8,counterRight:!1,rounds:20},e);if(typeof t!="function")throw new Error("core must be a function");return number(s),number(a),bool(o),bool(n),(c,l,u,h,f=0)=>{bytes(c),bytes(l),bytes(u);const p=u.length;if(h||(h=new Uint8Array(p)),bytes(h),number(f),f<0||f>=MAX_COUNTER)throw new Error("arx: counter overflow");if(h.length<p)throw new Error(`arx: output (${h.length}) is shorter than data (${p})`);const g=[];let w=c.length,y,b;if(w===32)y=c.slice(),g.push(y),b=sigma32_32;else if(w===16&&n)y=new Uint8Array(32),y.set(c),y.set(c,16),b=sigma16_32,g.push(y);else throw new Error(`arx: invalid 32-byte key, got length=${w}`);isAligned32(l)||(l=l.slice(),g.push(l));const x=u32(y);if(r){if(l.length!==24)throw new Error("arx: extended nonce must be 24 bytes");r(b,x,u32(l.subarray(0,16)),x),l=l.subarray(16)}const _=16-s;if(_!==l.length)throw new Error(`arx: nonce must be ${_} or 16 bytes`);if(_!==12){const $=new Uint8Array(12);$.set(l,o?0:12-l.length),l=$,g.push(l)}const R=u32(l);for(runCipher(t,b,x,R,u,h,f,a);g.length>0;)g.pop().fill(0);return h}}function chachaCore(t,e,n,r,s,o=20){let a=t[0],c=t[1],l=t[2],u=t[3],h=e[0],f=e[1],p=e[2],g=e[3],w=e[4],y=e[5],b=e[6],x=e[7],_=s,R=n[0],$=n[1],A=n[2],L=a,v=c,D=l,j=u,z=h,E=f,k=p,B=g,H=w,S=y,T=b,U=x,K=_,O=R,V=$,F=A;for(let Y=0;Y<o;Y+=2)L=L+z|0,K=rotl(K^L,16),H=H+K|0,z=rotl(z^H,12),L=L+z|0,K=rotl(K^L,8),H=H+K|0,z=rotl(z^H,7),v=v+E|0,O=rotl(O^v,16),S=S+O|0,E=rotl(E^S,12),v=v+E|0,O=rotl(O^v,8),S=S+O|0,E=rotl(E^S,7),D=D+k|0,V=rotl(V^D,16),T=T+V|0,k=rotl(k^T,12),D=D+k|0,V=rotl(V^D,8),T=T+V|0,k=rotl(k^T,7),j=j+B|0,F=rotl(F^j,16),U=U+F|0,B=rotl(B^U,12),j=j+B|0,F=rotl(F^j,8),U=U+F|0,B=rotl(B^U,7),L=L+E|0,F=rotl(F^L,16),T=T+F|0,E=rotl(E^T,12),L=L+E|0,F=rotl(F^L,8),T=T+F|0,E=rotl(E^T,7),v=v+k|0,K=rotl(K^v,16),U=U+K|0,k=rotl(k^U,12),v=v+k|0,K=rotl(K^v,8),U=U+K|0,k=rotl(k^U,7),D=D+B|0,O=rotl(O^D,16),H=H+O|0,B=rotl(B^H,12),D=D+B|0,O=rotl(O^D,8),H=H+O|0,B=rotl(B^H,7),j=j+z|0,V=rotl(V^j,16),S=S+V|0,z=rotl(z^S,12),j=j+z|0,V=rotl(V^j,8),S=S+V|0,z=rotl(z^S,7);let q=0;r[q++]=a+L|0,r[q++]=c+v|0,r[q++]=l+D|0,r[q++]=u+j|0,r[q++]=h+z|0,r[q++]=f+E|0,r[q++]=p+k|0,r[q++]=g+B|0,r[q++]=w+H|0,r[q++]=y+S|0,r[q++]=b+T|0,r[q++]=x+U|0,r[q++]=_+K|0,r[q++]=R+O|0,r[q++]=$+V|0,r[q++]=A+F|0}const chacha20=createCipher(chachaCore,{counterRight:!1,counterLength:4,allowShortKeys:!1});class HMAC extends Hash{constructor(e,n){super(),this.finished=!1,this.destroyed=!1,assert.hash(e);const r=toBytes(n);if(this.iHash=e.create(),typeof this.iHash.update!="function")throw new Error("Expected instance of class which extends utils.Hash");this.blockLen=this.iHash.blockLen,this.outputLen=this.iHash.outputLen;const s=this.blockLen,o=new Uint8Array(s);o.set(r.length>s?e.create().update(r).digest():r);for(let a=0;a<o.length;a++)o[a]^=54;this.iHash.update(o),this.oHash=e.create();for(let a=0;a<o.length;a++)o[a]^=106;this.oHash.update(o),o.fill(0)}update(e){return assert.exists(this),this.iHash.update(e),this}digestInto(e){assert.exists(this),assert.bytes(e,this.outputLen),this.finished=!0,this.iHash.digestInto(e),this.oHash.update(e),this.oHash.digestInto(e),this.destroy()}digest(){const e=new Uint8Array(this.oHash.outputLen);return this.digestInto(e),e}_cloneInto(e){e||(e=Object.create(Object.getPrototypeOf(this),{}));const{oHash:n,iHash:r,finished:s,destroyed:o,blockLen:a,outputLen:c}=this;return e=e,e.finished=s,e.destroyed=o,e.blockLen=a,e.outputLen=c,e.oHash=n._cloneInto(e.oHash),e.iHash=r._cloneInto(e.iHash),e}destroy(){this.destroyed=!0,this.oHash.destroy(),this.iHash.destroy()}}const hmac=(t,e,n)=>new HMAC(t,e).update(n).digest();hmac.create=(t,e)=>new HMAC(t,e);function extract(t,e,n){return assert.hash(t),n===void 0&&(n=new Uint8Array(t.outputLen)),hmac(t,toBytes(n),toBytes(e))}const HKDF_COUNTER=new Uint8Array([0]),EMPTY_BUFFER=new Uint8Array;function expand(t,e,n,r=32){if(assert.hash(t),assert.number(r),r>255*t.outputLen)throw new Error("Length should be <= 255*HashLen");const s=Math.ceil(r/t.outputLen);n===void 0&&(n=EMPTY_BUFFER);const o=new Uint8Array(s*t.outputLen),a=hmac.create(t,e),c=a._cloneInto(),l=new Uint8Array(a.outputLen);for(let u=0;u<s;u++)HKDF_COUNTER[0]=u+1,c.update(u===0?EMPTY_BUFFER:l).update(n).update(HKDF_COUNTER).digestInto(l),o.set(l,t.outputLen*u),a._cloneInto(c);return a.destroy(),c.destroy(),l.fill(0),HKDF_COUNTER.fill(0),o.slice(0,r)}var __defProp=Object.defineProperty,__export=(t,e)=>{for(var n in e)__defProp(t,n,{get:e[n],enumerable:!0})},verifiedSymbol=Symbol("verified"),isRecord=t=>t instanceof Object;function validateEvent(t){if(!isRecord(t)||typeof t.kind!="number"||typeof t.content!="string"||typeof t.created_at!="number"||typeof t.pubkey!="string"||!t.pubkey.match(/^[a-f0-9]{64}$/)||!Array.isArray(t.tags))return!1;for(let e=0;e<t.tags.length;e++){let n=t.tags[e];if(!Array.isArray(n))return!1;for(let r=0;r<n.length;r++)if(typeof n[r]!="string")return!1}return!0}var utils_exports={};__export(utils_exports,{Queue:()=>Queue$1,QueueNode:()=>QueueNode,binarySearch:()=>binarySearch,bytesToHex:()=>bytesToHex,hexToBytes:()=>hexToBytes,insertEventIntoAscendingList:()=>insertEventIntoAscendingList,insertEventIntoDescendingList:()=>insertEventIntoDescendingList,normalizeURL:()=>normalizeURL,utf8Decoder:()=>utf8Decoder,utf8Encoder:()=>utf8Encoder});var utf8Decoder=new TextDecoder("utf-8"),utf8Encoder=new TextEncoder;function normalizeURL(t){try{t.indexOf("://")===-1&&(t="wss://"+t);let e=new URL(t);return e.pathname=e.pathname.replace(/\/+/g,"/"),e.pathname.endsWith("/")&&(e.pathname=e.pathname.slice(0,-1)),(e.port==="80"&&e.protocol==="ws:"||e.port==="443"&&e.protocol==="wss:")&&(e.port=""),e.searchParams.sort(),e.hash="",e.toString()}catch{throw new Error(`Invalid URL: ${t}`)}}function insertEventIntoDescendingList(t,e){const[n,r]=binarySearch(t,s=>e.id===s.id?0:e.created_at===s.created_at?-1:s.created_at-e.created_at);return r||t.splice(n,0,e),t}function insertEventIntoAscendingList(t,e){const[n,r]=binarySearch(t,s=>e.id===s.id?0:e.created_at===s.created_at?-1:e.created_at-s.created_at);return r||t.splice(n,0,e),t}function binarySearch(t,e){let n=0,r=t.length-1;for(;n<=r;){const s=Math.floor((n+r)/2),o=e(t[s]);if(o===0)return[s,!0];o<0?r=s-1:n=s+1}return[n,!1]}var QueueNode=class{constructor(t){m(this,"value");m(this,"next",null);m(this,"prev",null);this.value=t}},Queue$1=class{constructor(){m(this,"first");m(this,"last");this.first=null,this.last=null}enqueue(e){const n=new QueueNode(e);return this.last?this.last===this.first?(this.last=n,this.last.prev=this.first,this.first.next=n):(n.prev=this.last,this.last.next=n,this.last=n):(this.first=n,this.last=n),!0}dequeue(){if(!this.first)return null;if(this.first===this.last){const n=this.first;return this.first=null,this.last=null,n.value}const e=this.first;return this.first=e.next,this.first&&(this.first.prev=null),e.value}},JS=class{generateSecretKey(){return schnorr.utils.randomPrivateKey()}getPublicKey(t){return bytesToHex(schnorr.getPublicKey(t))}finalizeEvent(t,e){const n=t;return n.pubkey=bytesToHex(schnorr.getPublicKey(e)),n.id=getEventHash$1(n),n.sig=bytesToHex(schnorr.sign(getEventHash$1(n),e)),n[verifiedSymbol]=!0,n}verifyEvent(t){if(typeof t[verifiedSymbol]=="boolean")return t[verifiedSymbol];const e=getEventHash$1(t);if(e!==t.id)return t[verifiedSymbol]=!1,!1;try{const n=schnorr.verify(t.sig,e,t.pubkey);return t[verifiedSymbol]=n,n}catch{return t[verifiedSymbol]=!1,!1}}};function serializeEvent(t){if(!validateEvent(t))throw new Error("can't serialize event with wrong or missing properties");return JSON.stringify([0,t.pubkey,t.created_at,t.kind,t.tags,t.content])}function getEventHash$1(t){let e=sha256$1(utf8Encoder.encode(serializeEvent(t)));return bytesToHex(e)}var i=new JS,generateSecretKey=i.generateSecretKey,getPublicKey=i.getPublicKey,finalizeEvent=i.finalizeEvent,verifyEvent=i.verifyEvent,kinds_exports={};__export(kinds_exports,{Application:()=>Application,BadgeAward:()=>BadgeAward,BadgeDefinition:()=>BadgeDefinition,BlockedRelaysList:()=>BlockedRelaysList,BookmarkList:()=>BookmarkList,Bookmarksets:()=>Bookmarksets,Calendar:()=>Calendar,CalendarEventRSVP:()=>CalendarEventRSVP,ChannelCreation:()=>ChannelCreation,ChannelHideMessage:()=>ChannelHideMessage,ChannelMessage:()=>ChannelMessage,ChannelMetadata:()=>ChannelMetadata,ChannelMuteUser:()=>ChannelMuteUser,ClassifiedListing:()=>ClassifiedListing,ClientAuth:()=>ClientAuth,CommunitiesList:()=>CommunitiesList,CommunityDefinition:()=>CommunityDefinition,CommunityPostApproval:()=>CommunityPostApproval,Contacts:()=>Contacts,CreateOrUpdateProduct:()=>CreateOrUpdateProduct,CreateOrUpdateStall:()=>CreateOrUpdateStall,Curationsets:()=>Curationsets,Date:()=>Date2,DirectMessageRelaysList:()=>DirectMessageRelaysList,DraftClassifiedListing:()=>DraftClassifiedListing,DraftLong:()=>DraftLong,Emojisets:()=>Emojisets,EncryptedDirectMessage:()=>EncryptedDirectMessage,EventDeletion:()=>EventDeletion,FileMetadata:()=>FileMetadata,FileServerPreference:()=>FileServerPreference,Followsets:()=>Followsets,GenericRepost:()=>GenericRepost,Genericlists:()=>Genericlists,GiftWrap:()=>GiftWrap,HTTPAuth:()=>HTTPAuth,Handlerinformation:()=>Handlerinformation,Handlerrecommendation:()=>Handlerrecommendation,Highlights:()=>Highlights,InterestsList:()=>InterestsList,Interestsets:()=>Interestsets,JobFeedback:()=>JobFeedback,JobRequest:()=>JobRequest,JobResult:()=>JobResult,Label:()=>Label,LightningPubRPC:()=>LightningPubRPC,LiveChatMessage:()=>LiveChatMessage,LiveEvent:()=>LiveEvent,LongFormArticle:()=>LongFormArticle,Metadata:()=>Metadata,Mutelist:()=>Mutelist,NWCWalletInfo:()=>NWCWalletInfo,NWCWalletRequest:()=>NWCWalletRequest,NWCWalletResponse:()=>NWCWalletResponse,NostrConnect:()=>NostrConnect,OpenTimestamps:()=>OpenTimestamps,Pinlist:()=>Pinlist,PrivateDirectMessage:()=>PrivateDirectMessage,ProblemTracker:()=>ProblemTracker,ProfileBadges:()=>ProfileBadges,PublicChatsList:()=>PublicChatsList,Reaction:()=>Reaction,RecommendRelay:()=>RecommendRelay,RelayList:()=>RelayList,Relaysets:()=>Relaysets,Report:()=>Report,Reporting:()=>Reporting,Repost:()=>Repost,Seal:()=>Seal,SearchRelaysList:()=>SearchRelaysList,ShortTextNote:()=>ShortTextNote,Time:()=>Time,UserEmojiList:()=>UserEmojiList,UserStatuses:()=>UserStatuses,Zap:()=>Zap,ZapGoal:()=>ZapGoal,ZapRequest:()=>ZapRequest,classifyKind:()=>classifyKind,isAddressableKind:()=>isAddressableKind,isEphemeralKind:()=>isEphemeralKind,isKind:()=>isKind,isRegularKind:()=>isRegularKind,isReplaceableKind:()=>isReplaceableKind});function isRegularKind(t){return 1e3<=t&&t<1e4||[1,2,4,5,6,7,8,16,40,41,42,43,44].includes(t)}function isReplaceableKind(t){return[0,3].includes(t)||1e4<=t&&t<2e4}function isEphemeralKind(t){return 2e4<=t&&t<3e4}function isAddressableKind(t){return 3e4<=t&&t<4e4}function classifyKind(t){return isRegularKind(t)?"regular":isReplaceableKind(t)?"replaceable":isEphemeralKind(t)?"ephemeral":isAddressableKind(t)?"parameterized":"unknown"}function isKind(t,e){const n=e instanceof Array?e:[e];return validateEvent(t)&&n.includes(t.kind)||!1}var Metadata=0,ShortTextNote=1,RecommendRelay=2,Contacts=3,EncryptedDirectMessage=4,EventDeletion=5,Repost=6,Reaction=7,BadgeAward=8,Seal=13,PrivateDirectMessage=14,GenericRepost=16,ChannelCreation=40,ChannelMetadata=41,ChannelMessage=42,ChannelHideMessage=43,ChannelMuteUser=44,OpenTimestamps=1040,GiftWrap=1059,FileMetadata=1063,LiveChatMessage=1311,ProblemTracker=1971,Report=1984,Reporting=1984,Label=1985,CommunityPostApproval=4550,JobRequest=5999,JobResult=6999,JobFeedback=7e3,ZapGoal=9041,ZapRequest=9734,Zap=9735,Highlights=9802,Mutelist=1e4,Pinlist=10001,RelayList=10002,BookmarkList=10003,CommunitiesList=10004,PublicChatsList=10005,BlockedRelaysList=10006,SearchRelaysList=10007,InterestsList=10015,UserEmojiList=10030,DirectMessageRelaysList=10050,FileServerPreference=10096,NWCWalletInfo=13194,LightningPubRPC=21e3,ClientAuth=22242,NWCWalletRequest=23194,NWCWalletResponse=23195,NostrConnect=24133,HTTPAuth=27235,Followsets=3e4,Genericlists=30001,Relaysets=30002,Bookmarksets=30003,Curationsets=30004,ProfileBadges=30008,BadgeDefinition=30009,Interestsets=30015,CreateOrUpdateStall=30017,CreateOrUpdateProduct=30018,LongFormArticle=30023,DraftLong=30024,Emojisets=30030,Application=30078,LiveEvent=30311,UserStatuses=30315,ClassifiedListing=30402,DraftClassifiedListing=30403,Date2=31922,Time=31923,Calendar=31924,CalendarEventRSVP=31925,Handlerrecommendation=31989,Handlerinformation=31990,CommunityDefinition=34550;function matchFilter(t,e){if(t.ids&&t.ids.indexOf(e.id)===-1||t.kinds&&t.kinds.indexOf(e.kind)===-1||t.authors&&t.authors.indexOf(e.pubkey)===-1)return!1;for(let n in t)if(n[0]==="#"){let r=n.slice(1),s=t[`#${r}`];if(s&&!e.tags.find(([o,a])=>o===n.slice(1)&&s.indexOf(a)!==-1))return!1}return!(t.since&&e.created_at<t.since||t.until&&e.created_at>t.until)}function matchFilters(t,e){for(let n=0;n<t.length;n++)if(matchFilter(t[n],e))return!0;return!1}var fakejson_exports={};__export(fakejson_exports,{getHex64:()=>getHex64,getInt:()=>getInt,getSubscriptionId:()=>getSubscriptionId,matchEventId:()=>matchEventId,matchEventKind:()=>matchEventKind,matchEventPubkey:()=>matchEventPubkey});function getHex64(t,e){let n=e.length+3,r=t.indexOf(`"${e}":`)+n,s=t.slice(r).indexOf('"')+r+1;return t.slice(s,s+64)}function getInt(t,e){let n=e.length,r=t.indexOf(`"${e}":`)+n+3,s=t.slice(r),o=Math.min(s.indexOf(","),s.indexOf("}"));return parseInt(s.slice(0,o),10)}function getSubscriptionId(t){let e=t.slice(0,22).indexOf('"EVENT"');if(e===-1)return null;let n=t.slice(e+7+1).indexOf('"');if(n===-1)return null;let r=e+7+1+n,s=t.slice(r+1,80).indexOf('"');if(s===-1)return null;let o=r+1+s;return t.slice(r+1,o)}function matchEventId(t,e){return e===getHex64(t,"id")}function matchEventPubkey(t,e){return e===getHex64(t,"pubkey")}function matchEventKind(t,e){return e===getInt(t,"kind")}var nip42_exports={};__export(nip42_exports,{makeAuthEvent:()=>makeAuthEvent});function makeAuthEvent(t,e){return{kind:ClientAuth,created_at:Math.floor(Date.now()/1e3),tags:[["relay",t],["challenge",e]],content:""}}var _WebSocket;try{_WebSocket=WebSocket}catch{}var _WebSocket2;try{_WebSocket2=WebSocket}catch{}var nip19_exports={};__export(nip19_exports,{BECH32_REGEX:()=>BECH32_REGEX$1,Bech32MaxSize:()=>Bech32MaxSize,NostrTypeGuard:()=>NostrTypeGuard,decode:()=>decode,decodeNostrURI:()=>decodeNostrURI,encodeBytes:()=>encodeBytes,naddrEncode:()=>naddrEncode,neventEncode:()=>neventEncode,noteEncode:()=>noteEncode,nprofileEncode:()=>nprofileEncode,npubEncode:()=>npubEncode,nsecEncode:()=>nsecEncode});var NostrTypeGuard={isNProfile:t=>/^nprofile1[a-z\d]+$/.test(t||""),isNEvent:t=>/^nevent1[a-z\d]+$/.test(t||""),isNAddr:t=>/^naddr1[a-z\d]+$/.test(t||""),isNSec:t=>/^nsec1[a-z\d]{58}$/.test(t||""),isNPub:t=>/^npub1[a-z\d]{58}$/.test(t||""),isNote:t=>/^note1[a-z\d]+$/.test(t||""),isNcryptsec:t=>/^ncryptsec1[a-z\d]+$/.test(t||"")},Bech32MaxSize=5e3,BECH32_REGEX$1=/[\x21-\x7E]{1,83}1[023456789acdefghjklmnpqrstuvwxyz]{6,}/;function integerToUint8Array(t){const e=new Uint8Array(4);return e[0]=t>>24&255,e[1]=t>>16&255,e[2]=t>>8&255,e[3]=t&255,e}function decodeNostrURI(t){try{return t.startsWith("nostr:")&&(t=t.substring(6)),decode(t)}catch{return{type:"invalid",data:null}}}function decode(t){var s,o,a,c,l,u,h;let{prefix:e,words:n}=bech32.decode(t,Bech32MaxSize),r=new Uint8Array(bech32.fromWords(n));switch(e){case"nprofile":{let f=parseTLV(r);if(!((s=f[0])!=null&&s[0]))throw new Error("missing TLV 0 for nprofile");if(f[0][0].length!==32)throw new Error("TLV 0 should be 32 bytes");return{type:"nprofile",data:{pubkey:bytesToHex(f[0][0]),relays:f[1]?f[1].map(p=>utf8Decoder.decode(p)):[]}}}case"nevent":{let f=parseTLV(r);if(!((o=f[0])!=null&&o[0]))throw new Error("missing TLV 0 for nevent");if(f[0][0].length!==32)throw new Error("TLV 0 should be 32 bytes");if(f[2]&&f[2][0].length!==32)throw new Error("TLV 2 should be 32 bytes");if(f[3]&&f[3][0].length!==4)throw new Error("TLV 3 should be 4 bytes");return{type:"nevent",data:{id:bytesToHex(f[0][0]),relays:f[1]?f[1].map(p=>utf8Decoder.decode(p)):[],author:(a=f[2])!=null&&a[0]?bytesToHex(f[2][0]):void 0,kind:(c=f[3])!=null&&c[0]?parseInt(bytesToHex(f[3][0]),16):void 0}}}case"naddr":{let f=parseTLV(r);if(!((l=f[0])!=null&&l[0]))throw new Error("missing TLV 0 for naddr");if(!((u=f[2])!=null&&u[0]))throw new Error("missing TLV 2 for naddr");if(f[2][0].length!==32)throw new Error("TLV 2 should be 32 bytes");if(!((h=f[3])!=null&&h[0]))throw new Error("missing TLV 3 for naddr");if(f[3][0].length!==4)throw new Error("TLV 3 should be 4 bytes");return{type:"naddr",data:{identifier:utf8Decoder.decode(f[0][0]),pubkey:bytesToHex(f[2][0]),kind:parseInt(bytesToHex(f[3][0]),16),relays:f[1]?f[1].map(p=>utf8Decoder.decode(p)):[]}}}case"nsec":return{type:e,data:r};case"npub":case"note":return{type:e,data:bytesToHex(r)};default:throw new Error(`unknown prefix ${e}`)}}function parseTLV(t){let e={},n=t;for(;n.length>0;){let r=n[0],s=n[1],o=n.slice(2,2+s);if(n=n.slice(2+s),o.length<s)throw new Error(`not enough data to read on TLV ${r}`);e[r]=e[r]||[],e[r].push(o)}return e}function nsecEncode(t){return encodeBytes("nsec",t)}function npubEncode(t){return encodeBytes("npub",hexToBytes(t))}function noteEncode(t){return encodeBytes("note",hexToBytes(t))}function encodeBech32(t,e){let n=bech32.toWords(e);return bech32.encode(t,n,Bech32MaxSize)}function encodeBytes(t,e){return encodeBech32(t,e)}function nprofileEncode(t){let e=encodeTLV({0:[hexToBytes(t.pubkey)],1:(t.relays||[]).map(n=>utf8Encoder.encode(n))});return encodeBech32("nprofile",e)}function neventEncode(t){let e;t.kind!==void 0&&(e=integerToUint8Array(t.kind));let n=encodeTLV({0:[hexToBytes(t.id)],1:(t.relays||[]).map(r=>utf8Encoder.encode(r)),2:t.author?[hexToBytes(t.author)]:[],3:e?[new Uint8Array(e)]:[]});return encodeBech32("nevent",n)}function naddrEncode(t){let e=new ArrayBuffer(4);new DataView(e).setUint32(0,t.kind,!1);let n=encodeTLV({0:[utf8Encoder.encode(t.identifier)],1:(t.relays||[]).map(r=>utf8Encoder.encode(r)),2:[hexToBytes(t.pubkey)],3:[new Uint8Array(e)]});return encodeBech32("naddr",n)}function encodeTLV(t){let e=[];return Object.entries(t).reverse().forEach(([n,r])=>{r.forEach(s=>{let o=new Uint8Array(s.length+2);o.set([parseInt(n)],0),o.set([s.length],1),o.set(s,2),e.push(o)})}),concatBytes(...e)}var nip04_exports={};__export(nip04_exports,{decrypt:()=>decrypt$1,encrypt:()=>encrypt$1});function encrypt$1(t,e,n){const r=t instanceof Uint8Array?bytesToHex(t):t,s=secp256k1.getSharedSecret(r,"02"+e),o=getNormalizedX(s);let a=Uint8Array.from(randomBytes(16)),c=utf8Encoder.encode(n),l=cbc(o,a).encrypt(c),u=base64.encode(new Uint8Array(l)),h=base64.encode(new Uint8Array(a.buffer));return`${u}?iv=${h}`}function decrypt$1(t,e,n){const r=t instanceof Uint8Array?bytesToHex(t):t;let[s,o]=n.split("?iv="),a=secp256k1.getSharedSecret(r,"02"+e),c=getNormalizedX(a),l=base64.decode(o),u=base64.decode(s),h=cbc(c,l).decrypt(u);return utf8Decoder.decode(h)}function getNormalizedX(t){return t.slice(1,33)}var nip05_exports={};__export(nip05_exports,{NIP05_REGEX:()=>NIP05_REGEX$1,isNip05:()=>isNip05,isValid:()=>isValid,queryProfile:()=>queryProfile,searchDomain:()=>searchDomain,useFetchImplementation:()=>useFetchImplementation});var NIP05_REGEX$1=/^(?:([\w.+-]+)@)?([\w_-]+(\.[\w_-]+)+)$/,isNip05=t=>NIP05_REGEX$1.test(t||""),_fetch;try{_fetch=fetch}catch(t){}function useFetchImplementation(t){_fetch=t}async function searchDomain(t,e=""){try{const n=`https://${t}/.well-known/nostr.json?name=${e}`,r=await _fetch(n,{redirect:"manual"});if(r.status!==200)throw Error("Wrong response code");return(await r.json()).names}catch{return{}}}async function queryProfile(t){var s;const e=t.match(NIP05_REGEX$1);if(!e)return null;const[,n="_",r]=e;try{const o=`https://${r}/.well-known/nostr.json?name=${n}`,a=await _fetch(o,{redirect:"manual"});if(a.status!==200)throw Error("Wrong response code");const c=await a.json(),l=c.names[n];return l?{pubkey:l,relays:(s=c.relays)==null?void 0:s[l]}:null}catch{return null}}async function isValid(t,e){const n=await queryProfile(e);return n?n.pubkey===t:!1}var nip10_exports={};__export(nip10_exports,{parse:()=>parse});function parse(t){const e={reply:void 0,root:void 0,mentions:[],profiles:[],quotes:[]};let n,r;for(let s=t.tags.length-1;s>=0;s--){const o=t.tags[s];if(o[0]==="e"&&o[1]){const[a,c,l,u,h]=o,f={id:c,relays:l?[l]:[],author:h};if(u==="root"){e.root=f;continue}if(u==="reply"){e.reply=f;continue}if(u==="mention"){e.mentions.push(f);continue}n?r=f:n=f,e.mentions.push(f);continue}if(o[0]==="q"&&o[1]){const[a,c,l]=o;e.quotes.push({id:c,relays:l?[l]:[]})}if(o[0]==="p"&&o[1]){e.profiles.push({pubkey:o[1],relays:o[2]?[o[2]]:[]});continue}}return e.root||(e.root=r||n||e.reply),e.reply||(e.reply=n||e.root),[e.reply,e.root].forEach(s=>{if(!s)return;let o=e.mentions.indexOf(s);if(o!==-1&&e.mentions.splice(o,1),s.author){let a=e.profiles.find(c=>c.pubkey===s.author);a&&a.relays&&(s.relays||(s.relays=[]),a.relays.forEach(c=>{var l;((l=s.relays)==null?void 0:l.indexOf(c))===-1&&s.relays.push(c)}),a.relays=s.relays)}}),e.mentions.forEach(s=>{if(s.author){let o=e.profiles.find(a=>a.pubkey===s.author);o&&o.relays&&(s.relays||(s.relays=[]),o.relays.forEach(a=>{s.relays.indexOf(a)===-1&&s.relays.push(a)}),o.relays=s.relays)}}),e}var nip11_exports={};__export(nip11_exports,{fetchRelayInformation:()=>fetchRelayInformation,useFetchImplementation:()=>useFetchImplementation2});var _fetch2;try{_fetch2=fetch}catch{}function useFetchImplementation2(t){_fetch2=t}async function fetchRelayInformation(t){return await(await fetch(t.replace("ws://","http://").replace("wss://","https://"),{headers:{Accept:"application/nostr+json"}})).json()}var nip13_exports={};__export(nip13_exports,{fastEventHash:()=>fastEventHash,getPow:()=>getPow,minePow:()=>minePow});function getPow(t){let e=0;for(let n=0;n<64;n+=8){const r=parseInt(t.substring(n,n+8),16);if(r===0)e+=32;else{e+=Math.clz32(r);break}}return e}function minePow(t,e){let n=0;const r=t,s=["nonce",n.toString(),e.toString()];for(r.tags.push(s);;){const o=Math.floor(new Date().getTime()/1e3);if(o!==r.created_at&&(n=0,r.created_at=o),s[1]=(++n).toString(),r.id=fastEventHash(r),getPow(r.id)>=e)break}return r}function fastEventHash(t){return bytesToHex(sha256$1(utf8Encoder.encode(JSON.stringify([0,t.pubkey,t.created_at,t.kind,t.tags,t.content]))))}var nip17_exports={};__export(nip17_exports,{unwrapEvent:()=>unwrapEvent2,unwrapManyEvents:()=>unwrapManyEvents2,wrapEvent:()=>wrapEvent2,wrapManyEvents:()=>wrapManyEvents2});var nip59_exports={};__export(nip59_exports,{createRumor:()=>createRumor,createSeal:()=>createSeal,createWrap:()=>createWrap,unwrapEvent:()=>unwrapEvent,unwrapManyEvents:()=>unwrapManyEvents,wrapEvent:()=>wrapEvent$1,wrapManyEvents:()=>wrapManyEvents});var nip44_exports={};__export(nip44_exports,{decrypt:()=>decrypt2,encrypt:()=>encrypt2,getConversationKey:()=>getConversationKey,v2:()=>v2});var minPlaintextSize=1,maxPlaintextSize=65535;function getConversationKey(t,e){const n=secp256k1.getSharedSecret(t,"02"+e).subarray(1,33);return extract(sha256$1,n,"nip44-v2")}function getMessageKeys(t,e){const n=expand(sha256$1,t,e,76);return{chacha_key:n.subarray(0,32),chacha_nonce:n.subarray(32,44),hmac_key:n.subarray(44,76)}}function calcPaddedLen(t){if(!Number.isSafeInteger(t)||t<1)throw new Error("expected positive integer");if(t<=32)return 32;const e=1<<Math.floor(Math.log2(t-1))+1,n=e<=256?32:e/8;return n*(Math.floor((t-1)/n)+1)}function writeU16BE(t){if(!Number.isSafeInteger(t)||t<minPlaintextSize||t>maxPlaintextSize)throw new Error("invalid plaintext size: must be between 1 and 65535 bytes");const e=new Uint8Array(2);return new DataView(e.buffer).setUint16(0,t,!1),e}function pad(t){const e=utf8Encoder.encode(t),n=e.length,r=writeU16BE(n),s=new Uint8Array(calcPaddedLen(n)-n);return concatBytes(r,e,s)}function unpad(t){const e=new DataView(t.buffer).getUint16(0),n=t.subarray(2,2+e);if(e<minPlaintextSize||e>maxPlaintextSize||n.length!==e||t.length!==2+calcPaddedLen(e))throw new Error("invalid padding");return utf8Decoder.decode(n)}function hmacAad(t,e,n){if(n.length!==32)throw new Error("AAD associated data must be 32 bytes");const r=concatBytes(n,e);return hmac(sha256$1,t,r)}function decodePayload(t){if(typeof t!="string")throw new Error("payload must be a valid string");const e=t.length;if(e<132||e>87472)throw new Error("invalid payload length: "+e);if(t[0]==="#")throw new Error("unknown encryption version");let n;try{n=base64.decode(t)}catch(o){throw new Error("invalid base64: "+o.message)}const r=n.length;if(r<99||r>65603)throw new Error("invalid data length: "+r);const s=n[0];if(s!==2)throw new Error("unknown encryption version "+s);return{nonce:n.subarray(1,33),ciphertext:n.subarray(33,-32),mac:n.subarray(-32)}}function encrypt2(t,e,n=randomBytes(32)){const{chacha_key:r,chacha_nonce:s,hmac_key:o}=getMessageKeys(e,n),a=pad(t),c=chacha20(r,s,a),l=hmacAad(o,c,n);return base64.encode(concatBytes(new Uint8Array([2]),n,c,l))}function decrypt2(t,e){const{nonce:n,ciphertext:r,mac:s}=decodePayload(t),{chacha_key:o,chacha_nonce:a,hmac_key:c}=getMessageKeys(e,n),l=hmacAad(c,r,n);if(!equalBytes(l,s))throw new Error("invalid MAC");const u=chacha20(o,a,r);return unpad(u)}var v2={utils:{getConversationKey,calcPaddedLen},encrypt:encrypt2,decrypt:decrypt2},TWO_DAYS=2*24*60*60,now=()=>Math.round(Date.now()/1e3),randomNow=()=>Math.round(now()-Math.random()*TWO_DAYS),nip44ConversationKey=(t,e)=>getConversationKey(t,e),nip44Encrypt=(t,e,n)=>encrypt2(JSON.stringify(t),nip44ConversationKey(e,n)),nip44Decrypt=(t,e)=>JSON.parse(decrypt2(t.content,nip44ConversationKey(e,t.pubkey)));function createRumor(t,e){const n={created_at:now(),content:"",tags:[],...t,pubkey:getPublicKey(e)};return n.id=getEventHash$1(n),n}function createSeal(t,e,n){return finalizeEvent({kind:Seal,content:nip44Encrypt(t,e,n),created_at:randomNow(),tags:[]},e)}function createWrap(t,e){const n=generateSecretKey();return finalizeEvent({kind:GiftWrap,content:nip44Encrypt(t,n,e),created_at:randomNow(),tags:[["p",e]]},n)}function wrapEvent$1(t,e,n){const r=createRumor(t,e),s=createSeal(r,e,n);return createWrap(s,n)}function wrapManyEvents(t,e,n){if(!n||n.length===0)throw new Error("At least one recipient is required.");const r=getPublicKey(e),s=[wrapEvent$1(t,e,r)];return n.forEach(o=>{s.push(wrapEvent$1(t,e,o))}),s}function unwrapEvent(t,e){const n=nip44Decrypt(t,e);return nip44Decrypt(n,e)}function unwrapManyEvents(t,e){let n=[];return t.forEach(r=>{n.push(unwrapEvent(r,e))}),n.sort((r,s)=>r.created_at-s.created_at),n}function createEvent(t,e,n,r){const s={created_at:Math.ceil(Date.now()/1e3),kind:PrivateDirectMessage,tags:[],content:e};return(Array.isArray(t)?t:[t]).forEach(({publicKey:a,relayUrl:c})=>{s.tags.push(c?["p",a,c]:["p",a])}),r&&s.tags.push(["e",r.eventId,r.relayUrl||"","reply"]),n&&s.tags.push(["subject",n]),s}function wrapEvent2(t,e,n,r,s){const o=createEvent(e,n,r,s);return wrapEvent$1(o,t,e.publicKey)}function wrapManyEvents2(t,e,n,r,s){if(!e||e.length===0)throw new Error("At least one recipient is required.");return[{publicKey:getPublicKey(t)},...e].map(a=>wrapEvent2(t,a,n,r,s))}var unwrapEvent2=unwrapEvent,unwrapManyEvents2=unwrapManyEvents,nip18_exports={};__export(nip18_exports,{finishRepostEvent:()=>finishRepostEvent,getRepostedEvent:()=>getRepostedEvent,getRepostedEventPointer:()=>getRepostedEventPointer});function finishRepostEvent(t,e,n,r){var a;let s;const o=[...t.tags??[],["e",e.id,n],["p",e.pubkey]];return e.kind===ShortTextNote?s=Repost:(s=GenericRepost,o.push(["k",String(e.kind)])),finalizeEvent({kind:s,tags:o,content:t.content===""||(a=e.tags)!=null&&a.find(c=>c[0]==="-")?"":JSON.stringify(e),created_at:t.created_at},r)}function getRepostedEventPointer(t){if(![Repost,GenericRepost].includes(t.kind))return;let e,n;for(let r=t.tags.length-1;r>=0&&(e===void 0||n===void 0);r--){const s=t.tags[r];s.length>=2&&(s[0]==="e"&&e===void 0?e=s:s[0]==="p"&&n===void 0&&(n=s))}if(e!==void 0)return{id:e[1],relays:[e[2],n==null?void 0:n[2]].filter(r=>typeof r=="string"),author:n==null?void 0:n[1]}}function getRepostedEvent(t,{skipVerification:e}={}){const n=getRepostedEventPointer(t);if(n===void 0||t.content==="")return;let r;try{r=JSON.parse(t.content)}catch{return}if(r.id===n.id&&!(!e&&!verifyEvent(r)))return r}var nip21_exports={};__export(nip21_exports,{NOSTR_URI_REGEX:()=>NOSTR_URI_REGEX,parse:()=>parse2,test:()=>test});var NOSTR_URI_REGEX=new RegExp(`nostr:(${BECH32_REGEX$1.source})`);function test(t){return typeof t=="string"&&new RegExp(`^${NOSTR_URI_REGEX.source}$`).test(t)}function parse2(t){const e=t.match(new RegExp(`^${NOSTR_URI_REGEX.source}$`));if(!e)throw new Error(`Invalid Nostr URI: ${t}`);return{uri:e[0],value:e[1],decoded:decode(e[1])}}var nip25_exports={};__export(nip25_exports,{finishReactionEvent:()=>finishReactionEvent,getReactedEventPointer:()=>getReactedEventPointer});function finishReactionEvent(t,e,n){const r=e.tags.filter(s=>s.length>=2&&(s[0]==="e"||s[0]==="p"));return finalizeEvent({...t,kind:Reaction,tags:[...t.tags??[],...r,["e",e.id],["p",e.pubkey]],content:t.content??"+"},n)}function getReactedEventPointer(t){if(t.kind!==Reaction)return;let e,n;for(let r=t.tags.length-1;r>=0&&(e===void 0||n===void 0);r--){const s=t.tags[r];s.length>=2&&(s[0]==="e"&&e===void 0?e=s:s[0]==="p"&&n===void 0&&(n=s))}if(!(e===void 0||n===void 0))return{id:e[1],relays:[e[2],n[2]].filter(r=>r!==void 0),author:n[1]}}var nip27_exports={};__export(nip27_exports,{parse:()=>parse3});var noCharacter=/\W/m,noURLCharacter=/\W |\W$|$|,| /m;function*parse3(t){const e=t.length;let n=0,r=0;for(;r<e;){let s=t.indexOf(":",r);if(s===-1)break;if(t.substring(s-5,s)==="nostr"){const o=t.substring(s+60).match(noCharacter),a=o?s+60+o.index:e;try{let c,{data:l,type:u}=decode(t.substring(s+1,a));switch(u){case"npub":c={pubkey:l};break;case"nsec":case"note":r=a+1;continue;default:c=l}n!==s-5&&(yield{type:"text",text:t.substring(n,s-5)}),yield{type:"reference",pointer:c},r=a,n=r;continue}catch{r=s+1;continue}}else if(t.substring(s-5,s)==="https"||t.substring(s-4,s)==="http"){const o=t.substring(s+4).match(noURLCharacter),a=o?s+4+o.index:e,c=t[s-1]==="s"?5:4;try{let l=new URL(t.substring(s-c,a));if(l.hostname.indexOf(".")===-1)throw new Error("invalid url");if(n!==s-c&&(yield{type:"text",text:t.substring(n,s-c)}),l.pathname.endsWith(".png")||l.pathname.endsWith(".jpg")||l.pathname.endsWith(".jpeg")||l.pathname.endsWith(".gif")||l.pathname.endsWith(".webp")){yield{type:"image",url:l.toString()},r=a,n=r;continue}if(l.pathname.endsWith(".mp4")||l.pathname.endsWith(".avi")||l.pathname.endsWith(".webm")||l.pathname.endsWith(".mkv")){yield{type:"video",url:l.toString()},r=a,n=r;continue}if(l.pathname.endsWith(".mp3")||l.pathname.endsWith(".aac")||l.pathname.endsWith(".ogg")||l.pathname.endsWith(".opus")){yield{type:"audio",url:l.toString()},r=a,n=r;continue}yield{type:"url",url:l.toString()},r=a,n=r;continue}catch{r=a+1;continue}}else if(t.substring(s-3,s)==="wss"||t.substring(s-2,s)==="ws"){const o=t.substring(s+4).match(noURLCharacter),a=o?s+4+o.index:e,c=t[s-1]==="s"?3:2;try{let l=new URL(t.substring(s-c,a));if(l.hostname.indexOf(".")===-1)throw new Error("invalid ws url");n!==s-c&&(yield{type:"text",text:t.substring(n,s-c)}),yield{type:"relay",url:l.toString()},r=a,n=r;continue}catch{r=a+1;continue}}else{r=s+1;continue}}n!==e&&(yield{type:"text",text:t.substring(n)})}var nip28_exports={};__export(nip28_exports,{channelCreateEvent:()=>channelCreateEvent,channelHideMessageEvent:()=>channelHideMessageEvent,channelMessageEvent:()=>channelMessageEvent,channelMetadataEvent:()=>channelMetadataEvent,channelMuteUserEvent:()=>channelMuteUserEvent});var channelCreateEvent=(t,e)=>{let n;if(typeof t.content=="object")n=JSON.stringify(t.content);else if(typeof t.content=="string")n=t.content;else return;return finalizeEvent({kind:ChannelCreation,tags:[...t.tags??[]],content:n,created_at:t.created_at},e)},channelMetadataEvent=(t,e)=>{let n;if(typeof t.content=="object")n=JSON.stringify(t.content);else if(typeof t.content=="string")n=t.content;else return;return finalizeEvent({kind:ChannelMetadata,tags:[["e",t.channel_create_event_id],...t.tags??[]],content:n,created_at:t.created_at},e)},channelMessageEvent=(t,e)=>{const n=[["e",t.channel_create_event_id,t.relay_url,"root"]];return t.reply_to_channel_message_event_id&&n.push(["e",t.reply_to_channel_message_event_id,t.relay_url,"reply"]),finalizeEvent({kind:ChannelMessage,tags:[...n,...t.tags??[]],content:t.content,created_at:t.created_at},e)},channelHideMessageEvent=(t,e)=>{let n;if(typeof t.content=="object")n=JSON.stringify(t.content);else if(typeof t.content=="string")n=t.content;else return;return finalizeEvent({kind:ChannelHideMessage,tags:[["e",t.channel_message_event_id],...t.tags??[]],content:n,created_at:t.created_at},e)},channelMuteUserEvent=(t,e)=>{let n;if(typeof t.content=="object")n=JSON.stringify(t.content);else if(typeof t.content=="string")n=t.content;else return;return finalizeEvent({kind:ChannelMuteUser,tags:[["p",t.pubkey_to_mute],...t.tags??[]],content:n,created_at:t.created_at},e)},nip30_exports={};__export(nip30_exports,{EMOJI_SHORTCODE_REGEX:()=>EMOJI_SHORTCODE_REGEX,matchAll:()=>matchAll,regex:()=>regex,replaceAll:()=>replaceAll});var EMOJI_SHORTCODE_REGEX=/:(\w+):/,regex=()=>new RegExp(`\\B${EMOJI_SHORTCODE_REGEX.source}\\B`,"g");function*matchAll(t){const e=t.matchAll(regex());for(const n of e)try{const[r,s]=n;yield{shortcode:r,name:s,start:n.index,end:n.index+r.length}}catch{}}function replaceAll(t,e){return t.replaceAll(regex(),(n,r)=>e({shortcode:n,name:r}))}var nip39_exports={};__export(nip39_exports,{useFetchImplementation:()=>useFetchImplementation3,validateGithub:()=>validateGithub});var _fetch3;try{_fetch3=fetch}catch{}function useFetchImplementation3(t){_fetch3=t}async function validateGithub(t,e,n){try{return await(await _fetch3(`https://gist.github.com/${e}/${n}/raw`)).text()===`Verifying that I control the following Nostr public key: ${t}`}catch{return!1}}var nip47_exports={};__export(nip47_exports,{makeNwcRequestEvent:()=>makeNwcRequestEvent,parseConnectionString:()=>parseConnectionString});function parseConnectionString(t){const{host:e,pathname:n,searchParams:r}=new URL(t),s=n||e,o=r.get("relay"),a=r.get("secret");if(!s||!o||!a)throw new Error("invalid connection string");return{pubkey:s,relay:o,secret:a}}async function makeNwcRequestEvent(t,e,n){const s=encrypt$1(e,t,JSON.stringify({method:"pay_invoice",params:{invoice:n}})),o={kind:NWCWalletRequest,created_at:Math.round(Date.now()/1e3),content:s,tags:[["p",t]]};return finalizeEvent(o,e)}var nip54_exports={};__export(nip54_exports,{normalizeIdentifier:()=>normalizeIdentifier});function normalizeIdentifier(t){return t=t.trim().toLowerCase(),t=t.normalize("NFKC"),Array.from(t).map(e=>/\p{Letter}/u.test(e)||/\p{Number}/u.test(e)?e:"-").join("")}var nip57_exports={};__export(nip57_exports,{getSatoshisAmountFromBolt11:()=>getSatoshisAmountFromBolt11,getZapEndpoint:()=>getZapEndpoint,makeZapReceipt:()=>makeZapReceipt,makeZapRequest:()=>makeZapRequest,useFetchImplementation:()=>useFetchImplementation4,validateZapRequest:()=>validateZapRequest});var _fetch4;try{_fetch4=fetch}catch{}function useFetchImplementation4(t){_fetch4=t}async function getZapEndpoint(t){try{let e="",{lud06:n,lud16:r}=JSON.parse(t.content);if(n){let{words:a}=bech32.decode(n,1e3),c=bech32.fromWords(a);e=utf8Decoder.decode(c)}else if(r){let[a,c]=r.split("@");e=new URL(`/.well-known/lnurlp/${a}`,`https://${c}`).toString()}else return null;let o=await(await _fetch4(e)).json();if(o.allowsNostr&&o.nostrPubkey)return o.callback}catch{}return null}function makeZapRequest(t){let e={kind:9734,created_at:Math.round(Date.now()/1e3),content:t.comment||"",tags:[["p","pubkey"in t?t.pubkey:t.event.pubkey],["amount",t.amount.toString()],["relays",...t.relays]]};if("event"in t){if(isReplaceableKind(t.event.kind)){const n=["a",`${t.event.kind}:${t.event.pubkey}:`];e.tags.push(n)}else if(isAddressableKind(t.event.kind)){let n=t.event.tags.find(([s,o])=>s==="d"&&o);if(!n)throw new Error("d tag not found or is empty");const r=["a",`${t.event.kind}:${t.event.pubkey}:${n[1]}`];e.tags.push(r)}e.tags.push(["k",t.event.kind.toString()])}return e}function validateZapRequest(t){let e;try{e=JSON.parse(t)}catch{return"Invalid zap request JSON."}if(!validateEvent(e))return"Zap request is not a valid Nostr event.";if(!verifyEvent(e))return"Invalid signature on zap request.";let n=e.tags.find(([o,a])=>o==="p"&&a);if(!n)return"Zap request doesn't have a 'p' tag.";if(!n[1].match(/^[a-f0-9]{64}$/))return"Zap request 'p' tag is not valid hex.";let r=e.tags.find(([o,a])=>o==="e"&&a);return r&&!r[1].match(/^[a-f0-9]{64}$/)?"Zap request 'e' tag is not valid hex.":e.tags.find(([o,a])=>o==="relays"&&a)?null:"Zap request doesn't have a 'relays' tag."}function makeZapReceipt({zapRequest:t,preimage:e,bolt11:n,paidAt:r}){let s=JSON.parse(t),o=s.tags.filter(([c])=>c==="e"||c==="p"||c==="a"),a={kind:9735,created_at:Math.round(r.getTime()/1e3),content:"",tags:[...o,["P",s.pubkey],["bolt11",n],["description",t]]};return e&&a.tags.push(["preimage",e]),a}function getSatoshisAmountFromBolt11(t){if(t.length<50)return 0;t=t.substring(0,50);const e=t.lastIndexOf("1");if(e===-1)return 0;const n=t.substring(0,e);if(!n.startsWith("lnbc"))return 0;const r=n.substring(4);if(r.length<1)return 0;const s=r[r.length-1],o=s.charCodeAt(0)-"0".charCodeAt(0),a=o>=0&&o<=9;let c=r.length-1;if(a&&c++,c<1)return 0;const l=parseInt(r.substring(0,c));switch(s){case"m":return l*1e5;case"u":return l*100;case"n":return l/10;case"p":return l/1e4;default:return l*1e8}}var nip98_exports={};__export(nip98_exports,{getToken:()=>getToken,hashPayload:()=>hashPayload,unpackEventFromToken:()=>unpackEventFromToken,validateEvent:()=>validateEvent2,validateEventKind:()=>validateEventKind,validateEventMethodTag:()=>validateEventMethodTag,validateEventPayloadTag:()=>validateEventPayloadTag,validateEventTimestamp:()=>validateEventTimestamp,validateEventUrlTag:()=>validateEventUrlTag,validateToken:()=>validateToken});var _authorizationScheme="Nostr ";async function getToken(t,e,n,r=!1,s){const o={kind:HTTPAuth,tags:[["u",t],["method",e]],created_at:Math.round(new Date().getTime()/1e3),content:""};s&&o.tags.push(["payload",hashPayload(s)]);const a=await n(o);return(r?_authorizationScheme:"")+base64.encode(utf8Encoder.encode(JSON.stringify(a)))}async function validateToken(t,e,n){const r=await unpackEventFromToken(t).catch(o=>{throw o});return await validateEvent2(r,e,n).catch(o=>{throw o})}async function unpackEventFromToken(t){if(!t)throw new Error("Missing token");t=t.replace(_authorizationScheme,"");const e=utf8Decoder.decode(base64.decode(t));if(!e||e.length===0||!e.startsWith("{"))throw new Error("Invalid token");return JSON.parse(e)}function validateEventTimestamp(t){return t.created_at?Math.round(new Date().getTime()/1e3)-t.created_at<60:!1}function validateEventKind(t){return t.kind===HTTPAuth}function validateEventUrlTag(t,e){const n=t.tags.find(r=>r[0]==="u");return n?n.length>0&&n[1]===e:!1}function validateEventMethodTag(t,e){const n=t.tags.find(r=>r[0]==="method");return n?n.length>0&&n[1].toLowerCase()===e.toLowerCase():!1}function hashPayload(t){const e=sha256$1(utf8Encoder.encode(JSON.stringify(t)));return bytesToHex(e)}function validateEventPayloadTag(t,e){const n=t.tags.find(s=>s[0]==="payload");if(!n)return!1;const r=hashPayload(e);return n.length>0&&n[1]===r}async function validateEvent2(t,e,n,r){if(!verifyEvent(t))throw new Error("Invalid nostr event, signature invalid");if(!validateEventKind(t))throw new Error("Invalid nostr event, kind invalid");if(!validateEventTimestamp(t))throw new Error("Invalid nostr event, created_at timestamp invalid");if(!validateEventUrlTag(t,e))throw new Error("Invalid nostr event, url tag invalid");if(!validateEventMethodTag(t,n))throw new Error("Invalid nostr event, method tag invalid");if(r&&typeof r=="object"&&Object.keys(r).length>0&&!validateEventPayloadTag(t,r))throw new Error("Invalid nostr event, payload tag does not match request body hash");return!0}const sha256=sha256$3;var dist={},LRUCache$1={},LRUCacheNode$1={};Object.defineProperty(LRUCacheNode$1,"__esModule",{value:!0});LRUCacheNode$1.LRUCacheNode=void 0;class LRUCacheNode{constructor(e,n,r){const{entryExpirationTimeInMS:s=null,next:o=null,prev:a=null,onEntryEvicted:c,onEntryMarkedAsMostRecentlyUsed:l,clone:u,cloneFn:h}=r??{};if(typeof s=="number"&&(s<=0||Number.isNaN(s)))throw new Error("entryExpirationTimeInMS must either be null (no expiry) or greater than 0");this.clone=u??!1,this.cloneFn=h??this.defaultClone,this.key=e,this.internalValue=this.clone?this.cloneFn(n):n,this.created=Date.now(),this.entryExpirationTimeInMS=s,this.next=o,this.prev=a,this.onEntryEvicted=c,this.onEntryMarkedAsMostRecentlyUsed=l}get value(){return this.clone?this.cloneFn(this.internalValue):this.internalValue}get isExpired(){return typeof this.entryExpirationTimeInMS=="number"&&Date.now()-this.created>this.entryExpirationTimeInMS}invokeOnEvicted(){if(this.onEntryEvicted){const{key:e,value:n,isExpired:r}=this;this.onEntryEvicted({key:e,value:n,isExpired:r})}}invokeOnEntryMarkedAsMostRecentlyUsed(){if(this.onEntryMarkedAsMostRecentlyUsed){const{key:e,value:n}=this;this.onEntryMarkedAsMostRecentlyUsed({key:e,value:n})}}defaultClone(e){return typeof e=="boolean"||typeof e=="string"||typeof e=="number"?e:JSON.parse(JSON.stringify(e))}}LRUCacheNode$1.LRUCacheNode=LRUCacheNode;Object.defineProperty(LRUCache$1,"__esModule",{value:!0});LRUCache$1.LRUCache=void 0;const LRUCacheNode_1=LRUCacheNode$1;class LRUCache{constructor(e){this.lookupTable=new Map,this.head=null,this.tail=null;const{maxSize:n=25,entryExpirationTimeInMS:r=null,onEntryEvicted:s,onEntryMarkedAsMostRecentlyUsed:o,cloneFn:a,clone:c}=e??{};if(Number.isNaN(n)||n<=0)throw new Error("maxSize must be greater than 0.");if(typeof r=="number"&&(r<=0||Number.isNaN(r)))throw new Error("entryExpirationTimeInMS must either be null (no expiry) or greater than 0");this.maxSizeInternal=n,this.entryExpirationTimeInMS=r,this.onEntryEvicted=s,this.onEntryMarkedAsMostRecentlyUsed=o,this.clone=c,this.cloneFn=a}get size(){return this.cleanCache(),this.lookupTable.size}get remainingSize(){return this.maxSizeInternal-this.size}get newest(){return this.head?this.head.isExpired?(this.removeNodeFromListAndLookupTable(this.head),this.newest):this.mapNodeToEntry(this.head):null}get oldest(){return this.tail?this.tail.isExpired?(this.removeNodeFromListAndLookupTable(this.tail),this.oldest):this.mapNodeToEntry(this.tail):null}get maxSize(){return this.maxSizeInternal}set maxSize(e){if(Number.isNaN(e)||e<=0)throw new Error("maxSize must be greater than 0.");this.maxSizeInternal=e,this.enforceSizeLimit()}set(e,n,r){const s=this.lookupTable.get(e);s&&this.removeNodeFromListAndLookupTable(s);const o=new LRUCacheNode_1.LRUCacheNode(e,n,{entryExpirationTimeInMS:this.entryExpirationTimeInMS,onEntryEvicted:this.onEntryEvicted,onEntryMarkedAsMostRecentlyUsed:this.onEntryMarkedAsMostRecentlyUsed,clone:this.clone,cloneFn:this.cloneFn,...r});return this.setNodeAsHead(o),this.lookupTable.set(e,o),this.enforceSizeLimit(),this}get(e){const n=this.lookupTable.get(e);return n?n.isExpired?(this.removeNodeFromListAndLookupTable(n),null):(this.setNodeAsHead(n),n.value):null}peek(e){const n=this.lookupTable.get(e);return n?n.isExpired?(this.removeNodeFromListAndLookupTable(n),null):n.value:null}delete(e){const n=this.lookupTable.get(e);return n?this.removeNodeFromListAndLookupTable(n):!1}has(e){const n=this.lookupTable.get(e);return n?n.isExpired?(this.removeNodeFromListAndLookupTable(n),!1):!0:!1}clear(){this.head=null,this.tail=null,this.lookupTable.clear()}find(e){let n=this.head;for(;n;){if(n.isExpired){const s=n.next;this.removeNodeFromListAndLookupTable(n),n=s;continue}const r=this.mapNodeToEntry(n);if(e(r))return this.setNodeAsHead(n),r;n=n.next}return null}forEach(e){let n=this.head,r=0;for(;n;){if(n.isExpired){const s=n.next;this.removeNodeFromListAndLookupTable(n),n=s;continue}e(n.value,n.key,r),n=n.next,r++}}*values(){let e=this.head;for(;e;){if(e.isExpired){const n=e.next;this.removeNodeFromListAndLookupTable(e),e=n;continue}yield e.value,e=e.next}}*keys(){let e=this.head;for(;e;){if(e.isExpired){const n=e.next;this.removeNodeFromListAndLookupTable(e),e=n;continue}yield e.key,e=e.next}}*entries(){let e=this.head;for(;e;){if(e.isExpired){const n=e.next;this.removeNodeFromListAndLookupTable(e),e=n;continue}yield this.mapNodeToEntry(e),e=e.next}}*[Symbol.iterator](){let e=this.head;for(;e;){if(e.isExpired){const n=e.next;this.removeNodeFromListAndLookupTable(e),e=n;continue}yield this.mapNodeToEntry(e),e=e.next}}enforceSizeLimit(){let e=this.tail;for(;e!==null&&this.size>this.maxSizeInternal;){const n=e.prev;this.removeNodeFromListAndLookupTable(e),e=n}}mapNodeToEntry({key:e,value:n}){return{key:e,value:n}}setNodeAsHead(e){this.removeNodeFromList(e),this.head?(e.next=this.head,this.head.prev=e,this.head=e):(this.head=e,this.tail=e),e.invokeOnEntryMarkedAsMostRecentlyUsed()}removeNodeFromList(e){e.prev!==null&&(e.prev.next=e.next),e.next!==null&&(e.next.prev=e.prev),this.head===e&&(this.head=e.next),this.tail===e&&(this.tail=e.prev),e.next=null,e.prev=null}removeNodeFromListAndLookupTable(e){return e.invokeOnEvicted(),this.removeNodeFromList(e),this.lookupTable.delete(e.key)}cleanCache(){if(!this.entryExpirationTimeInMS)return;const e=[];for(const n of this.lookupTable.values())n.isExpired&&e.push(n);e.forEach(n=>this.removeNodeFromListAndLookupTable(n))}}LRUCache$1.LRUCache=LRUCache;(function(t){var e=commonjsGlobal&&commonjsGlobal.__createBinding||(Object.create?function(r,s,o,a){a===void 0&&(a=o);var c=Object.getOwnPropertyDescriptor(s,o);(!c||("get"in c?!s.__esModule:c.writable||c.configurable))&&(c={enumerable:!0,get:function(){return s[o]}}),Object.defineProperty(r,a,c)}:function(r,s,o,a){a===void 0&&(a=o),r[a]=s[o]}),n=commonjsGlobal&&commonjsGlobal.__exportStar||function(r,s){for(var o in r)o!=="default"&&!Object.prototype.hasOwnProperty.call(s,o)&&e(s,r,o)};Object.defineProperty(t,"__esModule",{value:!0}),n(LRUCache$1,t)})(dist);var lib={};(function(t){/*! scure-base - MIT License (c) 2022 Paul Miller (paulmillr.com) */Object.defineProperty(t,"__esModule",{value:!0}),t.bytes=t.stringToBytes=t.str=t.bytesToString=t.hex=t.utf8=t.bech32m=t.bech32=t.base58check=t.base58xmr=t.base58xrp=t.base58flickr=t.base58=t.base64url=t.base64=t.base32crockford=t.base32hex=t.base32=t.base16=t.utils=t.assertNumber=void 0;function e(E){if(!Number.isSafeInteger(E))throw new Error(`Wrong integer: ${E}`)}t.assertNumber=e;function n(...E){const k=(S,T)=>U=>S(T(U)),B=Array.from(E).reverse().reduce((S,T)=>S?k(S,T.encode):T.encode,void 0),H=E.reduce((S,T)=>S?k(S,T.decode):T.decode,void 0);return{encode:B,decode:H}}function r(E){return{encode:k=>{if(!Array.isArray(k)||k.length&&typeof k[0]!="number")throw new Error("alphabet.encode input should be an array of numbers");return k.map(B=>{if(e(B),B<0||B>=E.length)throw new Error(`Digit index outside alphabet: ${B} (alphabet: ${E.length})`);return E[B]})},decode:k=>{if(!Array.isArray(k)||k.length&&typeof k[0]!="string")throw new Error("alphabet.decode input should be array of strings");return k.map(B=>{if(typeof B!="string")throw new Error(`alphabet.decode: not string element=${B}`);const H=E.indexOf(B);if(H===-1)throw new Error(`Unknown letter: "${B}". Allowed: ${E}`);return H})}}}function s(E=""){if(typeof E!="string")throw new Error("join separator should be string");return{encode:k=>{if(!Array.isArray(k)||k.length&&typeof k[0]!="string")throw new Error("join.encode input should be array of strings");for(let B of k)if(typeof B!="string")throw new Error(`join.encode: non-string input=${B}`);return k.join(E)},decode:k=>{if(typeof k!="string")throw new Error("join.decode input should be string");return k.split(E)}}}function o(E,k="="){if(e(E),typeof k!="string")throw new Error("padding chr should be string");return{encode(B){if(!Array.isArray(B)||B.length&&typeof B[0]!="string")throw new Error("padding.encode input should be array of strings");for(let H of B)if(typeof H!="string")throw new Error(`padding.encode: non-string input=${H}`);for(;B.length*E%8;)B.push(k);return B},decode(B){if(!Array.isArray(B)||B.length&&typeof B[0]!="string")throw new Error("padding.encode input should be array of strings");for(let S of B)if(typeof S!="string")throw new Error(`padding.decode: non-string input=${S}`);let H=B.length;if(H*E%8)throw new Error("Invalid padding: string should have whole number of bytes");for(;H>0&&B[H-1]===k;H--)if(!((H-1)*E%8))throw new Error("Invalid padding: string has too much padding");return B.slice(0,H)}}}function a(E){if(typeof E!="function")throw new Error("normalize fn should be function");return{encode:k=>k,decode:k=>E(k)}}function c(E,k,B){if(k<2)throw new Error(`convertRadix: wrong from=${k}, base cannot be less than 2`);if(B<2)throw new Error(`convertRadix: wrong to=${B}, base cannot be less than 2`);if(!Array.isArray(E))throw new Error("convertRadix: data should be array");if(!E.length)return[];let H=0;const S=[],T=Array.from(E);for(T.forEach(U=>{if(e(U),U<0||U>=k)throw new Error(`Wrong integer: ${U}`)});;){let U=0,K=!0;for(let O=H;O<T.length;O++){const V=T[O],F=k*U+V;if(!Number.isSafeInteger(F)||k*U/k!==U||F-V!==k*U)throw new Error("convertRadix: carry overflow");if(U=F%B,T[O]=Math.floor(F/B),!Number.isSafeInteger(T[O])||T[O]*B+U!==F)throw new Error("convertRadix: carry overflow");if(K)T[O]?K=!1:H=O;else continue}if(S.push(U),K)break}for(let U=0;U<E.length-1&&E[U]===0;U++)S.push(0);return S.reverse()}const l=(E,k)=>k?l(k,E%k):E,u=(E,k)=>E+(k-l(E,k));function h(E,k,B,H){if(!Array.isArray(E))throw new Error("convertRadix2: data should be array");if(k<=0||k>32)throw new Error(`convertRadix2: wrong from=${k}`);if(B<=0||B>32)throw new Error(`convertRadix2: wrong to=${B}`);if(u(k,B)>32)throw new Error(`convertRadix2: carry overflow from=${k} to=${B} carryBits=${u(k,B)}`);let S=0,T=0;const U=2**B-1,K=[];for(const O of E){if(e(O),O>=2**k)throw new Error(`convertRadix2: invalid data word=${O} from=${k}`);if(S=S<<k|O,T+k>32)throw new Error(`convertRadix2: carry overflow pos=${T} from=${k}`);for(T+=k;T>=B;T-=B)K.push((S>>T-B&U)>>>0);S&=2**T-1}if(S=S<<B-T&U,!H&&T>=k)throw new Error("Excess padding");if(!H&&S)throw new Error(`Non-zero padding: ${S}`);return H&&T>0&&K.push(S>>>0),K}function f(E){return e(E),{encode:k=>{if(!(k instanceof Uint8Array))throw new Error("radix.encode input should be Uint8Array");return c(Array.from(k),2**8,E)},decode:k=>{if(!Array.isArray(k)||k.length&&typeof k[0]!="number")throw new Error("radix.decode input should be array of strings");return Uint8Array.from(c(k,E,2**8))}}}function p(E,k=!1){if(e(E),E<=0||E>32)throw new Error("radix2: bits should be in (0..32]");if(u(8,E)>32||u(E,8)>32)throw new Error("radix2: carry overflow");return{encode:B=>{if(!(B instanceof Uint8Array))throw new Error("radix2.encode input should be Uint8Array");return h(Array.from(B),8,E,!k)},decode:B=>{if(!Array.isArray(B)||B.length&&typeof B[0]!="number")throw new Error("radix2.decode input should be array of strings");return Uint8Array.from(h(B,E,8,k))}}}function g(E){if(typeof E!="function")throw new Error("unsafeWrapper fn should be function");return function(...k){try{return E.apply(null,k)}catch{}}}function w(E,k){if(e(E),typeof k!="function")throw new Error("checksum fn should be function");return{encode(B){if(!(B instanceof Uint8Array))throw new Error("checksum.encode: input should be Uint8Array");const H=k(B).slice(0,E),S=new Uint8Array(B.length+E);return S.set(B),S.set(H,B.length),S},decode(B){if(!(B instanceof Uint8Array))throw new Error("checksum.decode: input should be Uint8Array");const H=B.slice(0,-E),S=k(H).slice(0,E),T=B.slice(-E);for(let U=0;U<E;U++)if(S[U]!==T[U])throw new Error("Invalid checksum");return H}}}t.utils={alphabet:r,chain:n,checksum:w,radix:f,radix2:p,join:s,padding:o},t.base16=n(p(4),r("0123456789ABCDEF"),s("")),t.base32=n(p(5),r("ABCDEFGHIJKLMNOPQRSTUVWXYZ234567"),o(5),s("")),t.base32hex=n(p(5),r("0123456789ABCDEFGHIJKLMNOPQRSTUV"),o(5),s("")),t.base32crockford=n(p(5),r("0123456789ABCDEFGHJKMNPQRSTVWXYZ"),s(""),a(E=>E.toUpperCase().replace(/O/g,"0").replace(/[IL]/g,"1"))),t.base64=n(p(6),r("ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/"),o(6),s("")),t.base64url=n(p(6),r("ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-_"),o(6),s(""));const y=E=>n(f(58),r(E),s(""));t.base58=y("123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz"),t.base58flickr=y("123456789abcdefghijkmnopqrstuvwxyzABCDEFGHJKLMNPQRSTUVWXYZ"),t.base58xrp=y("rpshnaf39wBUDNEGHJKLM4PQRST7VWXYZ2bcdeCg65jkm8oFqi1tuvAxyz");const b=[0,2,3,5,6,7,9,10,11];t.base58xmr={encode(E){let k="";for(let B=0;B<E.length;B+=8){const H=E.subarray(B,B+8);k+=t.base58.encode(H).padStart(b[H.length],"1")}return k},decode(E){let k=[];for(let B=0;B<E.length;B+=11){const H=E.slice(B,B+11),S=b.indexOf(H.length),T=t.base58.decode(H);for(let U=0;U<T.length-S;U++)if(T[U]!==0)throw new Error("base58xmr: wrong padding");k=k.concat(Array.from(T.slice(T.length-S)))}return Uint8Array.from(k)}};const x=E=>n(w(4,k=>E(E(k))),t.base58);t.base58check=x;const _=n(r("qpzry9x8gf2tvdw0s3jn54khce6mua7l"),s("")),R=[996825010,642813549,513874426,1027748829,705979059];function $(E){const k=E>>25;let B=(E&33554431)<<5;for(let H=0;H<R.length;H++)(k>>H&1)===1&&(B^=R[H]);return B}function A(E,k,B=1){const H=E.length;let S=1;for(let T=0;T<H;T++){const U=E.charCodeAt(T);if(U<33||U>126)throw new Error(`Invalid prefix (${E})`);S=$(S)^U>>5}S=$(S);for(let T=0;T<H;T++)S=$(S)^E.charCodeAt(T)&31;for(let T of k)S=$(S)^T;for(let T=0;T<6;T++)S=$(S);return S^=B,_.encode(h([S%2**30],30,5,!1))}function L(E){const k=E==="bech32"?1:734539939,B=p(5),H=B.decode,S=B.encode,T=g(H);function U(F,q,Y=90){if(typeof F!="string")throw new Error(`bech32.encode prefix should be string, not ${typeof F}`);if(!Array.isArray(q)||q.length&&typeof q[0]!="number")throw new Error(`bech32.encode words should be array of numbers, not ${typeof q}`);const Z=F.length+7+q.length;if(Y!==!1&&Z>Y)throw new TypeError(`Length ${Z} exceeds limit ${Y}`);return F=F.toLowerCase(),`${F}1${_.encode(q)}${A(F,q,k)}`}function K(F,q=90){if(typeof F!="string")throw new Error(`bech32.decode input should be string, not ${typeof F}`);if(F.length<8||q!==!1&&F.length>q)throw new TypeError(`Wrong string length: ${F.length} (${F}). Expected (8..${q})`);const Y=F.toLowerCase();if(F!==Y&&F!==F.toUpperCase())throw new Error("String must be lowercase or uppercase");F=Y;const Z=F.lastIndexOf("1");if(Z===0||Z===-1)throw new Error('Letter "1" must be present between prefix and data only');const X=F.slice(0,Z),te=F.slice(Z+1);if(te.length<6)throw new Error("Data must be at least 6 characters long");const J=_.decode(te).slice(0,-6),oe=A(X,J,k);if(!te.endsWith(oe))throw new Error(`Invalid checksum in ${F}: expected "${oe}"`);return{prefix:X,words:J}}const O=g(K);function V(F){const{prefix:q,words:Y}=K(F,!1);return{prefix:q,words:Y,bytes:H(Y)}}return{encode:U,decode:K,decodeToBytes:V,decodeUnsafe:O,fromWords:H,fromWordsUnsafe:T,toWords:S}}t.bech32=L("bech32"),t.bech32m=L("bech32m"),t.utf8={encode:E=>new TextDecoder().decode(E),decode:E=>new TextEncoder().encode(E)},t.hex=n(p(4),r("0123456789abcdef"),s(""),a(E=>{if(typeof E!="string"||E.length%2)throw new TypeError(`hex.decode: expected string, got ${typeof E} with length ${E.length}`);return E.toLowerCase()}));const v={utf8:t.utf8,hex:t.hex,base16:t.base16,base32:t.base32,base64:t.base64,base64url:t.base64url,base58:t.base58,base58xmr:t.base58xmr},D=`Invalid encoding type. Available types: ${Object.keys(v).join(", ")}`,j=(E,k)=>{if(typeof E!="string"||!v.hasOwnProperty(E))throw new TypeError(D);if(!(k instanceof Uint8Array))throw new TypeError("bytesToString() expects Uint8Array");return v[E].encode(k)};t.bytesToString=j,t.str=t.bytesToString;const z=(E,k)=>{if(!v.hasOwnProperty(E))throw new TypeError(D);if(typeof k!="string")throw new TypeError("stringToBytes() expects string");return v[E].decode(k)};t.stringToBytes=z,t.bytes=t.stringToBytes})(lib);BigInt(1e3),BigInt(1e6),BigInt(1e9),BigInt(1e12);BigInt("2100000000000000000");BigInt(1e11);const TAGCODES={payment_hash:1,payment_secret:16,description:13,payee:19,description_hash:23,expiry:6,min_final_cltv_expiry:24,fallback_address:9,route_hint:3,feature_bits:5,metadata:27};for(let t=0,e=Object.keys(TAGCODES);t<e.length;t++)e[t],TAGCODES[e[t]].toString();function getRelaysForSync(t,e,n="write"){if(!t.outboxTracker)return;const r=t.outboxTracker.data.get(e);if(r)return n==="write"?r.writeRelays:r.readRelays}async function getWriteRelaysFor(t,e,n="write"){if(t.outboxTracker)return t.outboxTracker.data.has(e)||await t.outboxTracker.trackUsers([e]),getRelaysForSync(t,e,n)}function getTopRelaysForAuthors(t,e){const n=new Map;return e.forEach(s=>{const o=getRelaysForSync(t,s);o&&o.forEach(a=>{const c=n.get(a)||0;n.set(a,c+1)})}),Array.from(n.entries()).sort((s,o)=>o[1]-s[1]).map(s=>s[0])}function getAllRelaysForAllPubkeys(t,e,n="read"){const r=new Map,s=new Set;return e.forEach(o=>{const a=getRelaysForSync(t,o,n);a&&a.size>0?(a.forEach(c=>{(r.get(c)||new Set).add(o)}),r.set(o,a)):s.add(o)}),{pubkeysToRelays:r,authorsMissingRelays:s}}function chooseRelayCombinationForPubkeys(t,e,n,{count:r,preferredRelays:s}={}){r??(r=2),s??(s=new Set);const o=t.pool,a=o.connectedRelays();a.forEach(p=>{s==null||s.add(p.url)});const c=new Map,{pubkeysToRelays:l,authorsMissingRelays:u}=getAllRelaysForAllPubkeys(t,e,n),h=getTopRelaysForAuthors(t,e),f=(p,g)=>{const w=c.get(g)||[];w.push(p),c.set(g,w)};for(const[p,g]of l.entries()){let w=r;for(const y of a)g.has(y.url)&&(f(p,y.url),w--);for(const y of g)c.has(y)&&(f(p,y),w--);if(!(w<=0))for(const y of h){if(w<=0)break;g.has(y)&&(f(p,y),w--)}}for(const p of u)o.permanentAndConnectedRelays().forEach(g=>{const w=c.get(g.url)||[];w.push(p),c.set(g.url,w)});return c}function getRelaysForFilterWithAuthors(t,e,n=2){return chooseRelayCombinationForPubkeys(t,e,"write",{count:n})}function tryNormalizeRelayUrl(t){try{return normalizeRelayUrl(t)}catch{return}}function normalizeRelayUrl(t){let e=normalizeUrl(t,{stripAuthentication:!1,stripWWW:!1,stripHash:!0});return e.endsWith("/")||(e+="/"),e}function normalize(t){const e=new Set;for(const n of t)try{e.add(normalizeRelayUrl(n))}catch{}return Array.from(e)}var DATA_URL_DEFAULT_MIME_TYPE="text/plain",DATA_URL_DEFAULT_CHARSET="us-ascii",testParameter=(t,e)=>e.some(n=>n instanceof RegExp?n.test(t):n===t),supportedProtocols=new Set(["https:","http:","file:"]),hasCustomProtocol=t=>{try{const{protocol:e}=new URL(t);return e.endsWith(":")&&!e.includes(".")&&!supportedProtocols.has(e)}catch{return!1}},normalizeDataURL=(t,{stripHash:e})=>{var f,p,g,w;const n=/^data:(?<type>[^,]*?),(?<data>[^#]*?)(?:#(?<hash>.*))?$/.exec(t);if(!n)throw new Error(`Invalid URL: ${t}`);const r=((f=n.groups)==null?void 0:f.type)??"",s=((p=n.groups)==null?void 0:p.data)??"";let o=((g=n.groups)==null?void 0:g.hash)??"";const a=r.split(";");o=e?"":o;let c=!1;a[a.length-1]==="base64"&&(a.pop(),c=!0);const l=((w=a.shift())==null?void 0:w.toLowerCase())??"",h=[...a.map(y=>{let[b,x=""]=y.split("=").map(_=>_.trim());return b==="charset"&&(x=x.toLowerCase(),x===DATA_URL_DEFAULT_CHARSET)?"":`${b}${x?`=${x}`:""}`}).filter(Boolean)];return c&&h.push("base64"),(h.length>0||l&&l!==DATA_URL_DEFAULT_MIME_TYPE)&&h.unshift(l),`data:${h.join(";")},${c?s.trim():s}${o?`#${o}`:""}`};function normalizeUrl(t,e={}){if(e={defaultProtocol:"http",normalizeProtocol:!0,forceHttp:!1,forceHttps:!1,stripAuthentication:!0,stripHash:!1,stripTextFragment:!0,stripWWW:!0,removeQueryParameters:[/^utm_\w+/i],removeTrailingSlash:!0,removeSingleSlash:!0,removeDirectoryIndex:!1,removeExplicitPort:!1,sortQueryParameters:!0,...e},typeof e.defaultProtocol=="string"&&!e.defaultProtocol.endsWith(":")&&(e.defaultProtocol=`${e.defaultProtocol}:`),t=t.trim(),/^data:/i.test(t))return normalizeDataURL(t,e);if(hasCustomProtocol(t))return t;const n=t.startsWith("//");!n&&/^\.*\//.test(t)||(t=t.replace(/^(?!(?:\w+:)?\/\/)|^\/\//,e.defaultProtocol));const s=new URL(t);if(s.hostname=s.hostname.toLowerCase(),e.forceHttp&&e.forceHttps)throw new Error("The `forceHttp` and `forceHttps` options cannot be used together");if(e.forceHttp&&s.protocol==="https:"&&(s.protocol="http:"),e.forceHttps&&s.protocol==="http:"&&(s.protocol="https:"),e.stripAuthentication&&(s.username="",s.password=""),e.stripHash?s.hash="":e.stripTextFragment&&(s.hash=s.hash.replace(/#?:~:text.*?$/i,"")),s.pathname){const a=/\b[a-z][a-z\d+\-.]{1,50}:\/\//g;let c=0,l="";for(;;){const h=a.exec(s.pathname);if(!h)break;const f=h[0],p=h.index,g=s.pathname.slice(c,p);l+=g.replace(/\/{2,}/g,"/"),l+=f,c=p+f.length}const u=s.pathname.slice(c,s.pathname.length);l+=u.replace(/\/{2,}/g,"/"),s.pathname=l}if(s.pathname)try{s.pathname=decodeURI(s.pathname)}catch{}if(e.removeDirectoryIndex===!0&&(e.removeDirectoryIndex=[/^index\.[a-z]+$/]),Array.isArray(e.removeDirectoryIndex)&&e.removeDirectoryIndex.length>0){let a=s.pathname.split("/");const c=a[a.length-1];testParameter(c,e.removeDirectoryIndex)&&(a=a.slice(0,-1),s.pathname=`${a.slice(1).join("/")}/`)}if(s.hostname&&(s.hostname=s.hostname.replace(/\.$/,""),e.stripWWW&&/^www\.(?!www\.)[a-z\-\d]{1,63}\.[a-z.\-\d]{2,63}$/.test(s.hostname)&&(s.hostname=s.hostname.replace(/^www\./,""))),Array.isArray(e.removeQueryParameters))for(const a of[...s.searchParams.keys()])testParameter(a,e.removeQueryParameters)&&s.searchParams.delete(a);if(!Array.isArray(e.keepQueryParameters)&&e.removeQueryParameters===!0&&(s.search=""),Array.isArray(e.keepQueryParameters)&&e.keepQueryParameters.length>0)for(const a of[...s.searchParams.keys()])testParameter(a,e.keepQueryParameters)||s.searchParams.delete(a);if(e.sortQueryParameters){s.searchParams.sort();try{s.search=decodeURIComponent(s.search)}catch{}}e.removeTrailingSlash&&(s.pathname=s.pathname.replace(/\/$/,"")),e.removeExplicitPort&&s.port&&(s.port="");const o=t;return t=s.toString(),!e.removeSingleSlash&&s.pathname==="/"&&!o.endsWith("/")&&s.hash===""&&(t=t.replace(/\/$/,"")),(e.removeTrailingSlash||s.pathname==="/")&&s.hash===""&&e.removeSingleSlash&&(t=t.replace(/\/$/,"")),n&&!e.normalizeProtocol&&(t=t.replace(/^http:\/\//,"//")),e.stripProtocol&&(t=t.replace(/^(?:https?:)?\/\//,"")),t}var MAX_RECONNECT_ATTEMPTS=5,FLAPPING_THRESHOLD_MS=1e3,NDKRelayConnectivity=class{constructor(t,e){m(this,"ndkRelay");m(this,"ws");m(this,"_status");m(this,"timeoutMs");m(this,"connectedAt");m(this,"_connectionStats",{attempts:0,success:0,durations:[]});m(this,"debug");m(this,"netDebug");m(this,"connectTimeout");m(this,"reconnectTimeout");m(this,"ndk");m(this,"openSubs",new Map);m(this,"openCountRequests",new Map);m(this,"openEventPublishes",new Map);m(this,"serial",0);m(this,"baseEoseTimeout",4400);m(this,"updateConnectionStats",{connected:()=>{this._connectionStats.success++,this._connectionStats.connectedAt=Date.now()},disconnected:()=>{this._connectionStats.connectedAt&&(this._connectionStats.durations.push(Date.now()-this._connectionStats.connectedAt),this._connectionStats.durations.length>100&&this._connectionStats.durations.shift()),this._connectionStats.connectedAt=void 0},attempt:()=>{this._connectionStats.attempts++,this._connectionStats.connectedAt=Date.now()}});this.ndkRelay=t,this._status=1;const n=Math.floor(Math.random()*1e3);this.debug=this.ndkRelay.debug.extend(`connectivity${n}`),this.ndk=e}async connect(t,e=!0){if(this.ws&&this.ws.readyState!==WebSocket.OPEN&&this.ws.readyState!==WebSocket.CONNECTING){this.debug("Cleaning up stale WebSocket connection");try{this.ws.close()}catch{}this.ws=void 0,this._status=1}if(this._status!==2&&this._status!==1||this.reconnectTimeout){this.debug("Relay requested to be connected but was in state %s or it had a reconnect timeout",this._status);return}this.reconnectTimeout&&(clearTimeout(this.reconnectTimeout),this.reconnectTimeout=void 0),this.connectTimeout&&(clearTimeout(this.connectTimeout),this.connectTimeout=void 0),t??(t=this.timeoutMs),!this.timeoutMs&&t&&(this.timeoutMs=t),this.timeoutMs&&(this.connectTimeout=setTimeout(()=>this.onConnectionError(e),this.timeoutMs));try{this.updateConnectionStats.attempt(),this._status===1?this._status=4:this._status=2,this.ws=new WebSocket(this.ndkRelay.url),this.ws.onopen=this.onConnect.bind(this),this.ws.onclose=this.onDisconnect.bind(this),this.ws.onmessage=this.onMessage.bind(this),this.ws.onerror=this.onError.bind(this)}catch(n){throw this.debug(`Failed to connect to ${this.ndkRelay.url}`,n),this._status=1,e?this.handleReconnection():this.ndkRelay.emit("delayed-connect",2*24*60*60*1e3),n}}disconnect(){var t;this._status=0;try{(t=this.ws)==null||t.close()}catch(e){this.debug("Failed to disconnect",e),this._status=1}}onConnectionError(t){this.debug(`Error connecting to ${this.ndkRelay.url}`,this.timeoutMs),t&&!this.reconnectTimeout&&this.handleReconnection()}onConnect(){var t;(t=this.netDebug)==null||t.call(this,"connected",this.ndkRelay),this.reconnectTimeout&&(clearTimeout(this.reconnectTimeout),this.reconnectTimeout=void 0),this.connectTimeout&&(clearTimeout(this.connectTimeout),this.connectTimeout=void 0),this.updateConnectionStats.connected(),this._status=5,this.ndkRelay.emit("connect"),this.ndkRelay.emit("ready")}onDisconnect(){var t;(t=this.netDebug)==null||t.call(this,"disconnected",this.ndkRelay),this.updateConnectionStats.disconnected(),this._status===5&&this.handleReconnection(),this._status=1,this.ndkRelay.emit("disconnect")}onMessage(t){var e;(e=this.netDebug)==null||e.call(this,t.data,this.ndkRelay,"recv");try{const n=JSON.parse(t.data),[r,s,...o]=n;switch(r){case"EVENT":{const a=this.openSubs.get(s),c=n[2];if(!a){this.debug(`Received event for unknown subscription ${s}`);return}a.onevent(c);return}case"COUNT":{const a=n[2],c=this.openCountRequests.get(s);c&&(c.resolve(a.count),this.openCountRequests.delete(s));return}case"EOSE":{const a=this.openSubs.get(s);if(!a)return;a.oneose(s);return}case"OK":{const a=n[2],c=n[3],l=this.openEventPublishes.get(s),u=l==null?void 0:l.pop();if(!l||!u){this.debug("Received OK for unknown event publish",s);return}a?u.resolve(c):u.reject(new Error(c)),l.length===0?this.openEventPublishes.delete(s):this.openEventPublishes.set(s,l);return}case"CLOSED":{const a=this.openSubs.get(s);if(!a)return;a.onclosed(n[2]);return}case"NOTICE":this.onNotice(n[1]);return;case"AUTH":{this.onAuthRequested(n[1]);return}}}catch(n){this.debug(`Error parsing message from ${this.ndkRelay.url}: ${n.message}`,n==null?void 0:n.stack);return}}async onAuthRequested(t){var n,r,s;const e=this.ndkRelay.authPolicy??((n=this.ndk)==null?void 0:n.relayAuthDefaultPolicy);if(this.debug("Relay requested authentication",{havePolicy:!!e}),this._status===7){this.debug("Already authenticating, ignoring");return}if(this._status=6,e){if(this._status>=5){this._status=7;let o;try{o=await e(this.ndkRelay,t)}catch(a){this.debug("Authentication policy threw an error",a),o=!1}if(this.debug("Authentication policy returned",!!o),o instanceof NDKEvent||o===!0){o instanceof NDKEvent&&await this.auth(o);const a=async()=>{if(this._status>=5&&this._status<8){const c=new NDKEvent(this.ndk);c.kind=22242,c.tags=[["relay",this.ndkRelay.url],["challenge",t]],await c.sign(),this.auth(c).then(()=>{this._status=8,this.ndkRelay.emit("authed"),this.debug("Authentication successful")}).catch(l=>{this._status=6,this.ndkRelay.emit("auth:failed",l),this.debug("Authentication failed",l)})}else this.debug("Authentication failed, it changed status, status is %d",this._status)};o===!0&&((r=this.ndk)!=null&&r.signer?a().catch(c=>{console.error("Error authenticating",c)}):(this.debug("No signer available for authentication localhost"),(s=this.ndk)==null||s.once("signer:ready",a))),this._status=5,this.ndkRelay.emit("authed")}}}else this.ndkRelay.emit("auth",t)}onError(t){this.debug(`WebSocket error on ${this.ndkRelay.url}:`,t)}get status(){return this._status}isAvailable(){return this._status===5}isFlapping(){const t=this._connectionStats.durations;if(t.length%3!==0)return!1;const n=t.reduce((a,c)=>a+c,0)/t.length,r=t.map(a=>(a-n)**2).reduce((a,c)=>a+c,0)/t.length;return Math.sqrt(r)<FLAPPING_THRESHOLD_MS}async onNotice(t){this.ndkRelay.emit("notice",t)}handleReconnection(t=0){if(this.reconnectTimeout)return;if(this.isFlapping()){this.ndkRelay.emit("flapping",this._connectionStats),this._status=3;return}const e=this.connectedAt?Math.max(0,6e4-(Date.now()-this.connectedAt)):5e3*(this._connectionStats.attempts+1);this.reconnectTimeout=setTimeout(()=>{this.reconnectTimeout=void 0,this._status=2,this.connect().catch(n=>{t<MAX_RECONNECT_ATTEMPTS?setTimeout(()=>{this.handleReconnection(t+1)},Math.pow(1e3*(t+1),2)):this.debug("Reconnect failed")})},e),this.ndkRelay.emit("delayed-connect",e),this.debug("Reconnecting in",e),this._connectionStats.nextReconnectAt=Date.now()+e}async send(t){var e,n,r,s,o;this._status>=5&&((e=this.ws)==null?void 0:e.readyState)===WebSocket.OPEN?((n=this.ws)==null||n.send(t),(r=this.netDebug)==null||r.call(this,t,this.ndkRelay,"send")):(this.debug(`Not connected to ${this.ndkRelay.url} (%d), not sending message ${t}`,this._status),this._status>=5&&((s=this.ws)==null?void 0:s.readyState)!==WebSocket.OPEN&&(this.debug(`Stale connection detected, WebSocket state: ${(o=this.ws)==null?void 0:o.readyState}`),this.onDisconnect()))}async auth(t){const e=new Promise((n,r)=>{const s=this.openEventPublishes.get(t.id)??[];s.push({resolve:n,reject:r}),this.openEventPublishes.set(t.id,s)});return this.send(`["AUTH",${JSON.stringify(t.rawEvent())}]`),e}async publish(t){const e=new Promise((n,r)=>{const s=this.openEventPublishes.get(t.id)??[];s.length>0&&console.warn(`Duplicate event publishing detected, you are publishing event ${t.id} twice`),s.push({resolve:n,reject:r}),this.openEventPublishes.set(t.id,s)});return this.send(`["EVENT",${JSON.stringify(t)}]`),e}async count(t,e){this.serial++;const n=(e==null?void 0:e.id)||`count:${this.serial}`,r=new Promise((s,o)=>{this.openCountRequests.set(n,{resolve:s,reject:o})});return this.send(`["COUNT","${n}",${JSON.stringify(t).substring(1)}`),r}close(t,e){this.send(`["CLOSE","${t}"]`);const n=this.openSubs.get(t);this.openSubs.delete(t),n&&n.onclose(e)}req(t){`${this.send(`["REQ","${t.subId}",${JSON.stringify(t.executeFilters).substring(1)}`)}`,this.openSubs.set(t.subId,t)}get connectionStats(){return this._connectionStats}get url(){return this.ndkRelay.url}get connected(){var t;return this._status>=5&&((t=this.ws)==null?void 0:t.readyState)===WebSocket.OPEN}},NDKRelayPublisher=class{constructor(t){m(this,"ndkRelay");m(this,"debug");this.ndkRelay=t,this.debug=t.debug.extend("publisher")}async publish(t,e=2500){let n;const r=()=>new Promise((h,f)=>{try{this.publishEvent(t).then(p=>{this.ndkRelay.emit("published",t),t.emit("relay:published",this.ndkRelay),h(!0)}).catch(f)}catch(p){f(p)}}),s=new Promise((h,f)=>{n=setTimeout(()=>{n=void 0,f(new Error(`Timeout: ${e}ms`))},e)}),o=()=>{r().then(h=>a(h)).catch(h=>c(h))};let a,c;const l=h=>{throw this.ndkRelay.debug("Publish failed",h,t.id),this.ndkRelay.emit("publish:failed",t,h),t.emit("relay:publish:failed",this.ndkRelay,h),h},u=()=>{n&&clearTimeout(n),this.ndkRelay.removeListener("connect",o)};return this.ndkRelay.status>=5?Promise.race([r(),s]).catch(l).finally(u):(this.ndkRelay.status<=1?(console.warn("Relay is disconnected, trying to connect to publish an event",this.ndkRelay.url),this.ndkRelay.connect()):console.warn("Relay not connected, waiting for connection to publish an event",this.ndkRelay.url),Promise.race([new Promise((h,f)=>{a=h,c=f,this.ndkRelay.on("connect",o)}),s]).catch(l).finally(u))}async publishEvent(t){return this.ndkRelay.connectivity.publish(t.rawEvent())}};function filterFingerprint(t,e){const n=[];for(const s of t){const o=Object.entries(s||{}).map(([a,c])=>["since","until"].includes(a)?`${a}:${c}`:a).sort().join("-");n.push(o)}let r=e?"+":"";return r+=n.join("|"),r}function mergeFilters(t){const e=[],n={};return t.filter(r=>!!r.limit).forEach(r=>e.push(r)),t=t.filter(r=>!r.limit),t.length===0?e:(t.forEach(r=>{Object.entries(r).forEach(([s,o])=>{Array.isArray(o)?n[s]===void 0?n[s]=[...o]:n[s]=Array.from(new Set([...n[s],...o])):n[s]=o})}),[...e,n])}var NDKRelaySubscription=class{constructor(t,e,n){m(this,"fingerprint");m(this,"items",new Map);m(this,"topSubManager");m(this,"debug");m(this,"status",0);m(this,"onClose");m(this,"relay");m(this,"eosed",!1);m(this,"executionTimer");m(this,"fireTime");m(this,"delayType");m(this,"executeFilters");m(this,"id",Math.random().toString(36).substring(7));m(this,"_subId");m(this,"subIdParts",new Set);m(this,"executeOnRelayReady",()=>{if(this.status===2){if(this.items.size===0){this.debug("No items to execute; this relay was probably too slow to respond and the caller gave up",{status:this.status,fingerprint:this.fingerprint,items:this.items,itemsSize:this.items.size,id:this.id,subId:this.subId}),this.cleanup();return}this.debug("Executing on relay ready",{status:this.status,fingerprint:this.fingerprint,items:this.items,itemsSize:this.items.size}),this.status=1,this.execute()}});m(this,"reExecuteAfterAuth",(()=>{const t=this.subId;this.debug("Re-executing after auth",this.items.size),this.eosed?this.relay.close(this.subId):this.debug("We are abandoning an opened subscription, once it EOSE's, the handler will close it",{oldSubId:t}),this._subId=void 0,this.status=1,this.execute(),this.debug("Re-executed after auth %s  %s",t,this.subId)}).bind(this));this.relay=t,this.topSubManager=n,this.debug=t.debug.extend(`sub[${this.id}]`),this.fingerprint=e||Math.random().toString(36).substring(7)}get subId(){return this._subId?this._subId:(this._subId=this.fingerprint.slice(0,15),this._subId)}addSubIdPart(t){this.subIdParts.add(t)}addItem(t,e){if(this.debug("Adding item",{filters:e,internalId:t.internalId,status:this.status,fingerprint:this.fingerprint,id:this.subId,items:this.items,itemsSize:this.items.size}),!this.items.has(t.internalId))switch(t.on("close",this.removeItem.bind(this,t)),this.items.set(t.internalId,{subscription:t,filters:e}),this.status!==3&&t.subId&&(!this._subId||this._subId.length<48)&&(this.status===0||this.status===1)&&this.addSubIdPart(t.subId),this.status){case 0:this.evaluateExecutionPlan(t);break;case 3:break;case 1:this.evaluateExecutionPlan(t);break;case 4:throw this.debug("Subscription is closed, cannot add new items %o (%o)",t,e),new Error("Cannot add new items to a closed subscription")}}removeItem(t){if(this.items.delete(t.internalId),this.items.size===0){if(!this.eosed)return;this.close(),this.cleanup()}}close(){if(this.status===4)return;const t=this.status;if(this.status=4,t===3)try{this.relay.close(this.subId)}catch(e){this.debug("Error closing subscription",e,this)}else this.debug("Subscription wanted to close but it wasn't running, this is probably ok",{subId:this.subId,prevStatus:t,sub:this});this.cleanup()}cleanup(){this.executionTimer&&clearTimeout(this.executionTimer),this.relay.off("ready",this.executeOnRelayReady),this.relay.off("authed",this.reExecuteAfterAuth),this.onClose&&this.onClose(this)}evaluateExecutionPlan(t){if(!t.isGroupable()){this.status=1,this.execute();return}if(t.filters.find(r=>!!r.limit)&&(this.executeFilters=this.compileFilters(),this.executeFilters.length>=10)){this.status=1,this.execute();return}const e=t.groupableDelay,n=t.groupableDelayType;if(!e)throw new Error("Cannot group a subscription without a delay");if(this.status===0)this.schedule(e,n);else{const r=this.delayType,s=this.fireTime-Date.now();if(r==="at-least"&&n==="at-least")s<e&&(this.executionTimer&&clearTimeout(this.executionTimer),this.schedule(e,n));else if(r==="at-least"&&n==="at-most")s>e&&(this.executionTimer&&clearTimeout(this.executionTimer),this.schedule(e,n));else if(r==="at-most"&&n==="at-most")s>e&&(this.executionTimer&&clearTimeout(this.executionTimer),this.schedule(e,n));else if(r==="at-most"&&n==="at-least")s>e&&(this.executionTimer&&clearTimeout(this.executionTimer),this.schedule(e,n));else throw new Error(`Unknown delay type combination ${r} ${n}`)}}schedule(t,e){this.status=1;const n=Date.now();this.fireTime=n+t,this.delayType=e;const r=setTimeout(this.execute.bind(this),t);e==="at-least"&&(this.executionTimer=r)}finalizeSubId(){this.subIdParts.size>0?this._subId=Array.from(this.subIdParts).join("-"):this._subId=this.fingerprint.slice(0,15),this._subId+=`-${Math.random().toString(36).substring(2,7)}`}execute(){if(this.status===1){if(!this.relay.connected){this.status=2,this.debug("Waiting for relay to be ready",{status:this.status,id:this.subId,fingerprint:this.fingerprint,items:this.items,itemsSize:this.items.size}),this.relay.once("ready",this.executeOnRelayReady);return}this.relay.status<8&&this.relay.once("authed",this.reExecuteAfterAuth),this.status=3,this.finalizeSubId(),this.executeFilters=this.compileFilters(),this.relay.req(this)}}onstart(){}onevent(t){this.topSubManager.dispatchEvent(t,this.relay)}oneose(t){if(this.eosed=!0,t!==this.subId){this.debug("Received EOSE for an abandoned subscription",t,this.subId),this.relay.close(t);return}this.items.size===0&&this.close();for(const{subscription:e}of this.items.values())e.eoseReceived(this.relay),e.closeOnEose&&(this.debug("Removing item because of EOSE",{filters:e.filters,internalId:e.internalId,status:this.status,fingerprint:this.fingerprint,items:this.items,itemsSize:this.items.size}),this.removeItem(e))}onclose(t){this.status=4}onclosed(t){if(t)for(const{subscription:e}of this.items.values())e.closedReceived(this.relay,t)}compileFilters(){const t=[],e=Array.from(this.items.values()).map(r=>r.filters);if(!e[0])return this.debug(" No filters to merge",this.items),console.error("BUG: No filters to merge!",this.items),[];const n=e[0].length;for(let r=0;r<n;r++){const s=e.map(o=>o[r]);t.push(...mergeFilters(s))}return t}},NDKRelaySubscriptionManager=class{constructor(t,e){m(this,"relay");m(this,"subscriptions");m(this,"generalSubManager");this.relay=t,this.subscriptions=new Map,this.generalSubManager=e}addSubscription(t,e){let n;if(!t.isGroupable())n=this.createSubscription(t,e);else{const r=filterFingerprint(e,t.closeOnEose);r&&(n=(this.subscriptions.get(r)||[]).find(o=>o.status<3)),n??(n=this.createSubscription(t,e,r))}n.addItem(t,e)}createSubscription(t,e,n){const r=new NDKRelaySubscription(this.relay,n||null,this.generalSubManager);r.onClose=this.onRelaySubscriptionClose.bind(this);const s=this.subscriptions.get(r.fingerprint)??[];return this.subscriptions.set(r.fingerprint,[...s,r]),r}onRelaySubscriptionClose(t){let e=this.subscriptions.get(t.fingerprint)??[];e?e.length===1?this.subscriptions.delete(t.fingerprint):(e=e.filter(n=>n.id!==t.id),this.subscriptions.set(t.fingerprint,e)):console.warn("Unexpectedly did not find a subscription with fingerprint",t.fingerprint)}},Re,NDKRelay=(Re=class extends lib$1.EventEmitter{constructor(n,r,s){super();m(this,"url");m(this,"scores");m(this,"connectivity");m(this,"subs");m(this,"publisher");m(this,"authPolicy");m(this,"lowestValidationRatio");m(this,"targetValidationRatio");m(this,"validationRatioFn");m(this,"validatedEventCount",0);m(this,"nonValidatedEventCount",0);m(this,"trusted",!1);m(this,"complaining",!1);m(this,"debug");m(this,"req");m(this,"close");this.url=normalizeRelayUrl(n),this.scores=new Map,this.debug=createDebug5(`ndk:relay:${n}`),this.connectivity=new NDKRelayConnectivity(this,s),this.connectivity.netDebug=s==null?void 0:s.netDebug,this.req=this.connectivity.req.bind(this.connectivity),this.close=this.connectivity.close.bind(this.connectivity),this.subs=new NDKRelaySubscriptionManager(this,s.subManager),this.publisher=new NDKRelayPublisher(this),this.authPolicy=r,this.targetValidationRatio=s==null?void 0:s.initialValidationRatio,this.lowestValidationRatio=s==null?void 0:s.lowestValidationRatio,this.validationRatioFn=((s==null?void 0:s.validationRatioFn)??Re.defaultValidationRatioUpdateFn).bind(this),this.updateValidationRatio(),s||console.trace("relay created without ndk")}updateValidationRatio(){if(this.validationRatioFn&&this.validatedEventCount>0){const n=this.validationRatioFn(this,this.validatedEventCount,this.nonValidatedEventCount);this.targetValidationRatio=n}setTimeout(()=>{this.updateValidationRatio()},3e4)}get status(){return this.connectivity.status}get connectionStats(){return this.connectivity.connectionStats}async connect(n,r=!0){return this.connectivity.connect(n,r)}disconnect(){this.status!==1&&this.connectivity.disconnect()}subscribe(n,r){this.subs.addSubscription(n,r)}async publish(n,r=2500){return this.publisher.publish(n,r)}referenceTags(){return[["r",this.url]]}addValidatedEvent(){this.validatedEventCount++}addNonValidatedEvent(){this.nonValidatedEventCount++}get validationRatio(){return this.nonValidatedEventCount===0?1:this.validatedEventCount/(this.validatedEventCount+this.nonValidatedEventCount)}shouldValidateEvent(){return this.trusted?!1:this.targetValidationRatio===void 0||this.targetValidationRatio>=1?!0:Math.random()<this.targetValidationRatio}get connected(){return this.connectivity.connected}},m(Re,"defaultValidationRatioUpdateFn",(n,r,s)=>{if(n.lowestValidationRatio===void 0||n.targetValidationRatio===void 0)return 1;let o=n.validationRatio;if(n.validationRatio>n.targetValidationRatio){const a=r/100;o=Math.max(n.lowestValidationRatio,n.validationRatio-a)}return o<n.validationRatio?o:n.validationRatio}),Re),NDKPublishError=class extends Error{constructor(e,n,r,s){super(e);m(this,"errors");m(this,"publishedToRelays");m(this,"intendedRelaySet");this.errors=n,this.publishedToRelays=r,this.intendedRelaySet=s}get relayErrors(){const e=[];for(const[n,r]of this.errors)e.push(`${n.url}: ${r}`);return e.join(`
`)}},NDKRelaySet=class De{constructor(e,n,r){m(this,"relays");m(this,"debug");m(this,"ndk");m(this,"pool");this.relays=e,this.ndk=n,this.pool=r??n.pool,this.debug=n.debug.extend("relayset")}addRelay(e){this.relays.add(e)}get relayUrls(){return Array.from(this.relays).map(e=>e.url)}static fromRelayUrls(e,n,r=!0,s){if(s=s??n.pool,!s)throw new Error("No pool provided");const o=new Set;for(const a of e){const c=s.relays.get(normalizeRelayUrl(a));if(c)c.status<5&&r&&c.connect(),o.add(c);else{const l=new NDKRelay(normalizeRelayUrl(a),n==null?void 0:n.relayAuthDefaultPolicy,n);s.useTemporaryRelay(l,void 0,`requested from fromRelayUrls ${e}`),o.add(l)}}return new De(new Set(o),n,s)}async publish(e,n,r=1){var l;const s=new Set,o=new Map,a=e.isEphemeral();e.publishStatus="pending";const c=u=>{s.add(u)};e.on("relay:published",c);try{const u=Array.from(this.relays).map(h=>new Promise(f=>{const p=n?setTimeout(()=>{s.has(h)||(o.set(h,new Error(`Publish timeout after ${n}ms`)),f(!1))},n):null;h.publish(e,n).then(g=>{p&&clearTimeout(p),g?(s.add(h),f(!0)):f(!1)}).catch(g=>{p&&clearTimeout(p),a||o.set(h,g),f(!1)})}));if(await Promise.all(u),s.size<r){if(!a){const h=new NDKPublishError("Not enough relays received the event ("+s.size+" published, "+r+" required)",o,s,this);throw e.publishStatus="error",e.publishError=h,(l=this.ndk)==null||l.emit("event:publish-failed",e,h,this.relayUrls),h}}else e.publishStatus="success",e.emit("published",{relaySet:this,publishedToRelays:s});return s}finally{e.off("relay:published",c)}}get size(){return this.relays.size}},d=createDebug5("ndk:outbox:calculate");async function calculateRelaySetFromEvent(t,e,n){var c,l;const r=new Set,s=await getWriteRelaysFor(t,e.pubkey);s&&s.forEach(u=>{var f;const h=(f=t.pool)==null?void 0:f.getRelay(u);h&&r.add(h)});let o=e.tags.filter(u=>["a","e"].includes(u[0])).map(u=>u[2]).filter(u=>u==null?void 0:u.startsWith("wss://")).filter(u=>{try{return new URL(u),!0}catch{return!1}}).map(u=>normalizeRelayUrl(u));o=Array.from(new Set(o)).slice(0,5),o.forEach(u=>{var f;const h=(f=t.pool)==null?void 0:f.getRelay(u,!0,!0);h&&(d("Adding relay hint %s",u),r.add(h))});const a=e.getMatchingTags("p").map(u=>u[1]);if(a.length<5?Array.from(chooseRelayCombinationForPubkeys(t,a,"read",{preferredRelays:new Set(s)}).keys()).forEach(h=>{var p;const f=(p=t.pool)==null?void 0:p.getRelay(h,!1,!0);f&&(d("Adding p-tagged relay %s",h),r.add(f))}):d("Too many p-tags to consider %d",a.length),(c=t.pool)==null||c.permanentAndConnectedRelays().forEach(u=>r.add(u)),n&&r.size<n){const u=(l=t.explicitRelayUrls)==null?void 0:l.filter(h=>!Array.from(r).some(f=>f.url===h)).slice(0,n-r.size);u==null||u.forEach(h=>{var p;const f=(p=t.pool)==null?void 0:p.getRelay(h,!1,!0);f&&(d("Adding explicit relay %s",h),r.add(f))})}return new NDKRelaySet(r,t)}function calculateRelaySetsFromFilter(t,e,n){const r=new Map,s=new Set;if(e.forEach(o=>{o.authors&&o.authors.forEach(a=>s.add(a))}),s.size>0){const o=getRelaysForFilterWithAuthors(t,Array.from(s));for(const a of o.keys())r.set(a,[]);for(const a of e)if(a.authors)for(const[c,l]of o.entries()){const u=a.authors.filter(h=>l.includes(h));r.set(c,[...r.get(c),{...a,authors:u}])}else for(const c of o.keys())r.set(c,[...r.get(c),a])}else t.explicitRelayUrls&&t.explicitRelayUrls.forEach(o=>{r.set(o,e)});return r.size===0&&n.permanentAndConnectedRelays().slice(0,5).forEach(o=>{r.set(o.url,e)}),r}function calculateRelaySetsFromFilters(t,e,n){return calculateRelaySetsFromFilter(t,e,n)}function mergeTags(t,e){const n=new Map,r=a=>a.join(","),s=(a,c)=>a.every((l,u)=>l===c[u]),o=a=>{for(const[c,l]of n)if(s(l,a)||s(a,l)){a.length>=l.length&&n.set(c,a);return}n.set(r(a),a)};return t.concat(e).forEach(o),Array.from(n.values())}var hashtagRegex=new RegExp(`(?<=\\s|^)(#[^\\s!@#$%^&*()=+./,[{\\]};:'"?><]+)`,"g");function generateHashtags(t){const e=t.match(hashtagRegex),n=new Set,r=new Set;if(e)for(const s of e)n.has(s.slice(1))||(r.add(s.slice(1)),n.add(s.slice(1)));return Array.from(r)}async function generateContentTags(t,e=[]){const n=/(@|nostr:)(npub|nprofile|note|nevent|naddr)[a-zA-Z0-9]+/g,r=[],s=a=>{e.find(c=>["q",a[0]].includes(c[0])&&c[1]===a[1])||e.push(a)};t=t.replace(n,a=>{try{const c=a.split(/(@|nostr:)/)[2],{type:l,data:u}=nip19_exports.decode(c);let h;switch(l){case"npub":h=["p",u];break;case"nprofile":h=["p",u.pubkey];break;case"note":r.push(new Promise(async f=>{s(["q",u,await maybeGetEventRelayUrl(c)]),f()}));break;case"nevent":r.push(new Promise(async f=>{const{id:p,author:g}=u;let{relays:w}=u;(!w||w.length===0)&&(w=[await maybeGetEventRelayUrl(c)]),s(["q",p,w[0]]),g&&s(["p",g]),f()}));break;case"naddr":r.push(new Promise(async f=>{const p=[u.kind,u.pubkey,u.identifier].join(":");let g=u.relays??[];g.length===0&&(g=[await maybeGetEventRelayUrl(c)]),s(["q",p,g[0]]),s(["p",u.pubkey]),f()}));break;default:return a}return h&&s(h),`nostr:${c}`}catch{return a}}),await Promise.all(r);const o=generateHashtags(t).map(a=>["t",a]);return e=mergeTags(e,o),{content:t,tags:e}}async function maybeGetEventRelayUrl(t){return""}async function encrypt(t,e,n="nip44"){let r;if(!this.ndk)throw new Error("No NDK instance found!");let s=e;if(s||(this.ndk.assertSigner(),s=this.ndk.signer),!s)throw new Error("no NDK signer");const o=t||(()=>{const a=this.getMatchingTags("p");if(a.length!==1)throw new Error("No recipient could be determined and no explicit recipient was provided");return this.ndk.getUser({pubkey:a[0][1]})})();if(n==="nip44"&&await isEncryptionEnabled(s,"nip44")&&(r=await s.encrypt(o,this.content,"nip44")),(!r||n==="nip04")&&await isEncryptionEnabled(s,"nip04")&&(r=await s.encrypt(o,this.content,"nip04")),!r)throw new Error("Failed to encrypt event.");this.content=r}async function decrypt(t,e,n){var c,l,u,h;if((l=(c=this.ndk)==null?void 0:c.cacheAdapter)!=null&&l.getDecryptedEvent){let f=null;if(typeof this.ndk.cacheAdapter.getDecryptedEvent=="function"&&(f=this.ndk.cacheAdapter.getDecryptedEvent(this.id)),f){this.content=f.content;return}}let r;if(!this.ndk)throw new Error("No NDK instance found!");let s=e;if(s||(this.ndk.assertSigner(),s=this.ndk.signer),!s)throw new Error("no NDK signer");const o=t||this.author;if(!o)throw new Error("No sender provided and no author available");const a=n||(this.content.match(/\\?iv=/)?"nip04":"nip44");if((a==="nip04"||this.kind===4)&&await isEncryptionEnabled(s,"nip04")&&this.content.search("\\?iv=")&&(r=await s.decrypt(o,this.content,"nip04")),!r&&a==="nip44"&&await isEncryptionEnabled(s,"nip44")&&(r=await s.decrypt(o,this.content,"nip44")),!r)throw new Error("Failed to decrypt event.");this.content=r,(h=(u=this.ndk)==null?void 0:u.cacheAdapter)!=null&&h.addDecryptedEvent&&this.ndk.cacheAdapter.addDecryptedEvent(this)}async function isEncryptionEnabled(t,e){return t.encryptionEnabled?e?!!await t.encryptionEnabled(e):!0:!1}function eventHasETagMarkers(t){for(const e of t.tags)if(e[0]==="e"&&(e[3]??"").length>0)return!0;return!1}function getRootTag(t,e){e??(e=t.tagType());const n=t.tags.find(isTagRootTag);if(!n){if(eventHasETagMarkers(t))return;const r=t.getMatchingTags(e);if(r.length<3)return r[0]}return n}var nip22RootTags=new Set(["A","E","I"]),nip22ReplyTags=new Set(["a","e","i"]);function getReplyTag(t,e){if(t.kind===1111){let s;for(const o of t.tags)if(nip22RootTags.has(o[0]))s=o;else if(nip22ReplyTags.has(o[0])){s=o;break}return s}e??(e=t.tagType());let n=!1,r;for(const s of t.tags)if(s[0]===e){if((s[3]??"").length>0&&(n=!0),n&&s[3]==="reply")return s;n&&s[3]==="root"&&(r=s),n||(r=s)}return r}function isTagRootTag(t){return t[0]==="E"||t[3]==="root"}async function fetchTaggedEvent(t,e){if(!this.ndk)throw new Error("NDK instance not found");const n=this.getMatchingTags(t,e);if(n.length===0)return;const[r,s,o]=n[0];let a=o!==""?this.ndk.pool.getRelay(o):void 0;return await this.ndk.fetchEvent(s,{},a)}async function fetchRootEvent(t){if(!this.ndk)throw new Error("NDK instance not found");const e=getRootTag(this);if(e)return this.ndk.fetchEventFromTag(e,this,t)}async function fetchReplyEvent(t){if(!this.ndk)throw new Error("NDK instance not found");const e=getReplyTag(this);if(e)return this.ndk.fetchEventFromTag(e,this,t)}function isReplaceable(){if(this.kind===void 0)throw new Error("Kind not set");return[0,3].includes(this.kind)||this.kind>=1e4&&this.kind<2e4||this.kind>=3e4&&this.kind<4e4}function isEphemeral(){if(this.kind===void 0)throw new Error("Kind not set");return this.kind>=2e4&&this.kind<3e4}function isParamReplaceable(){if(this.kind===void 0)throw new Error("Kind not set");return this.kind>=3e4&&this.kind<4e4}var DEFAULT_RELAY_COUNT=2;function encode(t=DEFAULT_RELAY_COUNT){let e=[];return this.onRelays.length>0?e=this.onRelays.map(n=>n.url):this.relay&&(e=[this.relay.url]),e.length>t&&(e=e.slice(0,t)),this.isParamReplaceable()?nip19_exports.naddrEncode({kind:this.kind,pubkey:this.pubkey,identifier:this.replaceableDTag(),relays:e}):e.length>0?nip19_exports.neventEncode({id:this.tagId(),relays:e,author:this.pubkey}):nip19_exports.noteEncode(this.tagId())}async function repost(t=!0,e){if(!e&&t){if(!this.ndk)throw new Error("No NDK instance found");this.ndk.assertSigner(),e=this.ndk.signer}const n=new NDKEvent(this.ndk,{kind:getKind(this)});return this.isProtected||(n.content=JSON.stringify(this.rawEvent())),n.tag(this),this.kind!==1&&n.tags.push(["k",`${this.kind}`]),e&&await n.sign(e),t&&await n.publish(),n}function getKind(t){return t.kind===1?6:16}function serialize(t=!1,e=!1){const n=[0,this.pubkey,this.created_at,this.kind,this.tags,this.content];return t&&n.push(this.sig),e&&n.push(this.id),JSON.stringify(n)}function deserialize(t){const e=JSON.parse(t),n={pubkey:e[1],created_at:e[2],kind:e[3],tags:e[4],content:e[5]};if(e.length>=7){const r=e[6],s=e[7];r&&r.length===128?(n.sig=r,s&&s.length===64&&(n.id=s)):r&&r.length===64&&(n.id=r,s&&s.length===128&&(n.sig=s))}return n}var worker,processingQueue={};function signatureVerificationInit(t){worker=t,worker.onmessage=e=>{const[n,r]=e.data,s=processingQueue[n];if(!s){console.error("No record found for event",n);return}delete processingQueue[n];for(const o of s.resolves)o(r)}}async function verifySignatureAsync(t,e,n){const r=t.ndk,s=Date.now();let o;return r.signatureVerificationFunction?(console.log("[NDK-CORE] Using custom signature verification function async"),o=await r.signatureVerificationFunction(t),console.log("Custom signature verification result",t.id,{result:o})):(console.log("Using worker-based signature verification async"),o=await new Promise(a=>{const c=t.serialize();let l=!1;processingQueue[t.id]||(processingQueue[t.id]={event:t,resolves:[],relay:n},l=!0),processingQueue[t.id].resolves.push(a),l&&(worker==null||worker.postMessage({serialized:c,id:t.id,sig:t.sig,pubkey:t.pubkey}))})),r.signatureVerificationTimeMs+=Date.now()-s,o}var PUBKEY_REGEX=/^[a-f0-9]{64}$/;function validate(){if(typeof this.kind!="number"||typeof this.content!="string"||typeof this.created_at!="number"||typeof this.pubkey!="string"||!this.pubkey.match(PUBKEY_REGEX)||!Array.isArray(this.tags))return!1;for(let t=0;t<this.tags.length;t++){const e=this.tags[t];if(!Array.isArray(e))return!1;for(let n=0;n<e.length;n++)if(typeof e[n]=="object")return!1}return!0}var verifiedSignatures=new dist.LRUCache({maxSize:1e3,entryExpirationTimeInMS:6e4});function verifySignature(t){var n;if(typeof this.signatureVerified=="boolean")return this.signatureVerified;const e=verifiedSignatures.get(this.id);if(e!==null)return this.signatureVerified=!!e,this.signatureVerified;try{if((n=this.ndk)!=null&&n.asyncSigVerification)verifySignatureAsync(this,t,this.relay).then(r=>{var s,o;t&&(this.signatureVerified=r,r&&verifiedSignatures.set(this.id,this.sig)),r||(this.relay?(s=this.ndk)==null||s.reportInvalidSignature(this,this.relay):(o=this.ndk)==null||o.reportInvalidSignature(this),verifiedSignatures.set(this.id,!1))}).catch(r=>{console.error("signature verification error",this.id,r)});else{const r=sha256(new TextEncoder().encode(this.serialize())),s=schnorr$1.verify(this.sig,r,this.pubkey);return s?verifiedSignatures.set(this.id,this.sig):verifiedSignatures.set(this.id,!1),this.signatureVerified=s,s}}catch{return this.signatureVerified=!1,!1}}function getEventHash(){return getEventHashFromSerializedEvent(this.serialize())}function getEventHashFromSerializedEvent(t){const e=sha256(new TextEncoder().encode(t));return bytesToHex$3(e)}var skipClientTagOnKinds=new Set([0,4,1059,13,3,9734,5]),NDKEvent=class de extends lib$1.EventEmitter{constructor(n,r){var s;super();m(this,"ndk");m(this,"created_at");m(this,"content","");m(this,"tags",[]);m(this,"kind");m(this,"id","");m(this,"sig");m(this,"pubkey","");m(this,"signatureVerified");m(this,"_author");m(this,"relay");m(this,"publishStatus","success");m(this,"publishError");m(this,"serialize",serialize.bind(this));m(this,"getEventHash",getEventHash.bind(this));m(this,"validate",validate.bind(this));m(this,"verifySignature",verifySignature.bind(this));m(this,"isReplaceable",isReplaceable.bind(this));m(this,"isEphemeral",isEphemeral.bind(this));m(this,"isDvm",()=>this.kind&&this.kind>=5e3&&this.kind<=7e3);m(this,"isParamReplaceable",isParamReplaceable.bind(this));m(this,"encode",encode.bind(this));m(this,"encrypt",encrypt.bind(this));m(this,"decrypt",decrypt.bind(this));m(this,"fetchTaggedEvent",fetchTaggedEvent.bind(this));m(this,"fetchRootEvent",fetchRootEvent.bind(this));m(this,"fetchReplyEvent",fetchReplyEvent.bind(this));m(this,"repost",repost.bind(this));this.ndk=n,this.created_at=r==null?void 0:r.created_at,this.content=(r==null?void 0:r.content)||"",this.tags=(r==null?void 0:r.tags)||[],this.id=(r==null?void 0:r.id)||"",this.sig=r==null?void 0:r.sig,this.pubkey=(r==null?void 0:r.pubkey)||"",this.kind=r==null?void 0:r.kind,r instanceof de&&(this.relay&&(this.relay=r.relay,(s=this.ndk)==null||s.subManager.seenEvent(r.id,this.relay)),this.publishStatus=r.publishStatus,this.publishError=r.publishError)}get onRelays(){let n=[];return this.ndk?n=this.ndk.subManager.seenEvents.get(this.id)||[]:this.relay&&n.push(this.relay),n}static deserialize(n,r){return new de(n,deserialize(r))}rawEvent(){return{created_at:this.created_at,content:this.content,tags:this.tags,kind:this.kind,pubkey:this.pubkey,id:this.id,sig:this.sig}}set author(n){var r;this.pubkey=n.pubkey,this._author=n,(r=this._author).ndk??(r.ndk=this.ndk)}get author(){if(this._author)return this._author;if(!this.ndk)throw new Error("No NDK instance found");const n=this.ndk.getUser({pubkey:this.pubkey});return this._author=n,n}tagExternal(n,r,s){const o=["i"],a=["k"];switch(r){case"url":{const c=new URL(n);c.hash="",o.push(c.toString()),a.push(`${c.protocol}//${c.host}`);break}case"hashtag":o.push(`#${n.toLowerCase()}`),a.push("#");break;case"geohash":o.push(`geo:${n.toLowerCase()}`),a.push("geo");break;case"isbn":o.push(`isbn:${n.replace(/-/g,"")}`),a.push("isbn");break;case"podcast:guid":o.push(`podcast:guid:${n}`),a.push("podcast:guid");break;case"podcast:item:guid":o.push(`podcast:item:guid:${n}`),a.push("podcast:item:guid");break;case"podcast:publisher:guid":o.push(`podcast:publisher:guid:${n}`),a.push("podcast:publisher:guid");break;case"isan":o.push(`isan:${n.split("-").slice(0,4).join("-")}`),a.push("isan");break;case"doi":o.push(`doi:${n.toLowerCase()}`),a.push("doi");break;default:throw new Error(`Unsupported NIP-73 entity type: ${r}`)}s&&o.push(s),this.tags.push(o),this.tags.push(a)}tag(n,r,s,o){let a=[];if(n.fetchProfile!==void 0){o??(o="p");const l=[o,n.pubkey];r&&l.push("",r),a.push(l)}else if(n instanceof de){const l=n;s??(s=(l==null?void 0:l.pubkey)===this.pubkey),a=l.referenceTags(r,s,o);for(const u of l.getMatchingTags("p"))u[1]!==this.pubkey&&(this.tags.find(h=>h[0]==="p"&&h[1]===u[1])||this.tags.push(["p",u[1]]))}else if(Array.isArray(n))a=[n];else throw new Error("Invalid argument",n);this.tags=mergeTags(this.tags,a)}async toNostrEvent(n){var o,a;if(!n&&this.pubkey===""){const c=await((a=(o=this.ndk)==null?void 0:o.signer)==null?void 0:a.user());this.pubkey=(c==null?void 0:c.pubkey)||""}this.created_at||(this.created_at=Math.floor(Date.now()/1e3));const{content:r,tags:s}=await this.generateTags();this.content=r||"",this.tags=s;try{this.id=this.getEventHash()}catch{}return this.rawEvent()}getMatchingTags(n,r){const s=this.tags.filter(o=>o[0]===n);return r===void 0?s:s.filter(o=>o[3]===r)}hasTag(n,r){return this.tags.some(s=>s[0]===n&&(!r||s[3]===r))}tagValue(n,r){const s=this.getMatchingTags(n,r);if(s.length!==0)return s[0][1]}get alt(){return this.tagValue("alt")}set alt(n){this.removeTag("alt"),n&&this.tags.push(["alt",n])}get dTag(){return this.tagValue("d")}set dTag(n){this.removeTag("d"),n&&this.tags.push(["d",n])}removeTag(n,r){const s=Array.isArray(n)?n:[n];this.tags=this.tags.filter(o=>{const a=s.includes(o[0]),c=r?o[3]===r:!0;return!(a&&c)})}replaceTag(n){this.removeTag(n[0]),this.tags.push(n)}async sign(n){var s,o;n?this.author=await n.user():((s=this.ndk)==null||s.assertSigner(),n=(o=this.ndk)==null?void 0:o.signer);const r=await this.toNostrEvent();return this.sig=await n.sign(r),this.sig}async publishReplaceable(n,r,s){return this.id="",this.created_at=Math.floor(Date.now()/1e3),this.sig="",this.publish(n,r,s)}async publish(n,r,s){var c,l,u;if(s||(s=1),this.sig||await this.sign(),!this.ndk)throw new Error("NDKEvent must be associated with an NDK instance to publish");if((!n||n.size===0)&&(n=this.ndk.devWriteRelaySet||await calculateRelaySetFromEvent(this.ndk,this,s)),this.kind===5&&((c=this.ndk.cacheAdapter)!=null&&c.deleteEventIds)){const h=this.getMatchingTags("e").map(f=>f[1]);this.ndk.cacheAdapter.deleteEventIds(h)}const o=this.rawEvent();if((l=this.ndk.cacheAdapter)!=null&&l.addUnpublishedEvent&&shouldTrackUnpublishedEvent(this))try{this.ndk.cacheAdapter.addUnpublishedEvent(this,n.relayUrls)}catch(h){console.error("Error adding unpublished event to cache",h)}this.kind===5&&((u=this.ndk.cacheAdapter)!=null&&u.deleteEventIds)&&this.ndk.cacheAdapter.deleteEventIds(this.getMatchingTags("e").map(h=>h[1])),this.ndk.subManager.dispatchEvent(o,void 0,!0);const a=await n.publish(this,r,s);return a.forEach(h=>{var f;return(f=this.ndk)==null?void 0:f.subManager.seenEvent(this.id,h)}),a}async generateTags(){var o,a,c;let n=[];const r=await generateContentTags(this.content,this.tags),s=r.content;if(n=r.tags,this.kind&&this.isParamReplaceable()&&!this.getMatchingTags("d")[0]){const u=this.tagValue("title");let f=[...Array(u?6:16)].map(()=>Math.random().toString(36)[2]).join("");u&&u.length>0&&(f=`${u.replace(/[^a-z0-9]+/gi,"-").replace(/^-|-$/g,"")}-${f}`),n.push(["d",f])}if(this.shouldAddClientTag){const l=["client",((o=this.ndk)==null?void 0:o.clientName)??""];(a=this.ndk)!=null&&a.clientNip89&&l.push((c=this.ndk)==null?void 0:c.clientNip89),n.push(l)}else this.shouldStripClientTag&&(n=n.filter(l=>l[0]!=="client"));return{content:s||"",tags:n}}get shouldAddClientTag(){var n,r;return!(!((n=this.ndk)!=null&&n.clientName)&&!((r=this.ndk)!=null&&r.clientNip89)||skipClientTagOnKinds.has(this.kind)||this.isEphemeral()||this.isReplaceable()&&!this.isParamReplaceable()||this.isDvm()||this.hasTag("client"))}get shouldStripClientTag(){return skipClientTagOnKinds.has(this.kind)}muted(){var o,a;const n=(o=this.ndk)==null?void 0:o.mutedIds.get(this.pubkey);if(n&&n==="p")return"author";const r=this.tagReference(),s=(a=this.ndk)==null?void 0:a.mutedIds.get(r[1]);return s&&s===r[0]?"event":null}replaceableDTag(){if(this.kind&&this.kind>=3e4&&this.kind<=4e4){const n=this.getMatchingTags("d")[0];return n?n[1]:""}throw new Error("Event is not a parameterized replaceable event")}deduplicationKey(){return this.kind===0||this.kind===3||this.kind&&this.kind>=1e4&&this.kind<2e4?`${this.kind}:${this.pubkey}`:this.tagId()}tagId(){return this.isParamReplaceable()?this.tagAddress():this.id}tagAddress(){if(this.isParamReplaceable()){const n=this.dTag??"";return`${this.kind}:${this.pubkey}:${n}`}if(this.isReplaceable())return`${this.kind}:${this.pubkey}:`;throw new Error("Event is not a replaceable event")}tagType(){return this.isParamReplaceable()?"a":"e"}tagReference(n){let r;return this.isParamReplaceable()?r=["a",this.tagAddress()]:r=["e",this.tagId()],this.relay?r.push(this.relay.url):r.push(""),r.push(n??""),this.isParamReplaceable()||r.push(this.pubkey),r}referenceTags(n,r,s){let o=[];return this.isParamReplaceable()?o=[[s??"a",this.tagAddress()],[s??"e",this.id]]:o=[[s??"e",this.id]],o=o.map(a=>{var c,l,u;return a[0]==="e"||n?a.push(((c=this.relay)==null?void 0:c.url)??""):(l=this.relay)!=null&&l.url&&a.push((u=this.relay)==null?void 0:u.url),a}),o.forEach(a=>{a[0]==="e"?(a.push(n??""),a.push(this.pubkey)):n&&a.push(n)}),o=[...o,...this.getMatchingTags("h")],r||o.push(...this.author.referenceTags()),o}filter(){return this.isParamReplaceable()?{"#a":[this.tagId()]}:{"#e":[this.tagId()]}}nip22Filter(){return this.isParamReplaceable()?{"#A":[this.tagId()]}:{"#E":[this.tagId()]}}async delete(n,r=!0){var o;if(!this.ndk)throw new Error("No NDK instance found");this.ndk.assertSigner();const s=new de(this.ndk,{kind:5,content:n||""});return s.tag(this,void 0,!0),s.tags.push(["k",(o=this.kind)==null?void 0:o.toString()]),r&&(this.emit("deleted"),await s.publish()),s}set isProtected(n){this.removeTag("-"),n&&this.tags.push(["-"])}get isProtected(){return this.hasTag("-")}async react(n,r=!0){if(!this.ndk)throw new Error("No NDK instance found");this.ndk.assertSigner();const s=new de(this.ndk,{kind:7,content:n});return s.tag(this),this.kind!==1&&s.tags.push(["k",`${this.kind}`]),r&&await s.publish(),s}get isValid(){return this.validate()}get inspect(){return JSON.stringify(this.rawEvent(),null,4)}dump(){console.debug(JSON.stringify(this.rawEvent(),null,4)),console.debug("Event on relays:",this.onRelays.map(n=>n.url).join(", "))}reply(n){var s,o;const r=new de(this.ndk);if(this.kind===1&&!n)r.kind=1,this.hasTag("e")?r.tags=[...r.tags,...this.getMatchingTags("e"),...this.getMatchingTags("p"),...this.getMatchingTags("a"),...this.referenceTags("reply")]:r.tag(this,"root");else{r.kind=1111;const a=["A","E","I","P"],c=this.tags.filter(l=>a.includes(l[0]));if(c.length>0){const l=this.tagValue("K");r.tags.push(...c),l&&r.tags.push(["K",l]);const[u,h,f,...p]=this.tagReference(),g=[u,h,...p];r.tags.push(g)}else{const[l,u,h,f]=this.tagReference(),p=[l,u,f??""];l==="e"&&p.push(this.pubkey),r.tags.push(p);const g=[...p];g[0]=g[0].toUpperCase(),r.tags.push(g),r.tags.push(["K",(s=this.kind)==null?void 0:s.toString()]),r.tags.push(["P",this.pubkey])}r.tags.push(["k",(o=this.kind)==null?void 0:o.toString()]),r.tags.push(...this.getMatchingTags("p")),r.tags.push(["p",this.pubkey])}return r}},untrackedUnpublishedEvents=new Set([24133,13194,23194,23195]);function shouldTrackUnpublishedEvent(t){return!untrackedUnpublishedEvents.has(t.kind)}var NDKPool=class extends lib$1.EventEmitter{constructor(e,n,r,{debug:s,name:o}={}){super();m(this,"_relays",new Map);m(this,"status","idle");m(this,"autoConnectRelays",new Set);m(this,"poolBlacklistRelayUrls",new Set);m(this,"debug");m(this,"temporaryRelayTimers",new Map);m(this,"flappingRelays",new Set);m(this,"backoffTimes",new Map);m(this,"ndk");m(this,"_name","unnamed");this.debug=s??r.debug.extend("pool"),o&&(this._name=o),this.ndk=r,this.relayUrls=e,this.poolBlacklistRelayUrls=new Set(n),this.ndk.pools.push(this)}get blacklistRelayUrls(){const e=new Set(this.ndk.blacklistRelayUrls);return this.poolBlacklistRelayUrls.forEach(n=>e.add(n)),e}get relays(){return this._relays}set relayUrls(e){this._relays.clear();for(const n of e){const r=new NDKRelay(n,void 0,this.ndk);r.connectivity.netDebug=this.ndk.netDebug,this.addRelay(r)}}get name(){return this._name}set name(e){this._name=e,this.debug=this.debug.extend(e)}useTemporaryRelay(e,n=3e4,r){const s=this.relays.has(e.url);s||(this.addRelay(e),this.debug("Adding temporary relay %s for filters %o",e.url,r));const o=this.temporaryRelayTimers.get(e.url);if(o&&clearTimeout(o),!s||o){const a=setTimeout(()=>{var c;(c=this.ndk.explicitRelayUrls)!=null&&c.includes(e.url)||this.removeRelay(e.url)},n);this.temporaryRelayTimers.set(e.url,a)}}addRelay(e,n=!0){var y,b;const r=this.relays.has(e.url),s=(y=this.blacklistRelayUrls)==null?void 0:y.has(e.url),o=e.url.includes("/npub1");let a=!0;const c=e.url;if(r)return;if(s){this.debug(`Refusing to add relay ${c}: blacklisted`);return}if(o){this.debug(`Refusing to add relay ${c}: is a filter relay`);return}if((b=this.ndk.cacheAdapter)!=null&&b.getRelayStatus){const x=this.ndk.cacheAdapter.getRelayStatus(c);if(x!=null&&x.dontConnectBefore){if(x.dontConnectBefore>Date.now()){const _=x.dontConnectBefore-Date.now();this.debug(`Refusing to add relay ${c}: delayed connect for ${_}ms`),setTimeout(()=>{this.addRelay(e,n)},_);return}a=!1}}const l=x=>this.emit("notice",e,x),u=()=>this.handleRelayConnect(c),h=()=>this.handleRelayReady(e),f=()=>this.emit("relay:disconnect",e),p=()=>this.handleFlapping(e),g=x=>this.emit("relay:auth",e,x),w=()=>this.emit("relay:authed",e);e.off("notice",l),e.off("connect",u),e.off("ready",h),e.off("disconnect",f),e.off("flapping",p),e.off("auth",g),e.off("authed",w),e.on("notice",l),e.on("connect",u),e.on("ready",h),e.on("disconnect",f),e.on("flapping",p),e.on("auth",g),e.on("authed",w),e.on("delayed-connect",x=>{var _;(_=this.ndk.cacheAdapter)!=null&&_.updateRelayStatus&&this.ndk.cacheAdapter.updateRelayStatus(e.url,{dontConnectBefore:Date.now()+x})}),this._relays.set(c,e),n&&this.autoConnectRelays.add(c),n&&this.status==="active"&&(this.emit("relay:connecting",e),e.connect(void 0,a).catch(x=>{this.debug(`Failed to connect to relay ${c}`,x)}))}removeRelay(e){const n=this.relays.get(e);if(n)return n.disconnect(),this.relays.delete(e),this.autoConnectRelays.delete(e),this.emit("relay:disconnect",n),!0;const r=this.temporaryRelayTimers.get(e);return r&&(clearTimeout(r),this.temporaryRelayTimers.delete(e)),!1}isRelayConnected(e){const n=normalizeRelayUrl(e),r=this.relays.get(n);return r?r.status===5:!1}getRelay(e,n=!0,r=!1,s){let o=this.relays.get(normalizeRelayUrl(e));return o||(o=new NDKRelay(e,void 0,this.ndk),o.connectivity.netDebug=this.ndk.netDebug,r?this.useTemporaryRelay(o,3e4,s):this.addRelay(o,n)),o}handleRelayConnect(e){const n=this.relays.get(e);if(!n){console.error("NDK BUG: relay not found in pool",{relayUrl:e});return}this.emit("relay:connect",n),this.stats().connected===this.relays.size&&this.emit("connect")}handleRelayReady(e){this.emit("relay:ready",e)}async connect(e){this.status="active",this.debug(`Connecting to ${this.relays.size} relays${e?`, timeout ${e}ms`:""}...`);const n=Array.from(this.autoConnectRelays.keys()).map(a=>this.relays.get(a)).filter(a=>!!a);for(const a of n)a.status!==5&&a.status!==4&&(this.emit("relay:connecting",a),a.connect().catch(c=>{this.debug(`Failed to connect to relay ${a.url}: ${c??"No reason specified"}`)}));const r=()=>n.every(a=>a.status===5),s=new Promise(a=>{if(r()){a();return}const c=[];for(const l of n){const u=()=>{if(r()){for(let h=0;h<n.length;h++)n[h].off("connect",c[h]);a()}};c.push(u),l.on("connect",u)}}),o=typeof e=="number"?new Promise(a=>setTimeout(a,e)):new Promise(()=>{});await Promise.race([s,o])}checkOnFlappingRelays(){const e=this.flappingRelays.size,n=this.relays.size;if(e/n>=.8)for(const r of this.flappingRelays)this.backoffTimes.set(r,0)}handleFlapping(e){this.debug(`Relay ${e.url} is flapping`);let n=this.backoffTimes.get(e.url)||5e3;n=n*2,this.backoffTimes.set(e.url,n),this.debug(`Backoff time for ${e.url} is ${n}ms`),setTimeout(()=>{this.debug(`Attempting to reconnect to ${e.url}`),this.emit("relay:connecting",e),e.connect(),this.checkOnFlappingRelays()},n),e.disconnect(),this.emit("flapping",e)}size(){return this.relays.size}stats(){const e={total:0,connected:0,disconnected:0,connecting:0};for(const n of this.relays.values())e.total++,n.status===5?e.connected++:n.status===1?e.disconnected++:n.status===4&&e.connecting++;return e}connectedRelays(){return Array.from(this.relays.values()).filter(e=>e.status>=5)}permanentAndConnectedRelays(){return Array.from(this.relays.values()).filter(e=>e.status>=5&&!this.temporaryRelayTimers.has(e.url))}urls(){return Array.from(this.relays.keys())}},pe,NDKCashuMintList=(pe=class extends NDKEvent{constructor(n,r){super(n,r);m(this,"_p2pk");this.kind??(this.kind=10019)}static from(n){return new pe(n.ndk,n)}set relays(n){this.tags=this.tags.filter(r=>r[0]!=="relay");for(const r of n)this.tags.push(["relay",r])}get relays(){const n=[];for(const r of this.tags)r[0]==="relay"&&n.push(r[1]);return n}set mints(n){this.tags=this.tags.filter(r=>r[0]!=="mint");for(const r of n)this.tags.push(["mint",r])}get mints(){const n=[];for(const r of this.tags)r[0]==="mint"&&n.push(r[1]);return Array.from(new Set(n))}get p2pk(){return this._p2pk?this._p2pk:(this._p2pk=this.tagValue("pubkey")??this.pubkey,this._p2pk)}set p2pk(n){this._p2pk=n,this.removeTag("pubkey"),n&&this.tags.push(["pubkey",n])}get relaySet(){return NDKRelaySet.fromRelayUrls(this.relays,this.ndk)}},m(pe,"kind",10019),m(pe,"kinds",[10019]),pe),ye,NDKArticle=(ye=class extends NDKEvent{constructor(e,n){super(e,n),this.kind??(this.kind=30023)}static from(e){return new ye(e.ndk,e)}get title(){return this.tagValue("title")}set title(e){this.removeTag("title"),e&&this.tags.push(["title",e])}get image(){return this.tagValue("image")}set image(e){this.removeTag("image"),e&&this.tags.push(["image",e])}get summary(){return this.tagValue("summary")}set summary(e){this.removeTag("summary"),e&&this.tags.push(["summary",e])}get published_at(){const e=this.tagValue("published_at");if(e){let n=Number.parseInt(e);return n>1e12&&(n=Math.floor(n/1e3)),n}}set published_at(e){this.removeTag("published_at"),e!==void 0&&this.tags.push(["published_at",e.toString()])}async generateTags(){return super.generateTags(),this.published_at||(this.published_at=this.created_at),super.generateTags()}get url(){return this.tagValue("url")}set url(e){e?this.tags.push(["url",e]):this.removeTag("url")}},m(ye,"kind",30023),m(ye,"kinds",[30023]),ye);function proofsTotalBalance(t){return t.reduce((e,n)=>{if(n.amount<0)throw new Error("proof amount is negative");return e+n.amount},0)}var we,NDKCashuToken=(we=class extends NDKEvent{constructor(n,r){super(n,r);m(this,"_proofs",[]);m(this,"_mint");m(this,"_deletes",[]);m(this,"original");this.kind??(this.kind=7375)}static async from(n){const r=new we(n.ndk,n);r.original=n;try{await r.decrypt()}catch{r.content=r.original.content}try{const s=JSON.parse(r.content);if(r.proofs=s.proofs,r.mint=s.mint??r.tagValue("mint"),r.deletedTokens=s.del??[],!Array.isArray(r.proofs))return}catch{return}return r}get proofs(){return this._proofs}set proofs(n){const r=new Set;this._proofs=n.filter(s=>r.has(s.C)?(console.warn("Passed in proofs had duplicates, ignoring",s.C),!1):s.amount<0?(console.warn("Invalid proof with negative amount",s),!1):(r.add(s.C),!0)).map(this.cleanProof)}cleanProof(n){return{id:n.id,amount:n.amount,C:n.C,secret:n.secret}}async toNostrEvent(n){if(!this.ndk)throw new Error("no ndk");if(!this.ndk.signer)throw new Error("no signer");const r={proofs:this.proofs.map(this.cleanProof),mint:this.mint,del:this.deletedTokens??[]};this.content=JSON.stringify(r);const s=await this.ndk.signer.user();return await this.encrypt(s,void 0,"nip44"),super.toNostrEvent(n)}set mint(n){this._mint=n}get mint(){return this._mint}get deletedTokens(){return this._deletes}set deletedTokens(n){this._deletes=n}get amount(){return proofsTotalBalance(this.proofs)}async publish(n,r,s){return this.original?this.original.publish(n,r,s):super.publish(n,r,s)}},m(we,"kind",7375),m(we,"kinds",[7375]),we),me,NDKHighlight=(me=class extends NDKEvent{constructor(n,r){super(n,r);m(this,"_article");this.kind??(this.kind=9802)}static from(n){return new me(n.ndk,n)}get url(){return this.tagValue("r")}set context(n){n===void 0?this.tags=this.tags.filter(([r,s])=>r!=="context"):(this.tags=this.tags.filter(([r,s])=>r!=="context"),this.tags.push(["context",n]))}get context(){var n;return((n=this.tags.find(([r,s])=>r==="context"))==null?void 0:n[1])??void 0}get article(){return this._article}set article(n){this._article=n,typeof n=="string"?this.tags.push(["r",n]):this.tag(n)}getArticleTag(){return this.getMatchingTags("a")[0]||this.getMatchingTags("e")[0]||this.getMatchingTags("r")[0]}async getArticle(){var s;if(this._article!==void 0)return this._article;let n;const r=this.getArticleTag();if(r){switch(r[0]){case"a":{const[o,a,c]=r[1].split(":");n=nip19_exports.naddrEncode({kind:Number.parseInt(o),pubkey:a,identifier:c});break}case"e":n=nip19_exports.noteEncode(r[1]);break;case"r":this._article=r[1];break}if(n){let o=await((s=this.ndk)==null?void 0:s.fetchEvent(n));o&&(o.kind===30023&&(o=NDKArticle.from(o)),this._article=o)}return this._article}}},m(me,"kind",9802),m(me,"kinds",[9802]),me);function mapImetaTag(t){const e={};if(t.length===2){const r=t[1].split(" ");for(let s=0;s<r.length;s+=2){const o=r[s],a=r[s+1];o==="fallback"?(e.fallback||(e.fallback=[]),e.fallback.push(a)):e[o]=a}return e}const n=t.slice(1);for(const r of n){const s=r.split(" "),o=s[0],a=s.slice(1).join(" ");o==="fallback"?(e.fallback||(e.fallback=[]),e.fallback.push(a)):e[o]=a}return e}function imetaTagToTag(t){const e=["imeta"];for(const[n,r]of Object.entries(t))if(Array.isArray(r))for(const s of r)e.push(`${n} ${s}`);else r&&e.push(`${n} ${r}`);return e}var be,NDKImage=(be=class extends NDKEvent{constructor(n,r){super(n,r);m(this,"_imetas");this.kind??(this.kind=20)}static from(n){return new be(n.ndk,n.rawEvent())}get isValid(){return this.imetas.length>0}get imetas(){return this._imetas?this._imetas:(this._imetas=this.tags.filter(n=>n[0]==="imeta").map(mapImetaTag).filter(n=>!!n.url),this._imetas)}set imetas(n){this._imetas=n,this.tags=this.tags.filter(r=>r[0]!=="imeta"),this.tags.push(...n.map(imetaTagToTag))}},m(be,"kind",20),m(be,"kinds",[20]),be),Ue,NDKList=(Ue=class extends NDKEvent{constructor(n,r){super(n,r);m(this,"_encryptedTags");m(this,"encryptedTagsLength");this.kind??(this.kind=30001)}static from(n){return new Ue(n.ndk,n)}get title(){const n=this.tagValue("title")||this.tagValue("name");return n||(this.kind===3?"Contacts":this.kind===1e4?"Mute":this.kind===10001?"Pinned Notes":this.kind===10002?"Relay Metadata":this.kind===10003?"Bookmarks":this.kind===10004?"Communities":this.kind===10005?"Public Chats":this.kind===10006?"Blocked Relays":this.kind===10007?"Search Relays":this.kind===10050?"Direct Message Receive Relays":this.kind===10015?"Interests":this.kind===10030?"Emojis":this.tagValue("d"))}set title(n){this.removeTag(["title","name"]),n&&this.tags.push(["title",n])}get name(){return this.title}set name(n){this.title=n}get description(){return this.tagValue("description")}set description(n){this.removeTag("description"),n&&this.tags.push(["description",n])}get image(){return this.tagValue("image")}set image(n){this.removeTag("image"),n&&this.tags.push(["image",n])}isEncryptedTagsCacheValid(){return!!(this._encryptedTags&&this.encryptedTagsLength===this.content.length)}async encryptedTags(n=!0){if(n&&this.isEncryptedTagsCacheValid())return this._encryptedTags;if(!this.ndk)throw new Error("NDK instance not set");if(!this.ndk.signer)throw new Error("NDK signer not set");const r=await this.ndk.signer.user();try{if(this.content.length>0)try{const s=await this.ndk.signer.decrypt(r,this.content),o=JSON.parse(s);return o!=null&&o[0]?(this.encryptedTagsLength=this.content.length,this._encryptedTags=o):(this.encryptedTagsLength=this.content.length,this._encryptedTags=[])}catch{}}catch{}return[]}validateTag(n){return!0}getItems(n){return this.tags.filter(r=>r[0]===n)}get items(){return this.tags.filter(n=>!["d","L","l","title","name","description","published_at","summary","image","thumb","alt","expiration","subject","client"].includes(n[0]))}async addItem(n,r=void 0,s=!1,o="bottom"){if(!this.ndk)throw new Error("NDK instance not set");if(!this.ndk.signer)throw new Error("NDK signer not set");let a;if(n instanceof NDKEvent)a=[n.tagReference(r)];else if(n instanceof NDKUser)a=n.referenceTags();else if(n instanceof NDKRelay)a=n.referenceTags();else if(Array.isArray(n))a=[n];else throw new Error("Invalid object type");if(r&&a[0].push(r),s){const c=await this.ndk.signer.user(),l=await this.encryptedTags();o==="top"?l.unshift(...a):l.push(...a),this._encryptedTags=l,this.encryptedTagsLength=this.content.length,this.content=JSON.stringify(l),await this.encrypt(c)}else o==="top"?this.tags.unshift(...a):this.tags.push(...a);this.created_at=Math.floor(Date.now()/1e3),this.emit("change")}async removeItemByValue(n,r=!0){if(!this.ndk)throw new Error("NDK instance not set");if(!this.ndk.signer)throw new Error("NDK signer not set");const s=this.tags.findIndex(l=>l[1]===n);s>=0&&this.tags.splice(s,1);const o=await this.ndk.signer.user(),a=await this.encryptedTags(),c=a.findIndex(l=>l[1]===n);if(c>=0&&(a.splice(c,1),this._encryptedTags=a,this.encryptedTagsLength=this.content.length,this.content=JSON.stringify(a),await this.encrypt(o)),r)return this.publishReplaceable();this.created_at=Math.floor(Date.now()/1e3),this.emit("change")}async removeItem(n,r){if(!this.ndk)throw new Error("NDK instance not set");if(!this.ndk.signer)throw new Error("NDK signer not set");if(r){const s=await this.ndk.signer.user(),o=await this.encryptedTags();o.splice(n,1),this._encryptedTags=o,this.encryptedTagsLength=this.content.length,this.content=JSON.stringify(o),await this.encrypt(s)}else this.tags.splice(n,1);return this.created_at=Math.floor(Date.now()/1e3),this.emit("change"),this}has(n){return this.items.some(r=>r[1]===n)}filterForItems(){const n=new Set,r=new Map,s=[];for(const o of this.items)if(o[0]==="e"&&o[1])n.add(o[1]);else if(o[0]==="a"&&o[1]){const[a,c,l]=o[1].split(":");if(!a||!c)continue;const u=`${a}:${c}`,h=r.get(u)||[];h.push(l||""),r.set(u,h)}if(n.size>0&&s.push({ids:Array.from(n)}),r.size>0)for(const[o,a]of r.entries()){const[c,l]=o.split(":");s.push({kinds:[Number.parseInt(c)],authors:[l],"#d":a})}return s}},m(Ue,"kinds",[10063,30001,10004,10050,10030,10015,10001,10002,10007,10006,10003]),Ue),lists_default=NDKList,ue,NDKNutzap=(ue=class extends NDKEvent{constructor(n,r){super(n,r);m(this,"debug");m(this,"_proofs",[]);m(this,"sender",this.author);this.kind??(this.kind=9321),this.debug=(n==null?void 0:n.debug.extend("nutzap"))??createDebug5("ndk:nutzap"),this.alt||(this.alt="This is a nutzap");try{const s=this.getMatchingTags("proof");s.length?this._proofs=s.map(o=>JSON.parse(o[1])):this._proofs=JSON.parse(this.content)}catch{return}}static from(n){const r=new ue(n.ndk,n);if(!(!r._proofs||!r._proofs.length))return r}set comment(n){this.content=n??""}get comment(){const n=this.tagValue("comment");return n||this.content}set proofs(n){this._proofs=n,this.tags=this.tags.filter(r=>r[0]!=="proof");for(const r of n)this.tags.push(["proof",JSON.stringify(r)])}get proofs(){return this._proofs}get rawP2pk(){var r;const n=this.proofs[0];try{const s=JSON.parse(n.secret);let o;if(typeof s=="string"?(o=JSON.parse(s),this.debug("stringified payload",n.secret)):typeof s=="object"&&(o=s),Array.isArray(o)&&o[0]==="P2PK"&&o.length>1&&typeof o[1]=="object"&&o[1]!==null||typeof o=="object"&&o!==null&&typeof((r=o[1])==null?void 0:r.data)=="string")return o[1].data}catch(s){this.debug("error parsing p2pk pubkey",s,this.proofs[0])}}get p2pk(){const n=this.rawP2pk;if(n)return n.startsWith("02")?n.slice(2):n}get mint(){return this.tagValue("u")}set mint(n){this.replaceTag(["u",n])}get unit(){let n=this.tagValue("unit")??"sat";return n!=null&&n.startsWith("msat")&&(n="sat"),n}set unit(n){if(this.removeTag("unit"),n!=null&&n.startsWith("msat"))throw new Error("msat is not allowed, use sat denomination instead");n&&this.tag(["unit",n])}get amount(){return this.proofs.reduce((r,s)=>r+s.amount,0)}set target(n){this.tags=this.tags.filter(r=>r[0]!=="p"),n instanceof NDKEvent&&this.tags.push(n.tagReference())}set recipientPubkey(n){this.removeTag("p"),this.tag(["p",n])}get recipientPubkey(){return this.tagValue("p")}get recipient(){const n=this.recipientPubkey;return this.ndk?this.ndk.getUser({pubkey:n}):new NDKUser({pubkey:n})}async toNostrEvent(){this.unit==="msat"&&(this.unit="sat"),this.removeTag("amount"),this.tags.push(["amount",this.amount.toString()]);const n=await super.toNostrEvent();return n.content=this.comment,n}get isValid(){let n=0,r=0,s=0;for(const o of this.tags)o[0]==="e"&&n++,o[0]==="p"&&r++,o[0]==="u"&&s++;return r===1&&s===1&&n<=1&&this.proofs.length>0}},m(ue,"kind",9321),m(ue,"kinds",[ue.kind]),ue),Ee,NDKSimpleGroupMemberList=(Ee=class extends NDKEvent{constructor(n,r){super(n,r);m(this,"relaySet");m(this,"memberSet",new Set);this.kind??(this.kind=39002),this.memberSet=new Set(this.members)}static from(n){return new Ee(n.ndk,n)}get members(){return this.getMatchingTags("p").map(n=>n[1])}hasMember(n){return this.memberSet.has(n)}async publish(n,r,s){return n??(n=this.relaySet),super.publishReplaceable(n,r,s)}},m(Ee,"kind",39002),m(Ee,"kinds",[39002]),Ee),ve,NDKSimpleGroupMetadata=(ve=class extends NDKEvent{constructor(e,n){super(e,n),this.kind??(this.kind=39e3)}static from(e){return new ve(e.ndk,e)}get name(){return this.tagValue("name")}get picture(){return this.tagValue("picture")}get about(){return this.tagValue("about")}get scope(){if(this.getMatchingTags("public").length>0)return"public";if(this.getMatchingTags("public").length>0)return"private"}set scope(e){this.removeTag("public"),this.removeTag("private"),e==="public"?this.tags.push(["public",""]):e==="private"&&this.tags.push(["private",""])}get access(){if(this.getMatchingTags("open").length>0)return"open";if(this.getMatchingTags("closed").length>0)return"closed"}set access(e){this.removeTag("open"),this.removeTag("closed"),e==="open"?this.tags.push(["open",""]):e==="closed"&&this.tags.push(["closed",""])}},m(ve,"kind",39e3),m(ve,"kinds",[39e3]),ve);function strToPosition(t){const[e,n]=t.split(",").map(Number);return{x:e,y:n}}function strToDimension(t){const[e,n]=t.split("x").map(Number);return{width:e,height:n}}var ae,NDKStorySticker=(ae=class{constructor(e){m(this,"type");m(this,"value");m(this,"position");m(this,"dimension");m(this,"properties");m(this,"hasValidDimensions",()=>typeof this.dimension.width=="number"&&typeof this.dimension.height=="number"&&!Number.isNaN(this.dimension.width)&&!Number.isNaN(this.dimension.height));m(this,"hasValidPosition",()=>typeof this.position.x=="number"&&typeof this.position.y=="number"&&!Number.isNaN(this.position.x)&&!Number.isNaN(this.position.y));if(Array.isArray(e)){const n=e;if(n[0]!=="sticker"||n.length<5)throw new Error("Invalid sticker tag");this.type=n[1],this.value=n[2],this.position=strToPosition(n[3]),this.dimension=strToDimension(n[4]);const r={};for(let s=5;s<n.length;s++){const[o,...a]=n[s].split(" ");r[o]=a.join(" ")}Object.keys(r).length>0&&(this.properties=r)}else this.type=e,this.value=void 0,this.position={x:0,y:0},this.dimension={width:0,height:0}}static fromTag(e){try{return new ae(e)}catch{return null}}get style(){var e;return(e=this.properties)==null?void 0:e.style}set style(e){var n;e?this.properties={...this.properties,style:e}:(n=this.properties)==null||delete n.style}get rotation(){var e;return(e=this.properties)!=null&&e.rot?Number.parseFloat(this.properties.rot):void 0}set rotation(e){var n;e!==void 0?this.properties={...this.properties,rot:e.toString()}:(n=this.properties)==null||delete n.rot}get isValid(){return this.hasValidDimensions()&&this.hasValidPosition()}toTag(){if(!this.isValid){const r=[this.hasValidDimensions()?void 0:"dimensions is invalid",this.hasValidPosition()?void 0:"position is invalid"].filter(Boolean);throw new Error(`Invalid sticker: ${r.join(", ")}`)}let e;switch(this.type){case"event":e=this.value.tagId();break;case"pubkey":e=this.value.pubkey;break;default:e=this.value}const n=["sticker",this.type,e,coordinates(this.position),dimension(this.dimension)];if(this.properties)for(const[r,s]of Object.entries(this.properties))n.push(`${r} ${s}`);return n}},m(ae,"Text","text"),m(ae,"Pubkey","pubkey"),m(ae,"Event","event"),m(ae,"Prompt","prompt"),m(ae,"Countdown","countdown"),ae),xe,NDKStory=(xe=class extends NDKEvent{constructor(n,r){super(n,r);m(this,"_imeta");m(this,"_dimensions");if(this.kind??(this.kind=23),r)for(const s of r.tags)switch(s[0]){case"imeta":this._imeta=mapImetaTag(s);break;case"dim":this.dimensions=strToDimension(s[1]);break}}static from(n){return new xe(n.ndk,n)}get isValid(){return!!this.imeta}get imeta(){return this._imeta}set imeta(n){this._imeta=n,this.tags=this.tags.filter(r=>r[0]!=="imeta"),n&&this.tags.push(imetaTagToTag(n))}get dimensions(){const n=this.tagValue("dim");if(n)return strToDimension(n)}set dimensions(n){this.removeTag("dim"),n&&this.tags.push(["dim",`${n.width}x${n.height}`])}get duration(){const n=this.tagValue("dur");if(n)return Number.parseInt(n)}set duration(n){this.removeTag("dur"),n!==void 0&&this.tags.push(["dur",n.toString()])}get stickers(){const n=[];for(const r of this.tags){if(r[0]!=="sticker"||r.length<5)continue;const s=NDKStorySticker.fromTag(r);s&&n.push(s)}return n}addSticker(n){let r;if(n instanceof NDKStorySticker)r=n;else{const s=["sticker",n.type,typeof n.value=="string"?n.value:"",coordinates(n.position),dimension(n.dimension)];if(n.properties)for(const[o,a]of Object.entries(n.properties))s.push(`${o} ${a}`);r=new NDKStorySticker(s),r.value=n.value}r.type==="pubkey"?this.tag(r.value):r.type==="event"&&this.tag(r.value),this.tags.push(r.toTag())}removeSticker(n){const r=this.stickers;if(n<0||n>=r.length)return;let s=0;for(let o=0;o<this.tags.length;o++)if(this.tags[o][0]==="sticker"){if(s===n){this.tags.splice(o,1);break}s++}}},m(xe,"kind",23),m(xe,"kinds",[23]),xe),coordinates=t=>`${t.x},${t.y}`,dimension=t=>`${t.width}x${t.height}`,possibleIntervalFrequencies=["daily","weekly","monthly","quarterly","yearly"];function newAmount(t,e,n){return["amount",t.toString(),e,n]}function parseTagToSubscriptionAmount(t){const e=Number.parseInt(t[1]);if(Number.isNaN(e)||e===void 0||e===null||e<=0)return;const n=t[2];if(n===void 0||n==="")return;const r=t[3];if(r!==void 0&&possibleIntervalFrequencies.includes(r))return{amount:e,currency:n,term:r}}var Se,NDKSubscriptionTier=(Se=class extends NDKArticle{constructor(e,n){const r=(n==null?void 0:n.kind)??37001;super(e,n),this.kind=r}static from(e){return new Se(e.ndk,e)}get perks(){return this.getMatchingTags("perk").map(e=>e[1]).filter(e=>e!==void 0)}addPerk(e){this.tags.push(["perk",e])}get amounts(){return this.getMatchingTags("amount").map(e=>parseTagToSubscriptionAmount(e)).filter(e=>e!==void 0)}addAmount(e,n,r){this.tags.push(newAmount(e,n,r))}set relayUrl(e){this.tags.push(["r",e])}get relayUrls(){return this.getMatchingTags("r").map(e=>e[1]).filter(e=>e!==void 0)}get verifierPubkey(){return this.tagValue("p")}set verifierPubkey(e){this.removeTag("p"),e&&this.tags.push(["p",e])}get isValid(){return this.title!==void 0&&this.amounts.length>0}},m(Se,"kind",37001),m(Se,"kinds",[37001]),Se),Te,NDKVideo=(Te=class extends NDKEvent{constructor(){super(...arguments);m(this,"_imetas")}static from(n){return new Te(n.ndk,n.rawEvent())}get title(){return this.tagValue("title")}set title(n){this.removeTag("title"),n&&this.tags.push(["title",n])}get thumbnail(){var r;let n;return this.imetas&&this.imetas.length>0&&(n=(r=this.imetas[0].image)==null?void 0:r[0]),n??this.tagValue("thumb")}get imetas(){return this._imetas?this._imetas:(this._imetas=this.tags.filter(n=>n[0]==="imeta").map(mapImetaTag),this._imetas)}set imetas(n){this._imetas=n,this.tags=this.tags.filter(r=>r[0]!=="imeta"),this.tags.push(...n.map(imetaTagToTag))}get url(){return this.imetas&&this.imetas.length>0?this.imetas[0].url:this.tagValue("url")}get published_at(){const n=this.tagValue("published_at");if(n)return Number.parseInt(n)}async generateTags(){var n,r;if(super.generateTags(),!this.kind&&(r=(n=this.imetas)==null?void 0:n[0])!=null&&r.dim){const[s,o]=this.imetas[0].dim.split("x"),a=s&&o&&Number.parseInt(s)<Number.parseInt(o);this.duration&&this.duration<120&&a?this.kind=22:this.kind=21}return super.generateTags()}get duration(){const n=this.tagValue("duration");if(n)return Number.parseInt(n)}set duration(n){this.removeTag("duration"),n!==void 0&&this.tags.push(["duration",Math.floor(n).toString()])}},m(Te,"kind",21),m(Te,"kinds",[34235,34236,22,21]),Te),ke,NDKWiki=(ke=class extends NDKArticle{static from(e){return new ke(e.ndk,e.rawEvent())}get isDefered(){return this.hasTag("a","defer")}get deferedId(){return this.tagValue("a","defer")}set defer(e){this.removeTag("a","defer"),this.tag(e,"defer")}},m(ke,"kind",30818),m(ke,"kinds",[30818]),ke),Pe,NDKBlossomList=(Pe=class extends NDKEvent{constructor(e,n){super(e,n),this.kind??(this.kind=10063)}static from(e){return new Pe(e.ndk,e.rawEvent())}get servers(){return this.tags.filter(e=>e[0]==="server").map(e=>e[1])}set servers(e){this.tags=this.tags.filter(n=>n[0]!=="server");for(const n of e)this.tags.push(["server",n])}get default(){const e=this.servers;return e.length>0?e[0]:void 0}set default(e){if(!e)return;const r=this.servers.filter(s=>s!==e);this.servers=[e,...r]}addServer(e){if(!e)return;const n=this.servers;n.includes(e)||(this.servers=[...n,e])}removeServer(e){if(!e)return;const n=this.servers;this.servers=n.filter(r=>r!==e)}},m(Pe,"kinds",[10063]),Pe),$e,NDKFollowPack=($e=class extends NDKEvent{constructor(e,n){super(e,n),this.kind??(this.kind=39089)}static from(e){return new $e(e.ndk,e)}get title(){return this.tagValue("title")}set title(e){this.removeTag("title"),e&&this.tags.push(["title",e])}get image(){const e=this.tags.find(n=>n[0]==="imeta");if(e){const n=mapImetaTag(e);if(n.url)return n.url}return this.tagValue("image")}set image(e){this.tags=this.tags.filter(n=>n[0]!=="imeta"&&n[0]!=="image"),typeof e=="string"?e!==void 0&&this.tags.push(["image",e]):e&&typeof e=="object"&&(this.tags.push(imetaTagToTag(e)),e.url&&this.tags.push(["image",e.url]))}get pubkeys(){return Array.from(new Set(this.tags.filter(e=>e[0]==="p").map(e=>e[1])))}set pubkeys(e){this.tags=this.tags.filter(n=>n[0]!=="p");for(const n of e)this.tags.push(["p",n])}get description(){return this.tagValue("description")}set description(e){this.removeTag("description"),e&&this.tags.push(["description",e])}},m($e,"kind",39089),m($e,"kinds",[39089,39092]),$e),signerRegistry=new Map;function registerSigner(t,e){signerRegistry.set(t,e)}var NDKPrivateKeySigner=class Me{constructor(e,n){m(this,"_user");m(this,"_privateKey");m(this,"_pubkey");if(typeof e=="string")if(e.startsWith("nsec1")){const{type:r,data:s}=nip19_exports.decode(e);if(r==="nsec")this._privateKey=s;else throw new Error("Invalid private key provided.")}else if(e.length===64)this._privateKey=hexToBytes$3(e);else throw new Error("Invalid private key provided.");else this._privateKey=e;this._pubkey=getPublicKey(this._privateKey),n&&(this._user=n.getUser({pubkey:this._pubkey})),this._user??(this._user=new NDKUser({pubkey:this._pubkey}))}get privateKey(){if(!this._privateKey)throw new Error("Not ready");return bytesToHex$3(this._privateKey)}get pubkey(){if(!this._pubkey)throw new Error("Not ready");return this._pubkey}get nsec(){if(!this._privateKey)throw new Error("Not ready");return nip19_exports.nsecEncode(this._privateKey)}get npub(){if(!this._pubkey)throw new Error("Not ready");return nip19_exports.npubEncode(this._pubkey)}static generate(){const e=generateSecretKey();return new Me(e)}async blockUntilReady(){return this._user}async user(){return this._user}get userSync(){return this._user}async sign(e){if(!this._privateKey)throw Error("Attempted to sign without a private key");return finalizeEvent(e,this._privateKey).sig}async encryptionEnabled(e){const n=[];return(!e||e==="nip04")&&n.push("nip04"),(!e||e==="nip44")&&n.push("nip44"),n}async encrypt(e,n,r){if(!this._privateKey||!this.privateKey)throw Error("Attempted to encrypt without a private key");const s=e.pubkey;if(r==="nip44"){const o=nip44_exports.v2.utils.getConversationKey(this._privateKey,s);return await nip44_exports.v2.encrypt(n,o)}return await nip04_exports.encrypt(this._privateKey,s,n)}async decrypt(e,n,r){if(!this._privateKey||!this.privateKey)throw Error("Attempted to decrypt without a private key");const s=e.pubkey;if(r==="nip44"){const o=nip44_exports.v2.utils.getConversationKey(this._privateKey,s);return await nip44_exports.v2.decrypt(n,o)}return await nip04_exports.decrypt(this._privateKey,s,n)}toPayload(){if(!this._privateKey)throw new Error("Private key not available");const e={type:"private-key",payload:this.privateKey};return JSON.stringify(e)}static async fromPayload(e,n){const r=JSON.parse(e);if(r.type!=="private-key")throw new Error(`Invalid payload type: expected 'private-key', got ${r.type}`);if(!r.payload||typeof r.payload!="string")throw new Error("Invalid payload content for private-key signer");return new Me(r.payload,n)}};registerSigner("private-key",NDKPrivateKeySigner);var he,NDKProject=(he=class extends NDKEvent{constructor(n,r){super(n,r);m(this,"_signer");this.kind=31933}static from(n){return new he(n.ndk,n.rawEvent())}set repo(n){this.removeTag("repo"),n&&this.tags.push(["repo",n])}set hashtags(n){this.removeTag("hashtags"),n.filter(r=>r.length>0).length&&this.tags.push(["hashtags",...n])}get hashtags(){const n=this.tags.find(r=>r[0]==="hashtags");return n?n.slice(1):[]}get repo(){return this.tagValue("repo")}get title(){return this.tagValue("title")}set title(n){this.removeTag("title"),n&&this.tags.push(["title",n])}get picture(){return this.tagValue("picture")}set picture(n){this.removeTag("picture"),n&&this.tags.push(["picture",n])}set description(n){this.content=n}get description(){return this.content}get slug(){return this.dTag??"empty-dtag"}async getSigner(){var r,s;if(this._signer)return this._signer;const n=this.tagValue("key");if(!n)this._signer=NDKPrivateKeySigner.generate(),await this.encryptAndSaveNsec();else{const o=await((s=(r=this.ndk)==null?void 0:r.signer)==null?void 0:s.decrypt(this.ndk.activeUser,n));if(!o)throw new Error("Failed to decrypt project key or missing signer context.");this._signer=new NDKPrivateKeySigner(o)}return this._signer}async getNsec(){return(await this.getSigner()).privateKey}async setNsec(n){this._signer=new NDKPrivateKeySigner(n),await this.encryptAndSaveNsec()}async encryptAndSaveNsec(){var s,o;if(!this._signer)throw new Error("Signer is not set.");const n=this._signer.privateKey,r=await((o=(s=this.ndk)==null?void 0:s.signer)==null?void 0:o.encrypt(this.ndk.activeUser,n));r&&(this.removeTag("key"),this.tags.push(["key",r]))}},m(he,"kind",31933),m(he,"kinds",[he.kind]),he),Ae,NDKThread=(Ae=class extends NDKEvent{constructor(e,n){super(e,n),this.kind??(this.kind=11)}static from(e){return new Ae(e.ndk,e)}get title(){return this.tagValue("title")}set title(e){this.removeTag("title"),e&&this.tags.push(["title",e])}},m(Ae,"kind",11),m(Ae,"kinds",[11]),Ae),_e,NDKDraft=(_e=class extends NDKEvent{constructor(n,r){super(n,r);m(this,"_event");m(this,"counterparty");this.kind??(this.kind=31234)}static from(n){return new _e(n.ndk,n)}set identifier(n){this.removeTag("d"),this.tags.push(["d",n])}get identifier(){return this.dTag}set event(n){n instanceof NDKEvent?this._event=n:this._event=new NDKEvent(void 0,n),this.prepareEvent()}set checkpoint(n){n?(this.tags.push(n.tagReference()),this.kind=1234):(this.removeTag("a"),this.kind=31234)}get isCheckpoint(){return this.kind===1234}get isProposal(){const n=this.tagValue("p");return!!n&&n!==this.pubkey}async getEvent(n){var r;if(this._event)return this._event;if(n??(n=(r=this.ndk)==null?void 0:r.signer),!n)throw new Error("No signer available");if(this.content&&this.content.length>0)try{const s=n.pubkey,a=[this.tagValue("p"),this.pubkey].filter(Boolean).find(u=>u!==s);let c;c=new NDKUser({pubkey:a??s}),await this.decrypt(c,n);const l=JSON.parse(this.content);return this._event=await wrapEvent(new NDKEvent(this.ndk,l)),this._event}catch(s){console.error(s);return}else return null}prepareEvent(){if(!this._event)throw new Error("No event has been provided");this.removeTag("k"),this._event.kind&&this.tags.push(["k",this._event.kind.toString()]),this.content=JSON.stringify(this._event.rawEvent())}async save({signer:n,publish:r,relaySet:s}){var a;if(n??(n=(a=this.ndk)==null?void 0:a.signer),!n)throw new Error("No signer available");const o=this.counterparty||await n.user();if(await this.encrypt(o,n),this.counterparty){const c=this.counterparty.pubkey;this.removeTag("p"),this.tags.push(["p",c])}if(r!==!1)return this.publishReplaceable(s)}},m(_e,"kind",31234),m(_e,"kinds",[31234,1234]),_e),Ce,NDKTask=(Ce=class extends NDKEvent{constructor(e,n){super(e,n),this.kind=1934}static from(e){return new Ce(e.ndk,e.rawEvent())}set title(e){this.removeTag("title"),e&&this.tags.push(["title",e])}get title(){return this.tagValue("title")}set project(e){this.removeTag("a"),this.tags.push(e.tagReference())}get projectSlug(){var n;const e=this.getMatchingTags("a")[0];return e?(n=e[1].split(/:/))==null?void 0:n[2]:void 0}},m(Ce,"kind",1934),m(Ce,"kinds",[1934]),Ce),Ie,NDKProjectTemplate=(Ie=class extends NDKEvent{constructor(e,n){super(e,n),this.kind=30717}static from(e){return new Ie(e.ndk,e.rawEvent())}get templateId(){return this.dTag??""}set templateId(e){this.dTag=e}get name(){return this.tagValue("title")??""}set name(e){this.removeTag("title"),e&&this.tags.push(["title",e])}get description(){return this.tagValue("description")??""}set description(e){this.removeTag("description"),e&&this.tags.push(["description",e])}get repoUrl(){return this.tagValue("uri")??""}set repoUrl(e){this.removeTag("uri"),e&&this.tags.push(["uri",e])}get image(){return this.tagValue("image")}set image(e){this.removeTag("image"),e&&this.tags.push(["image",e])}get command(){return this.tagValue("command")}set command(e){this.removeTag("command"),e&&this.tags.push(["command",e])}get agentConfig(){const e=this.tagValue("agent");if(e)try{return JSON.parse(e)}catch{return}}set agentConfig(e){this.removeTag("agent"),e&&this.tags.push(["agent",JSON.stringify(e)])}get templateTags(){return this.getMatchingTags("t").map(e=>e[1]).filter(Boolean)}set templateTags(e){this.tags=this.tags.filter(n=>n[0]!=="t"),e.forEach(n=>{n&&this.tags.push(["t",n])})}},m(Ie,"kind",30717),m(Ie,"kinds",[30717]),Ie),registeredEventClasses=new Set;function wrapEvent(t){const e=new Map,r=[...[NDKImage,NDKVideo,NDKCashuMintList,NDKArticle,NDKHighlight,NDKDraft,NDKWiki,NDKNutzap,NDKProject,NDKTask,NDKProjectTemplate,NDKSimpleGroupMemberList,NDKSimpleGroupMetadata,NDKSubscriptionTier,NDKCashuToken,NDKList,NDKStory,NDKBlossomList,NDKFollowPack,NDKThread],...registeredEventClasses];for(const o of r)for(const a of o.kinds)e.set(a,o);const s=e.get(t.kind);return s?s.from(t):t}function queryFullyFilled(t){return!!(filterIncludesIds(t.filter)&&resultHasAllRequestedIds(t))}function filterIncludesIds(t){return!!t.ids}function resultHasAllRequestedIds(t){const e=t.filter.ids;return!!e&&e.length===t.eventFirstSeen.size}function filterFromId(t){let e;if(t.match(NIP33_A_REGEX)){const[n,r,s]=t.split(":"),o={authors:[r],kinds:[Number.parseInt(n)]};return s&&(o["#d"]=[s]),o}if(t.match(BECH32_REGEX))try{switch(e=nip19_exports.decode(t),e.type){case"nevent":{const n={ids:[e.data.id]};return e.data.author&&(n.authors=[e.data.author]),e.data.kind&&(n.kinds=[e.data.kind]),n}case"note":return{ids:[e.data]};case"naddr":{const n={authors:[e.data.pubkey],kinds:[e.data.kind]};return e.data.identifier&&(n["#d"]=[e.data.identifier]),n}}}catch(n){console.error("Error decoding",t,n)}return{ids:[t]}}function isNip33AValue(t){return t.match(NIP33_A_REGEX)!==null}var NIP33_A_REGEX=/^(\d+):([0-9A-Fa-f]+)(?::(.*))?$/,BECH32_REGEX=/^n(event|ote|profile|pub|addr)1[\d\w]+$/;function relaysFromBech32(t,e){try{const n=nip19_exports.decode(t);if(["naddr","nevent"].includes(n==null?void 0:n.type)){const r=n.data;if(r!=null&&r.relays)return r.relays.map(s=>new NDKRelay(s,e.relayAuthDefaultPolicy,e))}}catch{}return[]}var defaultOpts={closeOnEose:!1,cacheUsage:"CACHE_FIRST",dontSaveToCache:!1,groupable:!0,groupableDelay:100,groupableDelayType:"at-most",cacheUnconstrainFilter:["limit","since","until"]},NDKSubscription=class extends lib$1.EventEmitter{constructor(e,n,r,s){super();m(this,"subId");m(this,"filters");m(this,"opts");m(this,"pool");m(this,"skipVerification",!1);m(this,"skipValidation",!1);m(this,"relayFilters");m(this,"relaySet");m(this,"ndk");m(this,"debug");m(this,"eventFirstSeen",new Map);m(this,"eosesSeen",new Set);m(this,"lastEventReceivedAt");m(this,"mostRecentCacheEventTimestamp");m(this,"internalId");m(this,"closeOnEose");m(this,"poolMonitor");m(this,"skipOptimisticPublishEvent",!1);m(this,"cacheUnconstrainFilter");m(this,"onStopped");m(this,"eoseTimeout");m(this,"eosed",!1);this.ndk=e,this.opts={...defaultOpts,...r||{}},this.pool=this.opts.pool||e.pool,this.filters=Array.isArray(n)?n:[n],this.subId=s||this.opts.subId,this.internalId=Math.random().toString(36).substring(7),this.debug=e.debug.extend(`subscription[${this.opts.subId??this.internalId}]`),this.opts.relaySet?this.relaySet=this.opts.relaySet:this.opts.relayUrls&&(this.relaySet=NDKRelaySet.fromRelayUrls(this.opts.relayUrls,this.ndk)),this.skipVerification=this.opts.skipVerification||!1,this.skipValidation=this.opts.skipValidation||!1,this.closeOnEose=this.opts.closeOnEose||!1,this.skipOptimisticPublishEvent=this.opts.skipOptimisticPublishEvent||!1,this.cacheUnconstrainFilter=this.opts.cacheUnconstrainFilter}relaysMissingEose(){var n;return this.relayFilters?Array.from((n=this.relayFilters)==null?void 0:n.keys()).filter(r=>!this.eosesSeen.has(this.pool.getRelay(r,!1,!1))):[]}get filter(){return this.filters[0]}get groupableDelay(){var e;if(this.isGroupable())return(e=this.opts)==null?void 0:e.groupableDelay}get groupableDelayType(){var e;return((e=this.opts)==null?void 0:e.groupableDelayType)||"at-most"}isGroupable(){var e;return((e=this.opts)==null?void 0:e.groupable)||!1}shouldQueryCache(){var n;return this.opts.addSinceFromCache?!0:((n=this.opts)==null?void 0:n.cacheUsage)==="ONLY_RELAY"?!1:(this.filters.some(r=>{var s;return(s=r.kinds)==null?void 0:s.some(o=>kindIsEphemeral(o))}),!0)}shouldQueryRelays(){var e;return((e=this.opts)==null?void 0:e.cacheUsage)!=="ONLY_CACHE"}shouldWaitForCache(){var e;return this.opts.addSinceFromCache?!0:!!this.opts.closeOnEose&&!!((e=this.ndk.cacheAdapter)!=null&&e.locking)&&this.opts.cacheUsage!=="PARALLEL"}start(e=!0){let n;const r=o=>{if(e)for(const a of o)a.created_at&&(!this.mostRecentCacheEventTimestamp||a.created_at>this.mostRecentCacheEventTimestamp)&&(this.mostRecentCacheEventTimestamp=a.created_at),this.eventReceived(a,void 0,!0,!1);else{n=[];for(const a of o){a.created_at&&(!this.mostRecentCacheEventTimestamp||a.created_at>this.mostRecentCacheEventTimestamp)&&(this.mostRecentCacheEventTimestamp=a.created_at),a.ndk=this.ndk;const c=this.opts.wrap?wrapEvent(a):a;if(!c)break;if(c instanceof Promise){c.then(l=>{this.emitEvent(!1,l,void 0,!0,!1)});break}this.eventFirstSeen.set(c.id,Date.now()),n.push(c)}}},s=()=>{this.shouldQueryRelays()?(this.startWithRelays(),this.startPoolMonitor()):this.emit("eose",this)};return this.shouldQueryCache()?(n=this.startWithCache(),n instanceof Promise?this.shouldWaitForCache()?(n.then(o=>{if(r(o),queryFullyFilled(this)){this.emit("eose",this);return}s()}),null):(n.then(o=>{r(o)}),s(),null):(r(n),queryFullyFilled(this)?this.emit("eose",this):s(),n)):(s(),null)}startPoolMonitor(){this.debug.extend("pool-monitor"),this.poolMonitor=e=>{var r,s;if((r=this.relayFilters)!=null&&r.has(e.url))return;calculateRelaySetsFromFilters(this.ndk,this.filters,this.pool).get(e.url)&&((s=this.relayFilters)==null||s.set(e.url,this.filters),e.subscribe(this,this.filters))},this.pool.on("relay:connect",this.poolMonitor)}stop(){var e;this.emit("close",this),this.poolMonitor&&this.pool.off("relay:connect",this.poolMonitor),(e=this.onStopped)==null||e.call(this)}hasAuthorsFilter(){return this.filters.some(e=>{var n;return(n=e.authors)==null?void 0:n.length})}startWithCache(){var e;return(e=this.ndk.cacheAdapter)!=null&&e.query?this.ndk.cacheAdapter.query(this):[]}startWithRelays(){let e=this.filters;if(this.opts.addSinceFromCache&&this.mostRecentCacheEventTimestamp){const n=this.mostRecentCacheEventTimestamp+1;e=e.map(r=>({...r,since:Math.max(r.since||0,n)}))}if(!this.relaySet||this.relaySet.relays.size===0)this.relayFilters=calculateRelaySetsFromFilters(this.ndk,e,this.pool);else{this.relayFilters=new Map;for(const n of this.relaySet.relays)this.relayFilters.set(n.url,e)}for(const[n,r]of this.relayFilters)this.pool.getRelay(n,!0,!0,r).subscribe(this,r)}eventReceived(e,n,r=!1,s=!1){var l;const o=e.id,a=this.eventFirstSeen.has(o);let c;if(e instanceof NDKEvent&&(c=e),a){const u=Date.now()-(this.eventFirstSeen.get(o)||0);if(this.emit("event:dup",e,n,u,this,r,s),n){const h=verifiedSignatures.get(o);if(h&&typeof h=="string")if(e.sig===h)n.addValidatedEvent();else{const f=e instanceof NDKEvent?e:new NDKEvent(this.ndk,e);this.ndk.reportInvalidSignature(f,n)}}}else{if(c??(c=new NDKEvent(this.ndk,e)),c.ndk=this.ndk,c.relay=n,!r&&!s){if(!this.skipValidation&&!c.isValid){this.debug("Event failed validation %s from relay %s",o,n==null?void 0:n.url);return}if(n)if(n.shouldValidateEvent()&&!this.skipVerification){if(c.relay=n,!this.ndk.asyncSigVerification){if(!c.verifySignature(!0)){this.debug("Event failed signature validation",e),this.ndk.reportInvalidSignature(c,n);return}n.addValidatedEvent()}}else n.addNonValidatedEvent();this.ndk.cacheAdapter&&!this.opts.dontSaveToCache&&this.ndk.cacheAdapter.setEvent(c,this.filters,n)}(!s||this.skipOptimisticPublishEvent!==!0)&&(this.emitEvent(((l=this.opts)==null?void 0:l.wrap)??!1,c,n,r,s),this.eventFirstSeen.set(o,Date.now()))}this.lastEventReceivedAt=Date.now()}emitEvent(e,n,r,s,o){const a=e?wrapEvent(n):n;a instanceof Promise?a.then(c=>this.emitEvent(!1,c,r,s,o)):a&&this.emit("event",a,r,this,s,o)}closedReceived(e,n){this.emit("closed",e,n)}eoseReceived(e){var a;this.debug("EOSE received from %s",e.url),this.eosesSeen.add(e);let n=this.lastEventReceivedAt?Date.now()-this.lastEventReceivedAt:void 0;const r=this.eosesSeen.size===((a=this.relayFilters)==null?void 0:a.size),s=queryFullyFilled(this),o=c=>{var l;this.debug("Performing EOSE: %s %d",c,this.eosed),!this.eosed&&(this.eoseTimeout&&clearTimeout(this.eoseTimeout),this.emit("eose",this),this.eosed=!0,(l=this.opts)!=null&&l.closeOnEose&&this.stop())};if(s||r)o("query filled or seen all");else if(this.relayFilters){let c=1e3;const l=new Set(this.pool.connectedRelays().map(f=>f.url)),u=Array.from(this.relayFilters.keys()).filter(f=>l.has(f));if(u.length===0){this.debug("No connected relays, waiting for all relays to connect",Array.from(this.relayFilters.keys()).join(", "));return}const h=this.eosesSeen.size/u.length;if(this.debug("Percentage of relays that have sent EOSE",{subId:this.subId,percentageOfRelaysThatHaveSentEose:h,seen:this.eosesSeen.size,total:u.length}),this.eosesSeen.size>=2&&h>=.5){if(c=c*(1-h),c===0){o("time to wait was 0");return}this.eoseTimeout&&clearTimeout(this.eoseTimeout);const f=()=>{n=this.lastEventReceivedAt?Date.now()-this.lastEventReceivedAt:void 0,n!==void 0&&n<20?this.eoseTimeout=setTimeout(f,c):o(`send eose timeout: ${c}`)};this.eoseTimeout=setTimeout(f,c)}}}},kindIsEphemeral=t=>t>=2e4&&t<3e4;async function follows(t,e,n=3){var s,o;if(!this.ndk)throw new Error("NDK not set");const r=await this.ndk.fetchEvent({kinds:[n],authors:[this.pubkey]},t||{groupable:!1});if(r){const a=new Set;return r.tags.forEach(c=>{c[0]==="p"&&a.add(c[1])}),e&&((o=(s=this.ndk)==null?void 0:s.outboxTracker)==null||o.trackUsers(Array.from(a))),[...a].reduce((c,l)=>{const u=new NDKUser({pubkey:l});return u.ndk=this.ndk,c.add(u),c},new Set)}return new Set}var NIP05_REGEX=/^(?:([\w.+-]+)@)?([\w.-]+)$/;async function getNip05For(t,e,n=fetch,r={}){return await t.queuesNip05.add({id:e,func:async()=>{var l,u,h;if((l=t.cacheAdapter)!=null&&l.loadNip05){const f=await t.cacheAdapter.loadNip05(e);if(f!=="missing"){if(f){const p=new NDKUser({pubkey:f.pubkey,relayUrls:f.relays,nip46Urls:f.nip46});return p.ndk=t,p}if(r.cache!=="no-cache")return null}}const s=e.match(NIP05_REGEX);if(!s)return null;const[o,a="_",c]=s;try{const f=await n(`https://${c}/.well-known/nostr.json?name=${a}`,r),{names:p,relays:g,nip46:w}=parseNIP05Result(await f.json()),y=p[a.toLowerCase()];let b=null;return y&&(b={pubkey:y,relays:g==null?void 0:g[y],nip46:w==null?void 0:w[y]}),(u=t==null?void 0:t.cacheAdapter)!=null&&u.saveNip05&&t.cacheAdapter.saveNip05(e,b),b}catch(f){return(h=t==null?void 0:t.cacheAdapter)!=null&&h.saveNip05&&(t==null||t.cacheAdapter.saveNip05(e,null)),console.error("Failed to fetch NIP05 for",e,f),null}}})}function parseNIP05Result(t){const e={names:{}};for(const[n,r]of Object.entries(t.names))typeof n=="string"&&typeof r=="string"&&(e.names[n.toLowerCase()]=r);if(t.relays){e.relays={};for(const[n,r]of Object.entries(t.relays))typeof n=="string"&&Array.isArray(r)&&(e.relays[n]=r.filter(s=>typeof s=="string"))}if(t.nip46){e.nip46={};for(const[n,r]of Object.entries(t.nip46))typeof n=="string"&&Array.isArray(r)&&(e.nip46[n]=r.filter(s=>typeof s=="string"))}return e}function profileFromEvent(t){const e={};let n;try{n=JSON.parse(t.content)}catch(r){throw new Error(`Failed to parse profile event: ${r}`)}e.profileEvent=JSON.stringify(t.rawEvent());for(const r of Object.keys(n))switch(r){case"name":e.name=n.name;break;case"display_name":e.displayName=n.display_name;break;case"image":case"picture":e.picture=n.picture||n.image,e.image=e.picture;break;case"banner":e.banner=n.banner;break;case"bio":e.bio=n.bio;break;case"nip05":e.nip05=n.nip05;break;case"lud06":e.lud06=n.lud06;break;case"lud16":e.lud16=n.lud16;break;case"about":e.about=n.about;break;case"website":e.website=n.website;break;default:e[r]=n[r];break}return e.created_at=t.created_at,e}function serializeProfile(t){const e={};for(const[n,r]of Object.entries(t))switch(n){case"username":case"name":e.name=r;break;case"displayName":e.display_name=r;break;case"image":case"picture":e.picture=r;break;case"bio":case"about":e.about=r;break;default:e[n]=r;break}return JSON.stringify(e)}var NDKUser=class Oe{constructor(e){m(this,"ndk");m(this,"profile");m(this,"profileEvent");m(this,"_npub");m(this,"_pubkey");m(this,"relayUrls",[]);m(this,"nip46Urls",[]);m(this,"follows",follows.bind(this));if(e.npub&&(this._npub=e.npub),e.hexpubkey&&(this._pubkey=e.hexpubkey),e.pubkey&&(this._pubkey=e.pubkey),e.relayUrls&&(this.relayUrls=e.relayUrls),e.nip46Urls&&(this.nip46Urls=e.nip46Urls),e.nprofile)try{const n=nip19_exports.decode(e.nprofile);n.type==="nprofile"&&(this._pubkey=n.data.pubkey,n.data.relays&&n.data.relays.length>0&&this.relayUrls.push(...n.data.relays))}catch(n){console.error("Failed to decode nprofile",n)}}get npub(){if(!this._npub){if(!this._pubkey)throw new Error("pubkey not set");this._npub=nip19_exports.npubEncode(this.pubkey)}return this._npub}get nprofile(){var n,r;const e=(r=(n=this.profileEvent)==null?void 0:n.onRelays)==null?void 0:r.map(s=>s.url);return nip19_exports.nprofileEncode({pubkey:this.pubkey,relays:e})}set npub(e){this._npub=e}get pubkey(){if(!this._pubkey){if(!this._npub)throw new Error("npub not set");this._pubkey=nip19_exports.decode(this.npub).data}return this._pubkey}set pubkey(e){this._pubkey=e}filter(){return{"#p":[this.pubkey]}}async getZapInfo(e){if(!this.ndk)throw new Error("No NDK instance found");const n=async a=>{if(!e)return a;let c;const l=new Promise((u,h)=>{c=setTimeout(()=>h(new Error("Timeout")),e)});try{const u=await Promise.race([a,l]);return c&&clearTimeout(c),u}catch(u){if(u instanceof Error&&u.message==="Timeout")try{return await a}catch{return}return}},[r,s]=await Promise.all([n(this.fetchProfile()),n(this.ndk.fetchEvent({kinds:[10019],authors:[this.pubkey]}))]),o=new Map;if(s){const a=NDKCashuMintList.from(s);a.mints.length>0&&o.set("nip61",{mints:a.mints,relays:a.relays,p2pk:a.p2pk})}if(r){const{lud06:a,lud16:c}=r;o.set("nip57",{lud06:a,lud16:c})}return o}static async fromNip05(e,n,r=!1){if(!n)throw new Error("No NDK instance found");const s={};r&&(s.cache="no-cache");const o=await getNip05For(n,e,n==null?void 0:n.httpFetch,s);if(o){const a=new Oe({pubkey:o.pubkey,relayUrls:o.relays,nip46Urls:o.nip46});return a.ndk=n,a}}async fetchProfile(e,n=!1){if(!this.ndk)throw new Error("NDK not set");let r=null;if(this.ndk.cacheAdapter&&(this.ndk.cacheAdapter.fetchProfile||this.ndk.cacheAdapter.fetchProfileSync)&&(e==null?void 0:e.cacheUsage)!=="ONLY_RELAY"){let s=null;if(this.ndk.cacheAdapter.fetchProfileSync?s=this.ndk.cacheAdapter.fetchProfileSync(this.pubkey):this.ndk.cacheAdapter.fetchProfile&&(s=await this.ndk.cacheAdapter.fetchProfile(this.pubkey)),s)return this.profile=s,s}return e??(e={}),e.cacheUsage??(e.cacheUsage="ONLY_RELAY"),e.closeOnEose??(e.closeOnEose=!0),e.groupable??(e.groupable=!0),e.groupableDelay??(e.groupableDelay=250),r||(r=await this.ndk.fetchEvent({kinds:[0],authors:[this.pubkey]},e)),r?(this.profile=profileFromEvent(r),n&&this.profile&&this.ndk.cacheAdapter&&this.ndk.cacheAdapter.saveProfile&&this.ndk.cacheAdapter.saveProfile(this.pubkey,this.profile),this.profile):null}async followSet(e,n,r=3){const s=await this.follows(e,n,r);return new Set(Array.from(s).map(o=>o.pubkey))}tagReference(){return["p",this.pubkey]}referenceTags(e){const n=[["p",this.pubkey]];return e&&n[0].push("",e),n}async publish(){if(!this.ndk)throw new Error("No NDK instance found");if(!this.profile)throw new Error("No profile available");this.ndk.assertSigner(),await new NDKEvent(this.ndk,{kind:0,content:serializeProfile(this.profile)}).publish()}async follow(e,n,r=3){if(!this.ndk)throw new Error("No NDK instance found");if(this.ndk.assertSigner(),n||(n=await this.follows(void 0,void 0,r)),n.has(e))return!1;n.add(e);const s=new NDKEvent(this.ndk,{kind:r});for(const o of n)s.tag(o);return await s.publish(),!0}async unfollow(e,n,r=3){if(!this.ndk)throw new Error("No NDK instance found");this.ndk.assertSigner(),n||(n=await this.follows(void 0,void 0,r));const s=new Set;let o=!1;for(const c of n)c.pubkey!==e.pubkey?s.add(c):o=!0;if(!o)return!1;const a=new NDKEvent(this.ndk,{kind:r});for(const c of s)a.tag(c);return await a.publish()}async validateNip05(e){if(!this.ndk)throw new Error("No NDK instance found");const n=await getNip05For(this.ndk,e);return n===null?null:n.pubkey===this.pubkey}},READ_MARKER="read",WRITE_MARKER="write",NDKRelayList=class Ke extends NDKEvent{constructor(e,n){super(e,n),this.kind??(this.kind=10002)}static from(e){return new Ke(e.ndk,e.rawEvent())}get readRelayUrls(){return this.tags.filter(e=>e[0]==="r"||e[0]==="relay").filter(e=>!e[2]||e[2]&&e[2]===READ_MARKER).map(e=>tryNormalizeRelayUrl(e[1])).filter(e=>!!e)}set readRelayUrls(e){for(const n of e)this.tags.push(["r",n,READ_MARKER])}get writeRelayUrls(){return this.tags.filter(e=>e[0]==="r"||e[0]==="relay").filter(e=>!e[2]||e[2]&&e[2]===WRITE_MARKER).map(e=>tryNormalizeRelayUrl(e[1])).filter(e=>!!e)}set writeRelayUrls(e){for(const n of e)this.tags.push(["r",n,WRITE_MARKER])}get bothRelayUrls(){return this.tags.filter(e=>e[0]==="r"||e[0]==="relay").filter(e=>!e[2]).map(e=>e[1])}set bothRelayUrls(e){for(const n of e)this.tags.push(["r",n])}get relays(){return this.tags.filter(e=>e[0]==="r"||e[0]==="relay").map(e=>e[1])}get relaySet(){if(!this.ndk)throw new Error("NDKRelayList has no NDK instance");return new NDKRelaySet(new Set(this.relays.map(e=>{var n;return(n=this.ndk)==null?void 0:n.pool.getRelay(e)}).filter(e=>!!e)),this.ndk)}};function relayListFromKind3(t,e){try{const n=JSON.parse(e.content),r=new NDKRelayList(t),s=new Set,o=new Set;for(let[a,c]of Object.entries(n)){try{a=normalizeRelayUrl(a)}catch{continue}if(!c)s.add(a),o.add(a);else{const l=c;l.write&&o.add(a),l.read&&s.add(a)}}return r.readRelayUrls=Array.from(s),r.writeRelayUrls=Array.from(o),r}catch{}}function disconnect(t,e){return e??(e=createDebug5("ndk:relay:auth-policies:disconnect")),async n=>{e==null||e(`Relay ${n.url} requested authentication, disconnecting`),t.removeRelay(n.url)}}async function signAndAuth(t,e,n,r,s,o){try{await t.sign(n),s(t)}catch(a){r==null||r(`Failed to publish auth event to relay ${e.url}`,a),o(t)}}function signIn({ndk:t,signer:e,debug:n}={}){return n??(n=createDebug5("ndk:auth-policies:signIn")),async(r,s)=>{n==null||n(`Relay ${r.url} requested authentication, signing in`);const o=new NDKEvent(t);return o.kind=22242,o.tags=[["relay",r.url],["challenge",s]],e??(e=t==null?void 0:t.signer),new Promise(async(a,c)=>{e?await signAndAuth(o,r,e,n,a,c):t==null||t.once("signer:ready",async l=>{await signAndAuth(o,r,l,n,a,c)})})}}var NDKRelayAuthPolicies={disconnect,signIn},NDKNip07Signer=class Fe{constructor(e=1e3,n){m(this,"_userPromise");m(this,"encryptionQueue",[]);m(this,"encryptionProcessing",!1);m(this,"debug");m(this,"waitTimeout");m(this,"_pubkey");m(this,"ndk");m(this,"_user");this.debug=createDebug5("ndk:nip07"),this.waitTimeout=e,this.ndk=n}get pubkey(){if(!this._pubkey)throw new Error("Not ready");return this._pubkey}async blockUntilReady(){var r;await this.waitForExtension();const e=await((r=window.nostr)==null?void 0:r.getPublicKey());if(!e)throw new Error("User rejected access");this._pubkey=e;let n;return this.ndk?n=this.ndk.getUser({pubkey:e}):n=new NDKUser({pubkey:e}),this._user=n,n}async user(){return this._userPromise||(this._userPromise=this.blockUntilReady()),this._userPromise}get userSync(){if(!this._user)throw new Error("User not ready");return this._user}async sign(e){var r;await this.waitForExtension();const n=await((r=window.nostr)==null?void 0:r.signEvent(e));if(!n)throw new Error("Failed to sign event");return n.sig}async relays(e){var s,o;await this.waitForExtension();const n=await((o=(s=window.nostr)==null?void 0:s.getRelays)==null?void 0:o.call(s))||{},r=[];for(const a of Object.keys(n))n[a].read&&n[a].write&&r.push(a);return r.map(a=>new NDKRelay(a,e==null?void 0:e.relayAuthDefaultPolicy,e))}async encryptionEnabled(e){var r,s;const n=[];return(!e||e==="nip04")&&((r=window.nostr)!=null&&r.nip04)&&n.push("nip04"),(!e||e==="nip44")&&((s=window.nostr)!=null&&s.nip44)&&n.push("nip44"),n}async encrypt(e,n,r="nip04"){if(!await this.encryptionEnabled(r))throw new Error(`${r}encryption is not available from your browser extension`);await this.waitForExtension();const s=e.pubkey;return this.queueEncryption(r,"encrypt",s,n)}async decrypt(e,n,r="nip04"){if(!await this.encryptionEnabled(r))throw new Error(`${r}encryption is not available from your browser extension`);await this.waitForExtension();const s=e.pubkey;return this.queueEncryption(r,"decrypt",s,n)}async queueEncryption(e,n,r,s){return new Promise((o,a)=>{this.encryptionQueue.push({scheme:e,method:n,counterpartyHexpubkey:r,value:s,resolve:o,reject:a}),this.encryptionProcessing||this.processEncryptionQueue()})}async processEncryptionQueue(e,n=0){var h,f;if(!e&&this.encryptionQueue.length===0){this.encryptionProcessing=!1;return}this.encryptionProcessing=!0;const r=e||this.encryptionQueue.shift();if(!r){this.encryptionProcessing=!1;return}const{scheme:s,method:o,counterpartyHexpubkey:a,value:c,resolve:l,reject:u}=r;this.debug("Processing encryption queue item",{method:o,counterpartyHexpubkey:a,value:c});try{const p=await((f=(h=window.nostr)==null?void 0:h[s])==null?void 0:f[o](a,c));if(!p)throw new Error("Failed to encrypt/decrypt");l(p)}catch(p){const g=p instanceof Error?p.message:String(p);if(g.includes("call already executing")&&n<5){this.debug("Retrying encryption queue item",{method:o,counterpartyHexpubkey:a,value:c,retries:n}),setTimeout(()=>{this.processEncryptionQueue(r,n+1)},50*n);return}u(p instanceof Error?p:new Error(g))}this.processEncryptionQueue()}waitForExtension(){return new Promise((e,n)=>{if(window.nostr){e();return}let r;const s=setInterval(()=>{window.nostr&&(clearTimeout(r),clearInterval(s),e())},100);r=setTimeout(()=>{clearInterval(s),n(new Error("NIP-07 extension not available"))},this.waitTimeout)})}toPayload(){return JSON.stringify({type:"nip07",payload:""})}static async fromPayload(e,n){const r=JSON.parse(e);if(r.type!=="nip07")throw new Error(`Invalid payload type: expected 'nip07', got ${r.type}`);return new Fe(void 0,n)}};registerSigner("nip07",NDKNip07Signer);var NDKNostrRpc=class extends lib$1.EventEmitter{constructor(e,n,r,s){super();m(this,"ndk");m(this,"signer");m(this,"relaySet");m(this,"debug");m(this,"encryptionType","nip04");m(this,"pool");if(this.ndk=e,this.signer=n,s){this.pool=new NDKPool(s,[],e,{debug:r.extend("rpc-pool"),name:"Nostr RPC"}),this.relaySet=new NDKRelaySet(new Set,e,this.pool);for(const o of s){const a=this.pool.getRelay(o,!1,!1);a.authPolicy=NDKRelayAuthPolicies.signIn({ndk:e,signer:n,debug:r}),this.relaySet.addRelay(a),a.connect()}}this.debug=r.extend("rpc")}subscribe(e){const n=this.ndk.subscribe(e,{closeOnEose:!1,groupable:!1,cacheUsage:"ONLY_RELAY",pool:this.pool,relaySet:this.relaySet},!1);return n.on("event",async r=>{try{const s=await this.parseEvent(r);s.method?this.emit("request",s):(this.emit(`response-${s.id}`,s),this.emit("response",s))}catch(s){this.debug("error parsing event",s,r.rawEvent())}}),new Promise(r=>{n.on("eose",()=>{this.debug("eosed"),r(n)}),n.start()})}async parseEvent(e){this.encryptionType==="nip44"&&e.content.includes("?iv=")?this.encryptionType="nip04":this.encryptionType==="nip04"&&!e.content.includes("?iv=")&&(this.encryptionType="nip44");const n=this.ndk.getUser({pubkey:e.pubkey});n.ndk=this.ndk;let r;try{r=await this.signer.decrypt(n,e.content,this.encryptionType)}catch{const f=this.encryptionType==="nip04"?"nip44":"nip04";r=await this.signer.decrypt(n,e.content,f),this.encryptionType=f}const s=JSON.parse(r),{id:o,method:a,params:c,result:l,error:u}=s;return a?{id:o,pubkey:e.pubkey,method:a,params:c,event:e}:{id:o,result:l,error:u,event:e}}async sendResponse(e,n,r,s=24133,o){const a={id:e,result:r};o&&(a.error=o);const c=await this.signer.user(),l=this.ndk.getUser({pubkey:n}),u=new NDKEvent(this.ndk,{kind:s,content:JSON.stringify(a),tags:[["p",n]],pubkey:c.pubkey});u.content=await this.signer.encrypt(l,u.content,this.encryptionType),await u.sign(this.signer),await u.publish(this.relaySet)}async sendRequest(e,n,r=[],s=24133,o){const a=Math.random().toString(36).substring(7),c=await this.signer.user(),l=this.ndk.getUser({pubkey:e}),u={id:a,method:n,params:r},h=new Promise(()=>{const p=g=>{g.result==="auth_url"?(this.once(`response-${a}`,p),this.emit("authUrl",g.error)):o&&o(g)};this.once(`response-${a}`,p)}),f=new NDKEvent(this.ndk,{kind:s,content:JSON.stringify(u),tags:[["p",e]],pubkey:c.pubkey});return f.content=await this.signer.encrypt(l,f.content,this.encryptionType),await f.sign(this.signer),await f.publish(this.relaySet),h}};async function ndkSignerFromPayload(t,e){let n;try{n=JSON.parse(t)}catch(s){console.error("Failed to parse signer payload string",t,s);return}if(!n||typeof n.type!="string"){console.error("Failed to parse signer payload string",t,new Error("Missing type field"));return}const r=signerRegistry.get(n.type);if(!r)throw new Error(`Unknown signer type: ${n.type}`);try{return await r.fromPayload(t,e)}catch(s){const o=s instanceof Error?s.message:String(s);throw new Error(`Failed to deserialize signer type ${n.type}: ${o}`)}}function nostrConnectGenerateSecret(){return Math.random().toString(36).substring(2,15)}function generateNostrConnectUri(t,e,n,r){const s={name:r!=null&&r.name?encodeURIComponent(r.name):"",url:r!=null&&r.url?encodeURIComponent(r.url):"",image:r!=null&&r.image?encodeURIComponent(r.image):"",perms:r!=null&&r.perms?encodeURIComponent(r.perms):""};let o=`nostrconnect://${t}?image=${s.image}&url=${s.url}&name=${s.name}&perms=${s.perms}&secret=${encodeURIComponent(e)}`;return n&&(o+=`&relay=${encodeURIComponent(n)}`),o}var NDKNip46Signer=class Le extends lib$1.EventEmitter{constructor(n,r,s,o,a){super();m(this,"ndk");m(this,"_user");m(this,"bunkerPubkey");m(this,"userPubkey");m(this,"secret");m(this,"localSigner");m(this,"nip05");m(this,"rpc");m(this,"debug");m(this,"relayUrls");m(this,"subscription");m(this,"nostrConnectUri");m(this,"nostrConnectSecret");this.ndk=n,this.debug=n.debug.extend("nip46:signer"),this.relayUrls=o,s?typeof s=="string"?this.localSigner=new NDKPrivateKeySigner(s):this.localSigner=s:this.localSigner=NDKPrivateKeySigner.generate(),r===!1||(r?r.startsWith("bunker://")?this.bunkerFlowInit(r):this.nip05Init(r):this.nostrconnectFlowInit(a)),this.rpc=new NDKNostrRpc(this.ndk,this.localSigner,this.debug,this.relayUrls)}get pubkey(){if(!this.userPubkey)throw new Error("Not ready");return this.userPubkey}static bunker(n,r,s){return new Le(n,r,s)}static nostrconnect(n,r,s,o){return new Le(n,void 0,s,[r],o)}nostrconnectFlowInit(n){var s;this.nostrConnectSecret=nostrConnectGenerateSecret();const r=this.localSigner.pubkey;this.nostrConnectUri=generateNostrConnectUri(r,this.nostrConnectSecret,(s=this.relayUrls)==null?void 0:s[0],n)}bunkerFlowInit(n){const r=new URL(n),s=r.hostname||r.pathname.replace(/^\/\//,""),o=r.searchParams.get("pubkey"),a=r.searchParams.getAll("relay"),c=r.searchParams.get("secret");this.bunkerPubkey=s,this.userPubkey=o,this.relayUrls=a,this.secret=c}nip05Init(n){this.nip05=n}async startListening(){if(this.subscription)return;const n=await this.localSigner.user();if(!n)throw new Error("Local signer not ready");this.subscription=await this.rpc.subscribe({kinds:[24133],"#p":[n.pubkey]})}async user(){return this._user?this._user:this.blockUntilReady()}get userSync(){if(!this._user)throw new Error("Remote user not ready synchronously");return this._user}async blockUntilReadyNostrConnect(){return new Promise((n,r)=>{const s=o=>{o.result===this.nostrConnectSecret&&(this._user=o.event.author,this.userPubkey=o.event.pubkey,this.bunkerPubkey=o.event.pubkey,this.rpc.off("response",s),n(this._user))};this.startListening(),this.rpc.on("response",s)})}async blockUntilReady(){if(!this.bunkerPubkey&&!this.nostrConnectSecret&&!this.nip05)throw new Error("Bunker pubkey not set");if(this.nostrConnectSecret)return this.blockUntilReadyNostrConnect();if(this.nip05&&!this.userPubkey){const n=await NDKUser.fromNip05(this.nip05,this.ndk);n&&(this._user=n,this.userPubkey=n.pubkey,this.relayUrls=n.nip46Urls,this.rpc=new NDKNostrRpc(this.ndk,this.localSigner,this.debug,this.relayUrls))}if(!this.bunkerPubkey&&this.userPubkey)this.bunkerPubkey=this.userPubkey;else if(!this.bunkerPubkey)throw new Error("Bunker pubkey not set");return await this.startListening(),this.rpc.on("authUrl",(...n)=>{this.emit("authUrl",...n)}),new Promise((n,r)=>{const s=[this.userPubkey??""];if(this.secret&&s.push(this.secret),!this.bunkerPubkey)throw new Error("Bunker pubkey not set");this.rpc.sendRequest(this.bunkerPubkey,"connect",s,24133,o=>{o.result==="ack"?this.getPublicKey().then(a=>{this.userPubkey=a,this._user=this.ndk.getUser({pubkey:a}),n(this._user)}):r(o.error)})})}stop(){var n;(n=this.subscription)==null||n.stop(),this.subscription=void 0}async getPublicKey(){return this.userPubkey?this.userPubkey:new Promise((n,r)=>{if(!this.bunkerPubkey)throw new Error("Bunker pubkey not set");this.rpc.sendRequest(this.bunkerPubkey,"get_public_key",[],24133,s=>{n(s.result)})})}async encryptionEnabled(n){return n?[n]:Promise.resolve(["nip04","nip44"])}async encrypt(n,r,s="nip04"){return this.encryption(n,r,s,"encrypt")}async decrypt(n,r,s="nip04"){return this.encryption(n,r,s,"decrypt")}async encryption(n,r,s,o){return new Promise((c,l)=>{if(!this.bunkerPubkey)throw new Error("Bunker pubkey not set");this.rpc.sendRequest(this.bunkerPubkey,`${s}_${o}`,[n.pubkey,r],24133,u=>{u.error?l(u.error):c(u.result)})})}async sign(n){return new Promise((s,o)=>{if(!this.bunkerPubkey)throw new Error("Bunker pubkey not set");this.rpc.sendRequest(this.bunkerPubkey,"sign_event",[JSON.stringify(n)],24133,a=>{if(a.error)o(a.error);else{const c=JSON.parse(a.result);s(c.sig)}})})}async createAccount(n,r,s){await this.startListening();const o=[];return n&&o.push(n),r&&o.push(r),s&&o.push(s),new Promise((a,c)=>{if(!this.bunkerPubkey)throw new Error("Bunker pubkey not set");this.rpc.sendRequest(this.bunkerPubkey,"create_account",o,24133,l=>{if(l.error)c(l.error);else{const u=l.result;a(u)}})})}toPayload(){if(!this.bunkerPubkey||!this.userPubkey)throw new Error("NIP-46 signer is not fully initialized for serialization");const n={type:"nip46",payload:{bunkerPubkey:this.bunkerPubkey,userPubkey:this.userPubkey,relayUrls:this.relayUrls,secret:this.secret,localSignerPayload:this.localSigner.toPayload(),nip05:this.nip05||null}};return JSON.stringify(n)}static async fromPayload(n,r){if(!r)throw new Error("NDK instance is required to deserialize NIP-46 signer");const s=JSON.parse(n);if(s.type!=="nip46")throw new Error(`Invalid payload type: expected 'nip46', got ${s.type}`);const o=s.payload;if(!o||typeof o!="object"||!o.localSignerPayload)throw new Error("Invalid payload content for nip46 signer");const a=await ndkSignerFromPayload(o.localSignerPayload,r);if(!a)throw new Error("Failed to deserialize local signer for NIP-46");if(!(a instanceof NDKPrivateKeySigner))throw new Error("Local signer must be an instance of NDKPrivateKeySigner");let c;return c=new Le(r,!1,a,o.relayUrls),c.userPubkey=o.userPubkey,c.bunkerPubkey=o.bunkerPubkey,c.relayUrls=o.relayUrls,c.secret=o.secret,o.userPubkey&&(c._user=new NDKUser({pubkey:o.userPubkey}),c._user&&(c._user.ndk=r)),c}};registerSigner("nip46",NDKNip46Signer);function dedup(t,e){return t.created_at>e.created_at?t:e}async function getRelayListForUser(t,e){return(await getRelayListForUsers([t],e)).get(t)}async function getRelayListForUsers(t,e,n=!1,r=1e3){var f;const s=e.outboxPool||e.pool,o=new Set;for(const p of s.relays.values())o.add(p);const a=new Map,c=new Map,l=new NDKRelaySet(o,e);if((f=e.cacheAdapter)!=null&&f.locking&&!n){const p=await e.fetchEvents({kinds:[3,10002],authors:Array.from(new Set(t))},{cacheUsage:"ONLY_CACHE",subId:"ndk-relay-list-fetch"});for(const g of p)g.kind===10002&&a.set(g.pubkey,NDKRelayList.from(g));for(const g of p)if(g.kind===3){if(a.has(g.pubkey))continue;const w=relayListFromKind3(e,g);w&&c.set(g.pubkey,w)}t=t.filter(g=>!a.has(g)&&!c.has(g))}if(t.length===0)return a;const u=new Map,h=new Map;return new Promise(p=>{(async()=>{const w={closeOnEose:!0,pool:s,groupable:!0,subId:"ndk-relay-list-fetch",addSinceFromCache:!0,relaySet:l};l&&(w.relaySet=l),e.subscribe({kinds:[3,10002],authors:t},w,{onEvent:y=>{if(y.kind===10002){const b=u.get(y.pubkey);if(b&&b.created_at>y.created_at)return;u.set(y.pubkey,y)}else if(y.kind===3){const b=h.get(y.pubkey);if(b&&b.created_at>y.created_at)return;h.set(y.pubkey,y)}},onEose:()=>{for(const y of u.values())a.set(y.pubkey,NDKRelayList.from(y));for(const y of t){if(a.has(y))continue;const b=h.get(y);if(!b)continue;const x=relayListFromKind3(e,b);x&&a.set(y,x)}p(a)}}),setTimeout(()=>{p(a)},r)})()})}var OutboxItem=class{constructor(t){m(this,"type");m(this,"relayUrlScores");m(this,"readRelays");m(this,"writeRelays");this.type=t,this.relayUrlScores=new Map,this.readRelays=new Set,this.writeRelays=new Set}},OutboxTracker=class extends lib$1.EventEmitter{constructor(e){super();m(this,"data");m(this,"ndk");m(this,"debug");this.ndk=e,this.debug=e.debug.extend("outbox-tracker"),this.data=new dist.LRUCache({maxSize:1e5,entryExpirationTimeInMS:2*60*1e3})}async trackUsers(e,n=!1){const r=[];for(let s=0;s<e.length;s+=400){const a=e.slice(s,s+400).map(c=>getKeyFromItem(c)).filter(c=>!this.data.has(c));if(a.length!==0){for(const c of a)this.data.set(c,new OutboxItem("user"));r.push(new Promise(c=>{getRelayListForUsers(a,this.ndk,n).then(l=>{for(const[u,h]of l){let f=this.data.get(u);if(f??(f=new OutboxItem("user")),h){f.readRelays=new Set(normalize(h.readRelayUrls)),f.writeRelays=new Set(normalize(h.writeRelayUrls));for(const p of f.readRelays)this.ndk.pool.blacklistRelayUrls.has(p)&&f.readRelays.delete(p);for(const p of f.writeRelays)this.ndk.pool.blacklistRelayUrls.has(p)&&f.writeRelays.delete(p);this.data.set(u,f)}}}).finally(c)}))}}return Promise.all(r)}track(e,n,r=!0){const s=getKeyFromItem(e);n??(n=getTypeFromItem(e));let o=this.data.get(s);return o||(o=new OutboxItem(n),e instanceof NDKUser&&this.trackUsers([e])),o}};function getKeyFromItem(t){return t instanceof NDKUser?t.pubkey:t}function getTypeFromItem(t){return t instanceof NDKUser?"user":"kind"}function correctRelaySet(t,e){const n=e.connectedRelays();if(!Array.from(t.relays).some(s=>n.map(o=>o.url).includes(s.url)))for(const s of n)t.addRelay(s);if(n.length===0)for(const s of e.relays.values())t.addRelay(s);return t}var NDKSubscriptionManager=class{constructor(){m(this,"subscriptions");m(this,"seenEvents",new Map);this.subscriptions=new Map}add(t){this.subscriptions.set(t.internalId,t),t.onStopped,t.onStopped=()=>{this.subscriptions.delete(t.internalId)},t.on("close",()=>{this.subscriptions.delete(t.internalId)})}seenEvent(t,e){const n=this.seenEvents.get(t)||[];n.push(e),this.seenEvents.set(t,n)}dispatchEvent(t,e,n=!1){e&&this.seenEvent(t.id,e);const r=this.subscriptions.values(),s=[];for(const o of r)matchFilters(o.filters,t)&&s.push(o);for(const o of s)o.eventReceived(t,e,!1,n)}},debug7=createDebug5("ndk:active-user");async function getUserRelayList(t){if(!this.autoConnectUserRelays)return;const e=await getRelayListForUser(t.pubkey,this);if(e){for(const n of e.relays){let r=this.pool.relays.get(n);r||(r=new NDKRelay(n,this.relayAuthDefaultPolicy,this),this.pool.addRelay(r))}return e}}async function setActiveUser(t){const e=this.outboxPool||this.pool;e.connectedRelays.length>0?setActiveUserConnected.call(this,t):e.once("connect",()=>{setActiveUserConnected.call(this,t)})}async function setActiveUserConnected(t){var o;const e=await getUserRelayList.call(this,t),n=[{kinds:[10006],authors:[t.pubkey]}];this.autoFetchUserMutelist&&((o=n[0].kinds)==null||o.push(1e4));const r=new Map,s=e?e.relaySet:void 0;this.subscribe(n,{subId:"active-user-settings",closeOnEose:!0,relaySet:s},{onEvent:a=>{const c=r.get(a.kind);c&&c.created_at>=a.created_at||r.set(a.kind,a)},onEose:()=>{for(const a of r.values())processEvent.call(this,a)}})}async function processEvent(t){t.kind===10006?processBlockRelayList.call(this,t):t.kind===1e4&&processMuteList.call(this,t)}function processBlockRelayList(t){const e=lists_default.from(t);for(const n of e.items)this.pool.blacklistRelayUrls.add(n[0]);debug7("Added %d relays to relay blacklist",e.items.length)}function processMuteList(t){const e=lists_default.from(t);for(const n of e.items)this.mutedIds.set(n[1],n[0]);debug7("Added %d users to mute list",e.items.length)}function getEntity(t){try{const e=nip19_exports.decode(t);return e.type==="npub"?npub(this,e.data):e.type==="nprofile"?nprofile(this,e.data):e}catch{return null}}function npub(t,e){return t.getUser({pubkey:e})}function nprofile(t,e){const n=t.getUser({pubkey:e.pubkey});return e.relays&&(n.relayUrls=e.relays),n}function isValidHint(t){if(!t||t==="")return!1;try{return new URL(t),!0}catch{return!1}}async function fetchEventFromTag(t,e,n,r={type:"timeout"}){const s=this.debug.extend("fetch-event-from-tag"),[o,a,c]=t;n={},s("fetching event from tag",t,n,r);const l=getRelaysForSync(this,e.pubkey);if(l&&l.size>0){s("fetching event from author relays %o",Array.from(l));const y=NDKRelaySet.fromRelayUrls(Array.from(l),this),b=await this.fetchEvent(a,n,y);if(b)return b}else s("no author relays found for %s",e.pubkey,e);const u=calculateRelaySetsFromFilters(this,[{ids:[a]}],this.pool);s("fetching event without relay hint",u);const h=await this.fetchEvent(a,n);if(h)return h;if(c&&c!==""){const y=await this.fetchEvent(a,n,this.pool.getRelay(c,!0,!0,[{ids:[a]}]));if(y)return y}let f;const p=isValidHint(c)?this.pool.getRelay(c,!1,!0,[{ids:[a]}]):void 0,g=new Promise(y=>{this.fetchEvent(a,n,p).then(y)});if(!isValidHint(c)||r.type==="none")return g;const w=new Promise(async y=>{const b=r.relaySet,x=r.timeout??1500,_=new Promise(R=>setTimeout(R,x));if(r.type==="timeout"&&await _,f)y(f);else{s("fallback fetch triggered");const R=await this.fetchEvent(a,n,b);y(R)}});switch(r.type){case"timeout":return Promise.race([g,w]);case"eose":return f=await g,f||w}}var Queue=class{constructor(t,e){m(this,"queue",[]);m(this,"maxConcurrency");m(this,"processing",new Set);m(this,"promises",new Map);this.maxConcurrency=e}add(t){if(this.promises.has(t.id))return this.promises.get(t.id);const e=new Promise((n,r)=>{this.queue.push({...t,func:()=>t.func().then(s=>(n(s),s),s=>{throw r(s),s})}),this.process()});return this.promises.set(t.id,e),e.finally(()=>{this.promises.delete(t.id),this.processing.delete(t.id),this.process()}),e}process(){if(this.processing.size>=this.maxConcurrency||this.queue.length===0)return;const t=this.queue.shift();!t||this.processing.has(t.id)||(this.processing.add(t.id),t.func())}clear(){this.queue=[]}clearProcessing(){this.processing.clear()}clearAll(){this.clear(),this.clearProcessing()}length(){return this.queue.length}},DEFAULT_OUTBOX_RELAYS=["wss://purplepag.es/","wss://nos.lol/"],DEFAULT_BLACKLISTED_RELAYS=["wss://brb.io/","wss://nostr.mutinywallet.com/"],NDK=class extends lib$1.EventEmitter{constructor(e={}){super();m(this,"_explicitRelayUrls");m(this,"blacklistRelayUrls");m(this,"pool");m(this,"outboxPool");m(this,"_signer");m(this,"_activeUser");m(this,"cacheAdapter");m(this,"debug");m(this,"devWriteRelaySet");m(this,"outboxTracker");m(this,"mutedIds");m(this,"clientName");m(this,"clientNip89");m(this,"queuesZapConfig");m(this,"queuesNip05");m(this,"asyncSigVerification",!1);m(this,"initialValidationRatio",1);m(this,"lowestValidationRatio",.1);m(this,"validationRatioFn");m(this,"autoBlacklistInvalidRelays",!1);m(this,"subManager");m(this,"_signatureVerificationFunction");m(this,"_signatureVerificationWorker");m(this,"signatureVerificationTimeMs",0);m(this,"publishingFailureHandled",!1);m(this,"pools",[]);m(this,"relayAuthDefaultPolicy");m(this,"httpFetch");m(this,"netDebug");m(this,"autoConnectUserRelays",!0);m(this,"autoFetchUserMutelist",!0);m(this,"walletConfig");m(this,"fetchEventFromTag",fetchEventFromTag.bind(this));m(this,"getEntity",getEntity.bind(this));this.debug=e.debug||createDebug5("ndk"),this.netDebug=e.netDebug,this._explicitRelayUrls=e.explicitRelayUrls||[],this.blacklistRelayUrls=e.blacklistRelayUrls||DEFAULT_BLACKLISTED_RELAYS,this.subManager=new NDKSubscriptionManager,this.pool=new NDKPool(e.explicitRelayUrls||[],[],this),this.pool.name="Main",this.pool.on("relay:auth",async(n,r)=>{this.relayAuthDefaultPolicy&&await this.relayAuthDefaultPolicy(n,r)}),this.autoConnectUserRelays=e.autoConnectUserRelays??!0,this.autoFetchUserMutelist=e.autoFetchUserMutelist??!0,this.clientName=e.clientName,this.clientNip89=e.clientNip89,this.relayAuthDefaultPolicy=e.relayAuthDefaultPolicy,e.enableOutboxModel&&(this.outboxPool=new NDKPool(e.outboxRelayUrls||DEFAULT_OUTBOX_RELAYS,[],this,{debug:this.debug.extend("outbox-pool"),name:"Outbox Pool"}),this.outboxTracker=new OutboxTracker(this)),this.signer=e.signer,this.cacheAdapter=e.cacheAdapter,this.mutedIds=e.mutedIds||new Map,e.devWriteRelayUrls&&(this.devWriteRelaySet=NDKRelaySet.fromRelayUrls(e.devWriteRelayUrls,this)),this.queuesZapConfig=new Queue("zaps",3),this.queuesNip05=new Queue("nip05",10),e.signatureVerificationWorker&&(this.signatureVerificationWorker=e.signatureVerificationWorker),e.signatureVerificationFunction&&(this.signatureVerificationFunction=e.signatureVerificationFunction),this.initialValidationRatio=e.initialValidationRatio||1,this.lowestValidationRatio=e.lowestValidationRatio||.1,this.autoBlacklistInvalidRelays=e.autoBlacklistInvalidRelays||!1,this.validationRatioFn=e.validationRatioFn||this.defaultValidationRatioFn;try{this.httpFetch=fetch}catch{}}set explicitRelayUrls(e){this._explicitRelayUrls=e.map(normalizeRelayUrl),this.pool.relayUrls=e}get explicitRelayUrls(){return this._explicitRelayUrls||[]}set signatureVerificationWorker(e){this._signatureVerificationWorker=e,e?(signatureVerificationInit(e),this.asyncSigVerification=!0):this.asyncSigVerification=!1}set signatureVerificationFunction(e){this._signatureVerificationFunction=e,this.asyncSigVerification=!!e}get signatureVerificationFunction(){return this._signatureVerificationFunction}addExplicitRelay(e,n,r=!0){var o;let s;return typeof e=="string"?s=new NDKRelay(e,n,this):s=e,this.pool.addRelay(s,r),(o=this.explicitRelayUrls)==null||o.push(s.url),s}toJSON(){return{relayCount:this.pool.relays.size}.toString()}get activeUser(){return this._activeUser}set activeUser(e){var r;const n=((r=this._activeUser)==null?void 0:r.pubkey)!==(e==null?void 0:e.pubkey);this._activeUser=e,e&&n?setActiveUser.call(this,e):e||(this.mutedIds=new Map)}get signer(){return this._signer}set signer(e){this._signer=e,e&&this.emit("signer:ready",e),e==null||e.user().then(n=>{n.ndk=this,this.activeUser=n})}async connect(e){var r,s;this._signer&&this.autoConnectUserRelays&&(this.debug("Attempting to connect to user relays specified by signer %o",await((s=(r=this._signer).relays)==null?void 0:s.call(r,this))),this._signer.relays&&(await this._signer.relays(this)).forEach(a=>this.pool.addRelay(a)));const n=[this.pool.connect(e)];return this.outboxPool&&n.push(this.outboxPool.connect(e)),Promise.allSettled(n).then(()=>{})}reportInvalidSignature(e,n){this.debug(`Invalid signature detected for event ${e.id}${n?` from relay ${n.url}`:""}`),this.emit("event:invalid-sig",e,n),this.autoBlacklistInvalidRelays&&n&&this.blacklistRelay(n.url)}blacklistRelay(e){if(this.blacklistRelayUrls||(this.blacklistRelayUrls=[]),!this.blacklistRelayUrls.includes(e)){this.blacklistRelayUrls.push(e),this.debug(`Added relay to blacklist: ${e}`);const n=this.pool.getRelay(e,!1,!1);n&&(n.disconnect(),this.debug(`Disconnected from blacklisted relay: ${e}`))}}defaultValidationRatioFn(e,n,r){if(n<10)return this.initialValidationRatio;const s=Math.min(n/100,1),o=this.initialValidationRatio*(1-s)+this.lowestValidationRatio*s;return Math.max(o,this.lowestValidationRatio)}getUser(e){const n=new NDKUser(e);return n.ndk=this,n}async getUserFromNip05(e,n=!1){return NDKUser.fromNip05(e,this,n)}subscribe(e,n,r=!0,s=!0){var u;let o=n==null?void 0:n.relaySet,a=s;r instanceof NDKRelaySet?(console.warn("relaySet is deprecated, use opts.relaySet instead. This will be removed in version v2.14.0"),o=r,a=s):(typeof r=="boolean"||typeof r=="object")&&(a=r);const c=new NDKSubscription(this,e,{relaySet:o,...n});this.subManager.add(c);const l=c.pool;if(c.relaySet)for(const h of c.relaySet.relays)l.useTemporaryRelay(h,void 0,c.filters);if(this.outboxPool&&c.hasAuthorsFilter()){const h=c.filters.filter(f=>{var p;return f.authors&&((p=f.authors)==null?void 0:p.length)>0}).flatMap(f=>f.authors);(u=this.outboxTracker)==null||u.trackUsers(h)}if(a){let h;typeof a=="object"&&(a.onEvent&&c.on("event",a.onEvent),a.onEose&&c.on("eose",a.onEose),a.onEvents&&(h=a.onEvents)),setTimeout(()=>{const f=c.start(!h);f&&f.length>0&&h&&h(f)},0)}return c}fetchEventSync(e){if(!this.cacheAdapter)throw new Error("Cache adapter not set");let n;typeof e=="string"?n=[filterFromId(e)]:n=e;const r=new NDKSubscription(this,n),s=this.cacheAdapter.query(r);if(s instanceof Promise)throw new Error("Cache adapter is async");return s.map(o=>(o.ndk=this,o))}async fetchEvent(e,n,r){let s,o;if(r instanceof NDKRelay?o=new NDKRelaySet(new Set([r]),this):r instanceof NDKRelaySet&&(o=r),!r&&typeof e=="string"&&!isNip33AValue(e)){const a=relaysFromBech32(e,this);a.length>0&&(o=new NDKRelaySet(new Set(a),this),o=correctRelaySet(o,this.pool))}if(typeof e=="string"?s=[filterFromId(e)]:Array.isArray(e)?s=e:s=[e],s.length===0)throw new Error(`Invalid filter: ${JSON.stringify(e)}`);return new Promise(a=>{let c=null;const l={...n||{},closeOnEose:!0};o&&(l.relaySet=o);const u=this.subscribe(s,l,!1),h=setTimeout(()=>{u.stop(),a(c)},1e4);u.on("event",f=>{f.ndk=this,f.isReplaceable()?(!c||c.created_at<f.created_at)&&(c=f):(clearTimeout(h),a(f))}),u.on("eose",()=>{clearTimeout(h),a(c)}),u.start()})}async fetchEvents(e,n,r){return new Promise(s=>{const o=new Map,a={...n||{},closeOnEose:!0};r&&(a.relaySet=r);const c=this.subscribe(e,a,!1),l=u=>{let h;u instanceof NDKEvent?h=u:h=new NDKEvent(void 0,u);const f=h.deduplicationKey(),p=o.get(f);p&&(h=dedup(p,h)),h.ndk=this,o.set(f,h)};c.on("event",l),c.on("eose",()=>{s(new Set(o.values()))}),c.start()})}assertSigner(){if(!this.signer)throw this.emit("signer:required"),new Error("Signer required")}set wallet(e){var n,r;if(!e){this.walletConfig=void 0;return}this.walletConfig??(this.walletConfig={}),this.walletConfig.lnPay=(n=e==null?void 0:e.lnPay)==null?void 0:n.bind(e),this.walletConfig.cashuPay=(r=e==null?void 0:e.cashuPay)==null?void 0:r.bind(e)}};createDebug5("ndk:zapper:ln");createDebug5("ndk:zapper");const ARK_EVENT_KINDS={USER_PROFILE:3e4,CONTRACT:30001,PENDING_TX:30002,CONTRACT_UPDATE:1337,TX_ACK:1338},DEFAULT_RELAYS=["wss://nostr.arkade.sh"];class NostrCommunication{constructor(e,n){this.userCallbacks=[],this.contractCallbacks=[],this.pendingTxCallbacks=[],this.relayUrls=e||DEFAULT_RELAYS,this.privateKey=n,this.ndk=new NDK({explicitRelayUrls:this.relayUrls,outboxRelayUrls:this.relayUrls})}async initialize(){try{if(this.privateKey){const e=new NDKPrivateKeySigner(this.privateKey);this.ndk.signer=e,this.currentUser=await e.user()}await this.ndk.connect(),console.log(`Connected to ${this.ndk.pool.connectedRelays().length} Nostr relays`),this.currentUser?console.log("Nostr user authenticated with private key signer:",this.currentUser.pubkey):console.warn("No Nostr private key provided - Nostr functionality will be limited"),await this.setupSubscriptions(),console.log("Nostr communication provider initialized")}catch(e){throw console.error("Failed to initialize Nostr communication:",e),e}}cleanup(){var e,n,r;(e=this.userSubscription)==null||e.stop(),(n=this.contractSubscription)==null||n.stop(),(r=this.pendingTxSubscription)==null||r.stop(),this.userCallbacks=[],this.contractCallbacks=[],this.pendingTxCallbacks=[],console.log("Nostr communication provider cleaned up")}async publishUser(e){if(!this.currentUser)throw new Error("No authenticated Nostr user");try{const n=new NDKEvent(this.ndk,{kind:ARK_EVENT_KINDS.USER_PROFILE,content:JSON.stringify({name:e.name,pubkey:e.pubkey,address:e.address,timestamp:Date.now()}),tags:[["d",e.pubkey],["ark-user",e.pubkey],["ark-name",e.name]]});await n.sign(),await n.publish(),console.log("Published Ark user to Nostr:",e.name)}catch(n){throw console.error("Failed to publish user to Nostr:",n),n}}subscribeToUsers(e){this.userCallbacks.push(e)}async getUsers(){try{const e={kinds:[ARK_EVENT_KINDS.USER_PROFILE],"#ark-user":void 0},n=await this.ndk.fetchEvents(e),r=[];for(const s of n)try{const o=JSON.parse(s.content);r.push({pubkey:o.pubkey,name:o.name,address:o.address,timestamp:o.timestamp||Date.now()})}catch(o){console.warn("Failed to parse user event:",o)}return r}catch(e){return console.error("Failed to fetch users from Nostr:",e),[]}}async publishContract(e){if(!this.currentUser)throw new Error("No authenticated Nostr user");try{const n=new NDKEvent(this.ndk,{kind:ARK_EVENT_KINDS.CONTRACT,content:JSON.stringify({arkAddress:e.arkAddress,buyer:e.buyer,seller:e.seller,arbitrator:e.arbitrator,description:e.description,timestamp:e.timestamp,pendingTransaction:e.pendingTransaction}),tags:[["d",e.arkAddress],["ark-contract",e.arkAddress],["p",e.buyer.pubkey],["p",e.seller.pubkey],["p",e.arbitrator.pubkey]]});await n.sign(),await n.publish(),console.log("Published Ark contract to Nostr:",e.arkAddress)}catch(n){throw console.error("Failed to publish contract to Nostr:",n),n}}subscribeToContracts(e){this.contractCallbacks.push(e)}async getContracts(){if(!this.currentUser)return[];try{const e={kinds:[ARK_EVENT_KINDS.CONTRACT],"#p":[this.currentUser.pubkey]},n=await this.ndk.fetchEvents(e),r=[];for(const s of n)try{const o=JSON.parse(s.content);r.push(o)}catch(o){console.warn("Failed to parse contract event:",o)}return r}catch(e){return console.error("Failed to fetch contracts from Nostr:",e),[]}}async updateContract(e){await this.publishContract(e)}async notifyPendingTransaction(e,n){if(!this.currentUser)throw new Error("No authenticated Nostr user");try{const r=new NDKEvent(this.ndk,{kind:ARK_EVENT_KINDS.CONTRACT_UPDATE,content:JSON.stringify({contractId:e,transaction:n,timestamp:Date.now(),type:"pending_transaction_update"}),tags:[["ark-contract",e],["ark-update-type","pending_transaction"]]});await r.sign(),await r.publish(),console.log("Notified pending transaction update via Nostr:",e)}catch(r){throw console.error("Failed to notify pending transaction via Nostr:",r),r}}subscribeToPendingTransactions(e){this.pendingTxCallbacks.push(e)}async setupSubscriptions(){if(!this.currentUser){console.warn("No authenticated user, skipping subscriptions");return}this.userSubscription=this.ndk.subscribe({kinds:[ARK_EVENT_KINDS.USER_PROFILE]}),this.userSubscription.on("event",e=>{this.handleUserEvent(e)}),this.contractSubscription=this.ndk.subscribe({kinds:[ARK_EVENT_KINDS.CONTRACT],"#p":[this.currentUser.pubkey]}),this.contractSubscription.on("event",e=>{this.handleContractEvent(e)}),this.pendingTxSubscription=this.ndk.subscribe({kinds:[ARK_EVENT_KINDS.CONTRACT_UPDATE],"#ark-update-type":["pending_transaction"]}),this.pendingTxSubscription.on("event",e=>{this.handlePendingTxEvent(e)}),console.log("Nostr subscriptions established")}async handleUserEvent(e){try{const n=await this.getUsers();this.userCallbacks.forEach(r=>{try{r(n)}catch(s){console.error("Error in user callback:",s)}})}catch(n){console.error("Error handling user event:",n)}}async handleContractEvent(e){try{const n=await this.getContracts();this.contractCallbacks.forEach(r=>{try{r(n)}catch(s){console.error("Error in contract callback:",s)}})}catch(n){console.error("Error handling contract event:",n)}}handlePendingTxEvent(e){try{const n=JSON.parse(e.content);n.type==="pending_transaction_update"&&this.pendingTxCallbacks.forEach(r=>{try{r(n.contractId,n.transaction)}catch(s){console.error("Error in pending transaction callback:",s)}})}catch(n){console.error("Error handling pending transaction event:",n)}}getCurrentUser(){return this.currentUser}getConnectedRelays(){return Array.from(this.ndk.pool.connectedRelays()).map(e=>e.url)}async sendAcknowledgment(e,n){if(!this.currentUser)throw new Error("No authenticated Nostr user");try{const r=new NDKEvent(this.ndk,{kind:ARK_EVENT_KINDS.TX_ACK,content:JSON.stringify({contractId:e,transactionId:n,timestamp:Date.now(),type:"transaction_acknowledgment"}),tags:[["ark-contract",e],["ark-tx",n],["ark-ack","true"]]});await r.sign(),await r.publish(),console.log("Sent transaction acknowledgment via Nostr")}catch(r){throw console.error("Failed to send acknowledgment via Nostr:",r),r}}}class CommunicationManager{constructor(e){this.provider=null,this.config=e||{type:"localStorage"}}async initialize(){switch(this.provider&&await this.provider.cleanup(),this.config.type){case"localStorage":this.provider=new LocalStorageCommunication;break;case"nostr":this.provider=new NostrCommunication(this.config.relayUrls,this.config.privateKey);break;default:throw new Error(`Unknown communication provider type: ${this.config.type}`)}await this.provider.initialize(),console.log(`Communication manager initialized with ${this.config.type} provider`)}getProvider(){if(!this.provider)throw new Error("Communication manager not initialized. Call initialize() first.");return this.provider}async cleanup(){this.provider&&(await this.provider.cleanup(),this.provider=null)}}class ArkEscrowApp{constructor(){this.initializeElements(),this.initializeApp()}async initializeApp(){await this.initializeManagers(),this.setupEventListeners(),this.setupCrossTabSync()}initializeElements(){this.elements={arkServerUrl:document.getElementById("arkServerUrl"),connectServer:document.getElementById("connectServer"),serverStatus:document.getElementById("serverStatus"),createWallet:document.getElementById("createWallet"),importWallet:document.getElementById("importWallet"),importForm:document.getElementById("importForm"),privateKey:document.getElementById("privateKey"),confirmImport:document.getElementById("confirmImport"),cancelImport:document.getElementById("cancelImport"),walletInfo:document.getElementById("walletInfo"),walletAddress:document.getElementById("walletAddress"),walletPubkey:document.getElementById("walletPubkey"),walletPrivkey:document.getElementById("walletPrivkey"),walletBalance:document.getElementById("walletBalance"),copyAddress:document.getElementById("copyAddress"),copyPrivkey:document.getElementById("copyPrivkey"),hidePrivkey:document.getElementById("hidePrivkey"),refreshBalance:document.getElementById("refreshBalance"),settleBtn:document.getElementById("settleBtn"),sendBtn:document.getElementById("sendBtn"),sendForm:document.getElementById("sendForm"),sendAddress:document.getElementById("sendAddress"),sendAmount:document.getElementById("sendAmount"),confirmSend:document.getElementById("confirmSend"),cancelSend:document.getElementById("cancelSend"),refreshUsers:document.getElementById("refreshUsers"),usersList:document.getElementById("usersList"),buyerSelect:document.getElementById("buyerSelect"),sellerSelect:document.getElementById("sellerSelect"),arbitratorSelect:document.getElementById("arbitratorSelect"),contractDescription:document.getElementById("contractDescription"),createContract:document.getElementById("createContract"),refreshContracts:document.getElementById("refreshContracts"),contractsList:document.getElementById("contractsList"),notifications:document.getElementById("notifications")}}async initializeManagers(){this.notificationManager=new NotificationManager,this.serverManager=new ServerManager(this.notificationManager),this.walletManager=new WalletManager(this.notificationManager,this.serverManager),this.communicationManager=new CommunicationManager({type:"localStorage"}),await this.communicationManager.initialize();const e=this.communicationManager.getProvider();this.userManager=new UserManager(this.notificationManager,e),this.contractManager=new ContractManager(this.notificationManager,this.userManager,this.serverManager,this.walletManager,e),this.uiManager=new UIManager(this.elements,this.walletManager,this.userManager,this.contractManager,this.serverManager)}setupEventListeners(){this.elements.connectServer.addEventListener("click",()=>this.connectToServer()),this.elements.createWallet.addEventListener("click",()=>this.createWallet()),this.elements.importWallet.addEventListener("click",()=>this.uiManager.showImportForm()),this.elements.confirmImport.addEventListener("click",()=>this.importWallet()),this.elements.cancelImport.addEventListener("click",()=>this.uiManager.hideImportForm()),this.elements.copyAddress.addEventListener("click",()=>this.uiManager.copyAddress()),this.elements.copyPrivkey.addEventListener("click",()=>this.uiManager.copyPrivkey()),this.elements.hidePrivkey.addEventListener("click",()=>this.uiManager.togglePrivkeyVisibility()),this.elements.refreshBalance.addEventListener("click",()=>this.refreshBalance()),this.elements.settleBtn.addEventListener("click",()=>this.settle()),this.elements.sendBtn.addEventListener("click",()=>this.uiManager.showSendForm()),this.elements.confirmSend.addEventListener("click",()=>this.sendTransaction()),this.elements.cancelSend.addEventListener("click",()=>this.uiManager.hideSendForm()),this.elements.refreshUsers.addEventListener("click",()=>this.uiManager.updateUsersUI()),this.elements.createContract.addEventListener("click",()=>this.createEscrowContract()),this.elements.refreshContracts.addEventListener("click",()=>this.uiManager.updateContractsUI()),this.elements.privateKey.addEventListener("keypress",e=>{e.key==="Enter"&&this.importWallet()}),this.elements.sendAddress.addEventListener("keypress",e=>{e.key==="Enter"&&this.elements.sendAmount.focus()}),this.elements.sendAmount.addEventListener("keypress",e=>{e.key==="Enter"&&this.sendTransaction()}),window.addEventListener("beforeunload",()=>this.cleanup()),window.addEventListener("unload",()=>this.cleanup())}setupCrossTabSync(){window.addEventListener("storage",e=>{e.key==="arkUsers"?(console.log("Users updated in another tab, syncing..."),this.uiManager.updateUsersUI()):e.key==="arkContracts"?(console.log("Contracts updated in another tab, syncing..."),this.uiManager.updateContractsUI()):e.key==="ark-partial-transactions"&&(console.log("Partial transactions updated in another tab, syncing..."),this.uiManager.updateContractsUI())}),setInterval(()=>{this.uiManager.updateUsersUI(),this.uiManager.updateContractsUI(),this.refreshBalance()},1e4)}async connectToServer(){if(this.serverManager.isServerConnected()){await this.disconnectFromServer();return}const e=this.elements.arkServerUrl.value.trim();this.serverManager.setServerUrl(e),await this.serverManager.connectToServer()&&(this.uiManager.updateServerUI(!0),this.uiManager.showMainUI())}async disconnectFromServer(){this.serverManager.reset();const e=this.walletManager.getCurrentWallet();e&&(this.userManager.unregisterUser(e),this.walletManager.resetWallet()),this.uiManager.updateServerUI(!1),this.uiManager.hideMainUI(),this.uiManager.updateWalletDependentUI(),this.notificationManager.showInfo("Disconnected from Ark server")}async createWallet(){this.userManager.refreshUsers(),await this.walletManager.createWallet(),this.uiManager.updateWalletUI(),this.uiManager.updateBalanceUI(),this.uiManager.updateWalletDependentUI()}async importWallet(){const e=this.elements.privateKey.value;await this.walletManager.importWallet(e),this.uiManager.hideImportForm(),this.uiManager.updateWalletUI(),this.uiManager.updateBalanceUI(),this.uiManager.updateWalletDependentUI()}async refreshBalance(){try{const e=await this.walletManager.refreshBalance();this.uiManager.updateBalanceUI(e)}catch{}}async settle(){await this.walletManager.settle(),this.refreshBalance()}async sendTransaction(){const e=this.elements.sendAddress.value,n=parseFloat(this.elements.sendAmount.value);await this.walletManager.sendTransaction(e,n),this.uiManager.hideSendForm(),this.refreshBalance()}async createEscrowContract(){var l;const e=this.elements.buyerSelect.value,n=this.elements.sellerSelect.value,r=this.elements.arbitratorSelect.value,s=this.elements.contractDescription.value,o=this.walletManager.getCurrentWallet(),a=await((l=this.serverManager.getProvider())==null?void 0:l.getInfo());if(!a){this.notificationManager.showError("Not connected to server");return}const c={type:a.unilateralExitDelay<512?"blocks":"seconds",value:a.unilateralExitDelay};await this.contractManager.createEscrowContract(e,n,r,s,o,c),this.uiManager.clearContractForm(),this.uiManager.updateContractsUI()}async executeContractAction(e,n){const r=this.walletManager.getCurrentWallet();if(!r){this.notificationManager.showError("Wallet not found");return}const o=this.contractManager.getContractsForUser(r.pubkey)[e];if(!o){this.notificationManager.showError("Contract not found");return}await this.contractManager.executeContractAction(o,n,r),this.uiManager.updateContractsUI()}async approvePendingTransaction(e){const n=this.walletManager.getCurrentWallet();if(!n){this.notificationManager.showError("Wallet not found");return}const s=this.contractManager.getContractsForUser(n.pubkey)[e];if(!s){this.notificationManager.showError("Contract not found");return}await this.contractManager.approvePendingTransaction(s,n),this.uiManager.updateContractsUI()}async rejectPendingTransaction(e){const n=this.walletManager.getCurrentWallet();if(!n){this.notificationManager.showError("Wallet not found");return}const s=this.contractManager.getContractsForUser(n.pubkey)[e];if(!s){this.notificationManager.showError("Contract not found");return}await this.contractManager.rejectPendingTransaction(s,n),this.uiManager.updateContractsUI()}cleanup(){const e=this.walletManager.getCurrentWallet();e&&this.userManager.unregisterUser(e)}handleVisibilityChange(){const e=this.walletManager.getCurrentWallet();document.visibilityState==="hidden"?this.userManager.unregisterUser(e):document.visibilityState==="visible"&&e&&this.userManager.autoRegisterUser(e)}async initialize(){const e="https://mutinynet.arkade.sh",n=this.serverManager.getSavedServerUrl()||e;this.elements.arkServerUrl.value=n,await this.serverManager.connectToServer(n)?(this.uiManager.updateServerUI(!0),this.uiManager.showMainUI()):(this.uiManager.hideMainUI(),this.notificationManager.showInfo("Failed to connect to default server. Please check your connection and try again.")),this.uiManager.updateUsersUI(),this.uiManager.updateContractsUI(),this.uiManager.updateWalletDependentUI(),setInterval(()=>{this.serverManager.isServerConnected()&&(this.uiManager.updateUsersUI(),this.uiManager.updateContractsUI())},5e3)}}window.executeContractAction=async function(t,e){try{await new Promise(n=>setTimeout(n,1500)),console.log(`${e} executed for ${t}`)}catch(n){console.error(`Failed to execute ${e}`,n)}};document.addEventListener("DOMContentLoaded",async()=>{const t=new ArkEscrowApp;window.arkApp=t,await t.initialize()});export{_DebugPSBT as $,Address as A,p2tr_ms as B,CompactSizeLen as C,p2tr_ns as D,EMPTY as E,p2tr_pk as F,p2wpkh as G,p2wsh as H,CompactSize as I,OP as J,RawTx as K,ScriptNum as L,MAX_SCRIPT_BYTE_LENGTH as M,NETWORK as N,OutScript as O,PubT as P,TEST_NETWORK as Q,RawWitness as R,SignatureHash as S,Transaction as T,combinations as U,VarBytes as V,getAddress as W,sortedMultisig as X,taprootListToTree as Y,WIF as Z,_sortPubkeys as _,getPrevOut as a,bip32Path as a0,Decimal as a1,DEFAULT_SEQUENCE as a2,PSBTCombine as a3,SigHash as a4,TAPROOT_UNSPENDABLE_KEY as b,compareBytes as c,Script as d,equalBytes$2 as e,isBytes$1 as f,getInputType as g,hex$1 as h,inputBeforeSign as i,checkScript as j,tapLeafHash as k,TaprootControlBlock as l,concatBytes$3 as m,normalizeInput as n,taprootTweakPubkey as o,pubSchnorr as p,multisig as q,randomPrivateKeyBytes as r,sha256$3 as s,toVsize as t,p2ms as u,validatePubkey as v,p2pk as w,p2pkh as x,p2sh as y,p2tr as z};
