import{N as T,V as z,O as k,A as $,C as E,n as U,i as O,h as C,g as q,a as v,t as _,c as A,T as F,S as L,e as D,b as N,d as y,E as I,f as S,s as K,R as H,j as M,k as Y,v as G,P as V,l as X,m as j,p as Q,r as Z,o as J}from"./main-59028667.js";import{I as ct,a2 as ut,a1 as ht,M as lt,J as dt,a3 as ft,K as pt,L as gt,a4 as wt,Q as mt,Z as yt,$ as Et,_ as It,a0 as bt,U as kt,W as St,q as Wt,u as xt,w as zt,x as At,y as Bt,z as _t,B as Pt,D as Tt,F as $t,G as Rt,H as Ut,X as Ot,Y as Ct}from"./main-59028667.js";const b=n=>X.encode(n);function tt(n,e,s){if(!n||!n.length)throw new Error("no leafs");const t=()=>new Uint8Array(e),i=n.sort((o,h)=>b(o[0]).length-b(h[0]).length);for(const[o,h]of i){const a=h.slice(0,-1),g=h[h.length-1],d=k.decode(a);let c=[];if(d.type==="tr_ms"){const u=d.m,r=d.pubkeys.length-u;for(let l=0;l<u;l++)c.push(t());for(let l=0;l<r;l++)c.push(I)}else if(d.type==="tr_ns")for(const u of d.pubkeys)c.push(t());else{if(!s)throw new Error("Finalize: Unknown tapLeafScript");const u=Y(a,g);for(const r of s){if(!r.finalizeTaproot)continue;const l=y.decode(a),f=r.encode(l);if(f===void 0)continue;const p=l.filter(m=>{if(!S(m))return!1;try{return G(m,V.schnorr),!0}catch{return!1}}),w=r.finalizeTaproot(a,f,p.map(m=>[{pubKey:m,leafHash:u},t()]));if(w)return w.concat(b(o))}}return c.reverse().concat([a,b(o)])}throw new Error("there was no witness")}function et(n,e,s){let t=I,i;if(n.txType==="taproot"){const a=n.sighash!==L.DEFAULT?65:64;if(e.tapInternalKey&&!D(e.tapInternalKey,N))i=[new Uint8Array(a)];else if(e.tapLeafScript)i=tt(e.tapLeafScript,a,s.customScripts);else throw new Error("estimateInput/taproot: unknown input")}else{const a=()=>new Uint8Array(72),g=()=>new Uint8Array(33);let d=I,c=[];const u=n.last.type;if(u==="ms"){const r=n.last.m,l=[0];for(let f=0;f<r;f++)l.push(a());d=y.encode(l)}else if(u==="pk")d=y.encode([a()]);else if(u==="pkh")d=y.encode([a(),g()]);else if(u==="wpkh")d=I,c=[a(),g()];else if(u==="unknown"&&!s.allowUnknownInputs)throw new Error("Unknown inputs are not allowed");n.type.includes("wsh-")&&(d.length&&n.lastScript.length&&(c=y.decode(d).map(r=>{if(r===0)return I;if(S(r))return r;throw new Error(`Wrong witness op=${r}`)})),c=c.concat(n.lastScript)),n.txType==="segwit"&&(i=c),n.type.startsWith("sh-wsh-")?t=y.encode([y.encode([0,new Uint8Array(K.outputLen)])]):n.type.startsWith("sh-")?t=y.encode([...y.decode(d),n.lastScript]):n.type.startsWith("wsh-")||n.txType!=="segwit"&&(t=d)}let o=160+4*z.encode(t).length,h=!1;return i&&(o+=H.encode(i).length,h=!0),{weight:o,hasWitnesses:h}}const P=(n,e)=>{const s=n-e;return s<0n?-1:s>0n?1:0};function x(n,e={},s=T){let t;if("script"in n&&S(n.script)&&(t=n.script),"address"in n){if(typeof n.address!="string")throw new Error(`Estimator: wrong output address=${n.address}`);t=k.encode($(s).decode(n.address))}if(!t)throw new Error("Estimator: wrong output script");if(typeof n.amount!="bigint")throw new Error(`Estimator: wrong output amount=${n.amount}, should be of type bigint but got ${typeof n.amount}.`);if(t&&!e.allowUnknownOutputs&&k.decode(t).type==="unknown")throw new Error("Estimator: unknown output script type, there is a chance that input is unspendable. Pass allowUnknownOutputs=true, if you sure");return e.disableScriptCheck||M(t),t}class st{constructor(e,s,t){if(this.requiredIndices=[],this.outputs=s,this.opts=t,typeof t.feePerByte!="bigint")throw new Error(`Estimator: wrong feePerByte=${t.feePerByte}, should be of type bigint but got ${typeof t.feePerByte}.`);const i=32+4+1+107+4,o=34,h=t.dust===void 0?BigInt(i+o):t.dust;if(typeof h!="bigint")throw new Error(`Estimator: wrong dust=${t.dust}, should be of type bigint but got ${typeof t.dust}.`);const a=t.dustRelayFeeRate===void 0?3n:t.dustRelayFeeRate;if(typeof a!="bigint")throw new Error(`Estimator: wrong dustRelayFeeRate=${t.dustRelayFeeRate}, should be of type bigint but got ${typeof t.dustRelayFeeRate}.`);if(this.dust=h*a,t.requiredInputs!==void 0&&!Array.isArray(t.requiredInputs))throw new Error(`Estimator: wrong required inputs=${t.requiredInputs}`);const g=t.network||T;let d=0n,c=32;for(const f of s){const p=x(f,t,t.network);c+=32+4*z.encode(p).length,d+=f.amount}if(typeof t.changeAddress!="string")throw new Error(`Estimator: wrong change address=${t.changeAddress}`);let u=c+32+4*z.encode(k.encode($(g).decode(t.changeAddress))).length;c+=4*E.encode(s.length).length,u+=4*E.encode(s.length+1).length,this.baseWeight=c,this.changeWeight=u,this.amount=d;const r=Array.from(e);if(t.requiredInputs)for(let f=0;f<t.requiredInputs.length;f++)this.requiredIndices.push(r.push(t.requiredInputs[f])-1);const l=new Set;this.normalizedInputs=r.map(f=>{const p=U(f,void 0,void 0,t.disableScriptCheck,t.allowUnknown);O(p);const w=`${C.encode(p.txid)}:${p.index}`;if(!t.allowSameUtxo&&l.has(w))throw new Error(`Estimator: same input passed multiple times: ${w}`);l.add(w);const m=q(p,t.allowLegacyWitnessUtxo),W=v(p),B=et(m,p,this.opts),R=W.amount-t.feePerByte*BigInt(_(B.weight));return{inputType:m,normalized:p,amount:W.amount,value:R,estimate:B}})}checkInputIdx(e){if(!Number.isSafeInteger(e)||0>e||e>=this.normalizedInputs.length)throw new Error(`Wrong input index=${e}`);return e}sortIndices(e){return e.slice().sort((s,t)=>{const i=this.normalizedInputs[this.checkInputIdx(s)],o=this.normalizedInputs[this.checkInputIdx(t)],h=A(i.normalized.txid,o.normalized.txid);return h!==0?h:i.normalized.index-o.normalized.index})}sortOutputs(e){const s=e.map(i=>x(i,this.opts,this.opts.network));return e.map((i,o)=>o).sort((i,o)=>{const h=e[i].amount,a=e[o].amount,g=P(h,a);return g!==0?g:A(s[i],s[o])})}getSatoshi(e){return this.opts.feePerByte*BigInt(_(e))}get biggest(){return this.normalizedInputs.map((e,s)=>s).sort((e,s)=>P(this.normalizedInputs[s].value,this.normalizedInputs[e].value))}get smallest(){return this.biggest.reverse()}get oldest(){return this.normalizedInputs.map((e,s)=>s)}get newest(){return this.oldest.reverse()}accumulate(e,s=!1,t=!0,i=!1){let o=this.opts.alwaysChange?this.changeWeight:this.baseWeight,h=!1,a=0,g=0n;const d=this.amount,c=new Set;let u;for(const r of this.requiredIndices){if(this.checkInputIdx(r),c.has(r))throw new Error("required input encountered multiple times");const{estimate:l,amount:f}=this.normalizedInputs[r];let p=o+l.weight;!h&&l.hasWitnesses&&(p+=2);const w=p+4*E.encode(a).length;if(u=this.getSatoshi(w),o=p,l.hasWitnesses&&(h=!0),a++,g+=f,c.add(r),!i&&d+u<=g&&a>=this.requiredIndices.length)return{indices:Array.from(c),fee:u,weight:w,total:g}}for(const r of e){if(this.checkInputIdx(r),c.has(r))continue;const{estimate:l,amount:f,value:p}=this.normalizedInputs[r];let w=o+l.weight;!h&&l.hasWitnesses&&(w+=2);const m=w+4*E.encode(a).length;if(u=this.getSatoshi(m),!(s&&f+g>d+u+this.dust)&&!(t&&p<=0n)&&(o=w,l.hasWitnesses&&(h=!0),a++,g+=f,c.add(r),!i&&d+u<=g))return{indices:Array.from(c),fee:u,weight:m,total:g}}if(i){const r=o+4*E.encode(a).length;return{indices:Array.from(c),fee:u,weight:r,total:g}}}default(){const{biggest:e}=this,s=this.accumulate(e,!0,!1);return s||this.accumulate(e)}select(e){if(e==="all")return this.accumulate(this.normalizedInputs.map((t,i)=>i),!1,!0,!0);if(e==="default")return this.default();const s={Oldest:()=>this.oldest,Newest:()=>this.newest,Smallest:()=>this.smallest,Biggest:()=>this.biggest};if(e.startsWith("exact")){const[t,i]=e.slice(5).split("/");if(!s[t])throw new Error(`Estimator.select: wrong strategy=${e}`);e=i;const o=this.accumulate(s[t](),!0,!0);if(o)return o}if(e.startsWith("accum")){const t=e.slice(5);if(!s[t])throw new Error(`Estimator.select: wrong strategy=${e}`);return this.accumulate(s[t]())}throw new Error(`Estimator.select: wrong strategy=${e}`)}result(e){const s=this.select(e);if(!s)return;const{indices:t,weight:i,total:o}=s;let h=this.opts.alwaysChange;const a=this.opts.alwaysChange?i:i+(this.changeWeight-this.baseWeight),g=this.getSatoshi(a);let d=s.fee;const c=o-this.amount-g;c>this.dust&&(h=!0);let u=t,r=Array.from(this.outputs);if(h){if(d=g,c<0n)throw new Error(`Estimator.result: negative change=${c}`);r.push({address:this.opts.changeAddress,amount:c})}this.opts.bip69&&(u=this.sortIndices(u),r=this.sortOutputs(r).map(p=>r[p]));const l={inputs:u.map(p=>this.normalizedInputs[p].normalized),outputs:r,fee:d,weight:this.opts.alwaysChange?s.weight:a,change:!!h};let f;if(this.opts.createTx){const{inputs:p,outputs:w}=l;f=new F(this.opts);for(const m of p)f.addInput(m);for(const m of w)f.addOutput({...m,script:x(m,this.opts,this.opts.network)})}return Object.assign(l,{tx:f})}}function rt(n,e,s,t){const i={createTx:!0,bip69:!0,...t};return new st(n,e,i).result(s)}/*! scure-btc-signer - MIT License (c) 2022 Paul Miller (paulmillr.com) */const it={isBytes:S,concatBytes:j,compareBytes:A,pubSchnorr:Q,randomPrivateKeyBytes:Z,taprootTweakPubkey:J};export{$ as Address,ct as CompactSize,ut as DEFAULT_SEQUENCE,ht as Decimal,lt as MAX_SCRIPT_BYTE_LENGTH,T as NETWORK,dt as OP,k as OutScript,ft as PSBTCombine,pt as RawTx,H as RawWitness,y as Script,gt as ScriptNum,wt as SigHash,N as TAPROOT_UNSPENDABLE_KEY,mt as TEST_NETWORK,X as TaprootControlBlock,F as Transaction,yt as WIF,Et as _DebugPSBT,st as _Estimator,P as _cmpBig,It as _sortPubkeys,bt as bip32Path,kt as combinations,St as getAddress,q as getInputType,Wt as multisig,xt as p2ms,zt as p2pk,At as p2pkh,Bt as p2sh,_t as p2tr,Pt as p2tr_ms,Tt as p2tr_ns,$t as p2tr_pk,Rt as p2wpkh,Ut as p2wsh,rt as selectUTXO,Ot as sortedMultisig,Ct as taprootListToTree,it as utils};
